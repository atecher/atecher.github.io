<!DOCTYPE html><html class="theme-next muse use-motion" lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link href="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css"><link href="//cdn.bootcdn.net/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css"><link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css"><meta name="keywords" content="Hexo, NexT"><link rel="alternate" href="/atom.xml" title="Atecher's blog" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="//qn.atecher.com/mts/20180418/3853306649789440?v=5.1.1"><meta property="og:type" content="website"><meta property="og:title" content="Atecher&#39;s blog"><meta property="og:url" content="http://blog.atecher.com/index.html"><meta property="og:site_name" content="Atecher&#39;s blog"><meta property="og:locale" content="zh-Hans"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Atecher&#39;s blog"><script type="text/javascript" id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Muse",sidebar:{position:"left",display:"post",offset:12,offset_float:0,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!0,motion:!0,duoshuo:{userId:"0",author:"博主"},algolia:{applicationID:"PITP4EHINM",apiKey:"8123eba2f0fd8a9eacbaf3113776710f",indexName:"atecher_hexo",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><link rel="canonical" href="http://blog.atecher.com/"><script>!function(){var t=document.createElement("script"),e=window.location.protocol.split(":")[0];t.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(t,s)}()</script><title>Atecher's blog - 胸有丘壑,目有山川</title></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans"><div class="container sidebar-position-left page-home"><div class="headband"></div><a href="https://github.com/atecher" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513;color:#fff;position:absolute;top:0;border:0;right:0" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">Atecher's blog</span> <span class="logo-line-after"><i></i></span></a></div><h1 class="site-subtitle" itemprop="description">胸有丘壑,目有山川</h1></div><div class="site-nav-toggle"><button><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-sitemap"><a href="/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i><br>站点地图</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="algolia-popup popup search-popup"><div class="algolia-search"><div class="algolia-search-input-icon"><i class="fa fa-search"></i></div><div class="algolia-search-input" id="algolia-search-input"></div></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div id="algolia-pagination" class="algolia-pagination"></div></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><section id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.atecher.com/2018/04/11/Java-Design-Patterns/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Atecher"><meta itemprop="description" content=""><meta itemprop="image" content="//qn.atecher.com/mts/20180418/3853594527466496"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Atecher's blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/04/11/Java-Design-Patterns/" itemprop="url">Java23种设计模式</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-11T16:00:10+00:00">2018-04-11 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/软件工程/" itemprop="url" rel="index"><span itemprop="name">软件工程</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/04/11/Java-Design-Patterns/#SOHUCS" itemprop="discussionUrl"><span id="url::http://blog.atecher.com/2018/04/11/Java-Design-Patterns/" class="cy_cmt_count" data-xid="2018/04/11/Java-Design-Patterns/" itemprop="commentsCount"></span> </a><span id="/2018/04/11/Java-Design-Patterns/" class="leancloud_visitors" data-flag-title="Java23种设计模式"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数 </span><span class="leancloud-visitors-count"></span></span></span></div></header><div class="post-body" itemprop="articleBody"><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。本章系<strong>Java之美[从菜鸟到高手演变]系列</strong>之设计模式，我们会以理论与实践相结合的方式来进行本章的学习，希望广大程序爱好者，学好设计模式，做一个优秀的软件工程师！</p><div class="post-button text-center"><a class="btn" href="/2018/04/11/Java-Design-Patterns/#more" rel="contents">阅读全文 &raquo;</a></div></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.atecher.com/2018/04/11/Java-Algorithms-Problem/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Atecher"><meta itemprop="description" content=""><meta itemprop="image" content="//qn.atecher.com/mts/20180418/3853594527466496"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Atecher's blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/04/11/Java-Algorithms-Problem/" itemprop="url">Java算法题汇总</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-11T14:00:10+00:00">2018-04-11 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Algorithms/" itemprop="url" rel="index"><span itemprop="name">Algorithms</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/04/11/Java-Algorithms-Problem/#SOHUCS" itemprop="discussionUrl"><span id="url::http://blog.atecher.com/2018/04/11/Java-Algorithms-Problem/" class="cy_cmt_count" data-xid="2018/04/11/Java-Algorithms-Problem/" itemprop="commentsCount"></span> </a><span id="/2018/04/11/Java-Algorithms-Problem/" class="leancloud_visitors" data-flag-title="Java算法题汇总"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数 </span><span class="leancloud-visitors-count"></span></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？</p><p>1.程序分析：这个是典型的<a href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97" target="_blank" rel="noopener">斐波那契数列</a>，兔子的规律为数列1,1,2,3,5,8,13,21….</p><p>具体分析如下：</p><blockquote><p>f(1) = 1(第1个月有一对兔子）<br>f(2) = 1(第2个月还是一对兔子）<br>f(3) = 2(原来有一对兔子，第3个开始，每个月生一对兔子）<br>f(4) = 3(原来有两对兔子，有一对可以生育）<br>f(5) = 5(原来有3对兔子，第3个月出生的那对兔子也可以生育了，那么现在有两对兔子可以生育）<br>f(6) = 8(原来有5对兔子，第4个月出生的那对兔子也可以生育了，那么现在有3对兔子可以生育）<br>…………..<br>由以上可以看出，第n个月兔子的对数为<br>f(n) = f(n - 1) + f(n - 2);<br>f(n-1)是上个月的兔子数量，是原来有的。<br>f(n-2)是可以生育的兔子数，即多出来的数量。第n-2个月开始后的第3个月是第n个月，此时第n-2个月时的兔子都可以生育了</p></blockquote><div class="post-button text-center"><a class="btn" href="/2018/04/11/Java-Algorithms-Problem/#more" rel="contents">阅读全文 &raquo;</a></div></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.atecher.com/2018/04/03/Java-GC/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Atecher"><meta itemprop="description" content=""><meta itemprop="image" content="//qn.atecher.com/mts/20180418/3853594527466496"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Atecher's blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/04/03/Java-GC/" itemprop="url">深入理解Java垃圾回收机制</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-03T00:00:00+00:00">2018-04-03 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/04/03/Java-GC/#SOHUCS" itemprop="discussionUrl"><span id="url::http://blog.atecher.com/2018/04/03/Java-GC/" class="cy_cmt_count" data-xid="2018/04/03/Java-GC/" itemprop="commentsCount"></span> </a><span id="/2018/04/03/Java-GC/" class="leancloud_visitors" data-flag-title="深入理解Java垃圾回收机制"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数 </span><span class="leancloud-visitors-count"></span></span></span></div></header><div class="post-body" itemprop="articleBody"><h1 id="垃圾回收机制的意义"><a href="#垃圾回收机制的意义" class="headerlink" title="垃圾回收机制的意义"></a>垃圾回收机制的意义</h1><p>Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。<strong>垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。</strong></p><blockquote><p>ps:内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为“对象游离”。</p></blockquote><div class="post-button text-center"><a class="btn" href="/2018/04/03/Java-GC/#more" rel="contents">阅读全文 &raquo;</a></div></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.atecher.com/2018/03/23/clustered-index-and-noncustered-index/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Atecher"><meta itemprop="description" content=""><meta itemprop="image" content="//qn.atecher.com/mts/20180418/3853594527466496"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Atecher's blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2018/03/23/clustered-index-and-noncustered-index/" itemprop="url">聚集索引和非聚集索引</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-23T11:33:10+00:00">2018-03-23 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/DB/" itemprop="url" rel="index"><span itemprop="name">DB</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2018/03/23/clustered-index-and-noncustered-index/#SOHUCS" itemprop="discussionUrl"><span id="url::http://blog.atecher.com/2018/03/23/clustered-index-and-noncustered-index/" class="cy_cmt_count" data-xid="2018/03/23/clustered-index-and-noncustered-index/" itemprop="commentsCount"></span> </a><span id="/2018/03/23/clustered-index-and-noncustered-index/" class="leancloud_visitors" data-flag-title="聚集索引和非聚集索引"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数 </span><span class="leancloud-visitors-count"></span></span></span></div></header><div class="post-body" itemprop="articleBody"><h2 id="官方说法"><a href="#官方说法" class="headerlink" title="官方说法"></a>官方说法</h2><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>一种索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。</p><p>聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。</p><p>聚集索引对于那些经常要搜索范围值的列特别有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。例如，如果应用程序执行 的一个查询经常检索某一日期范围内的记录，则使用聚集索引可以迅速找到包含开始日期的行，然后检索表中所有相邻的行，直到到达结束日期。这样有助于提高此 类查询的性能。同样，如果对从表中检索的数据进行排序时经常要用到某一列，则可以将该表在该列上聚集（物理排序），避免每次查询该列时都进行排序，从而节 省成本。</p><p>当索引值唯一时，使用聚集索引查找特定的行也很有效率。例如，使用唯一雇员 ID 列 emp_id 查找特定雇员的最快速的方法，是在 emp_id 列上创建聚集索引或 PRIMARY KEY 约束。</p><div class="post-button text-center"><a class="btn" href="/2018/03/23/clustered-index-and-noncustered-index/#more" rel="contents">阅读全文 &raquo;</a></div></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.atecher.com/2017/11/06/Java-VM-Explanation-1/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Atecher"><meta itemprop="description" content=""><meta itemprop="image" content="//qn.atecher.com/mts/20180418/3853594527466496"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Atecher's blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2017/11/06/Java-VM-Explanation-1/" itemprop="url">Java虚拟机详解：JVM常见问题总结</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-06T14:00:10+00:00">2017-11-06 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2017/11/06/Java-VM-Explanation-1/#SOHUCS" itemprop="discussionUrl"><span id="url::http://blog.atecher.com/2017/11/06/Java-VM-Explanation-1/" class="cy_cmt_count" data-xid="2017/11/06/Java-VM-Explanation-1/" itemprop="commentsCount"></span> </a><span id="/2017/11/06/Java-VM-Explanation-1/" class="leancloud_visitors" data-flag-title="Java虚拟机详解：JVM常见问题总结"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数 </span><span class="leancloud-visitors-count"></span></span></span></div></header><div class="post-body" itemprop="articleBody"><p>先把本文的目录画一个思维导图：</p><p><img src="//qn.atecher.com/mts/20180418/3853291052336128" alt="Java-VM-Explanation-1-1"></p><div class="post-button text-center"><a class="btn" href="/2017/11/06/Java-VM-Explanation-1/#more" rel="contents">阅读全文 &raquo;</a></div></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.atecher.com/2017/10/22/Introduce-Quick-Sort/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Atecher"><meta itemprop="description" content=""><meta itemprop="image" content="//qn.atecher.com/mts/20180418/3853594527466496"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Atecher's blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2017/10/22/Introduce-Quick-Sort/" itemprop="url">浅谈算法和数据结构之快速排序</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-22T14:00:10+00:00">2017-10-22 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Data-Structures/" itemprop="url" rel="index"><span itemprop="name">Data Structures</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2017/10/22/Introduce-Quick-Sort/#SOHUCS" itemprop="discussionUrl"><span id="url::http://blog.atecher.com/2017/10/22/Introduce-Quick-Sort/" class="cy_cmt_count" data-xid="2017/10/22/Introduce-Quick-Sort/" itemprop="commentsCount"></span> </a><span id="/2017/10/22/Introduce-Quick-Sort/" class="leancloud_visitors" data-flag-title="浅谈算法和数据结构之快速排序"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数 </span><span class="leancloud-visitors-count"></span></span></span></div></header><div class="post-body" itemprop="articleBody"><p>上篇文章介绍了时间复杂度为O(nlgn)的合并排序，本篇文章介绍时间复杂度同样为O(nlgn)但是排序速度比合并排序更快的快速排序(Quick Sort)。</p><p>快速排序是<a href="http://www.siam.org/pdf/news/637.pdf" target="_blank" rel="noopener">20世纪科技领域的十大算法之一</a> ，他由<a href="http://en.wikipedia.org/wiki/Tony_Hoare" target="_blank" rel="noopener">C. A. R. Hoare</a>于1960年提出的一种划分交换排序。</p><p><a href="//qn.atecher.com/mts/20180418/3853286368494592"><img src="//qn.atecher.com/mts/20180418/3853286368494592" alt="Quick Sort founder"></a></p><div class="post-button text-center"><a class="btn" href="/2017/10/22/Introduce-Quick-Sort/#more" rel="contents">阅读全文 &raquo;</a></div></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.atecher.com/2017/10/21/Introduce-Merge-Sort/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Atecher"><meta itemprop="description" content=""><meta itemprop="image" content="//qn.atecher.com/mts/20180418/3853594527466496"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Atecher's blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2017/10/21/Introduce-Merge-Sort/" itemprop="url">浅谈算法和数据结构之合并排序</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-21T14:00:10+00:00">2017-10-21 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Data-Structures/" itemprop="url" rel="index"><span itemprop="name">Data Structures</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2017/10/21/Introduce-Merge-Sort/#SOHUCS" itemprop="discussionUrl"><span id="url::http://blog.atecher.com/2017/10/21/Introduce-Merge-Sort/" class="cy_cmt_count" data-xid="2017/10/21/Introduce-Merge-Sort/" itemprop="commentsCount"></span> </a><span id="/2017/10/21/Introduce-Merge-Sort/" class="leancloud_visitors" data-flag-title="浅谈算法和数据结构之合并排序"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数 </span><span class="leancloud-visitors-count"></span></span></span></div></header><div class="post-body" itemprop="articleBody"><p>合并排序，顾名思义，就是通过将两个有序的序列合并为一个大的有序的序列的方式来实现排序。合并排序是一种典型的分治算法：首先将序列分为两部分，然后对每一部分进行循环递归的排序，然后逐个将结果进行合并。</p><p><a href="//qn.atecher.com/mts/20180417/3852398591837184"><img src="//qn.atecher.com/mts/20180417/3852398591837184" alt="Definition of Merge Sort"></a></p><p>合并排序最大的优点是它的时间复杂度为O(nlgn)，这个是我们之前的选择排序和插入排序所达不到的。他还是一种稳定性排序，也就是相等的元素在序列中的相对位置在排序前后不会发生变化。他的唯一缺点是，需要利用额外的N的空间来进行排序。</p><div class="post-button text-center"><a class="btn" href="/2017/10/21/Introduce-Merge-Sort/#more" rel="contents">阅读全文 &raquo;</a></div></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.atecher.com/2017/10/20/Introduction-Insertion-and-Selection-and-Shell-Sort/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Atecher"><meta itemprop="description" content=""><meta itemprop="image" content="//qn.atecher.com/mts/20180418/3853594527466496"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Atecher's blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2017/10/20/Introduction-Insertion-and-Selection-and-Shell-Sort/" itemprop="url">浅谈算法和数据结构之基本排序算法</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-20T19:00:10+00:00">2017-10-20 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Data-Structures/" itemprop="url" rel="index"><span itemprop="name">Data Structures</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2017/10/20/Introduction-Insertion-and-Selection-and-Shell-Sort/#SOHUCS" itemprop="discussionUrl"><span id="url::http://blog.atecher.com/2017/10/20/Introduction-Insertion-and-Selection-and-Shell-Sort/" class="cy_cmt_count" data-xid="2017/10/20/Introduction-Insertion-and-Selection-and-Shell-Sort/" itemprop="commentsCount"></span> </a><span id="/2017/10/20/Introduction-Insertion-and-Selection-and-Shell-Sort/" class="leancloud_visitors" data-flag-title="浅谈算法和数据结构之基本排序算法"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数 </span><span class="leancloud-visitors-count"></span></span></span></div></header><div class="post-body" itemprop="articleBody"><p>本篇开始学习排序算法。排序与我们日常生活中息息相关，比如，我们要从电话簿中找到某个联系人首先会按照姓氏排序、买火车票会按照出发时间或者时长排序、买东西会按照销量或者好评度排序、查找文件会按照修改时间排序等等。在计算机程序设计中，排序和查找也是最基本的算法，很多其他的算法都是以排序算法为基础，在一般的数据处理或分析中，通常第一步就是进行排序，比如说二分查找，首先要对数据进行排序。在<a href="https://en.wikipedia.org/wiki/Donald_Knuth" target="_blank" rel="noopener">Donald Knuth</a>。 的计算机程序设计的艺术这四卷书中，有一卷是专门介绍排序和查找的。</p><div class="post-button text-center"><a class="btn" href="/2017/10/20/Introduction-Insertion-and-Selection-and-Shell-Sort/#more" rel="contents">阅读全文 &raquo;</a></div></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.atecher.com/2017/10/18/Introduce-B-Tree-and-B-Plus-Tree/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Atecher"><meta itemprop="description" content=""><meta itemprop="image" content="//qn.atecher.com/mts/20180418/3853594527466496"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Atecher's blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2017/10/18/Introduce-B-Tree-and-B-Plus-Tree/" itemprop="url">浅谈算法和数据结构之平衡查找树之B树</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-18T19:40:10+00:00">2017-10-18 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Data-Structures/" itemprop="url" rel="index"><span itemprop="name">Data Structures</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2017/10/18/Introduce-B-Tree-and-B-Plus-Tree/#SOHUCS" itemprop="discussionUrl"><span id="url::http://blog.atecher.com/2017/10/18/Introduce-B-Tree-and-B-Plus-Tree/" class="cy_cmt_count" data-xid="2017/10/18/Introduce-B-Tree-and-B-Plus-Tree/" itemprop="commentsCount"></span> </a><span id="/2017/10/18/Introduce-B-Tree-and-B-Plus-Tree/" class="leancloud_visitors" data-flag-title="浅谈算法和数据结构之平衡查找树之B树"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数 </span><span class="leancloud-visitors-count"></span></span></span></div></header><div class="post-body" itemprop="articleBody"><p>前面讲解了平衡查找树中的2-3树以及其实现红黑树。2-3树种，一个节点最多有2个key，而红黑树则使用染色的方式来标识这两个key。</p><p>维基百科对B树的定义为“在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B-树为系统<strong>最优化大块数据的读和写操作</strong>。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。”</p><div class="post-button text-center"><a class="btn" href="/2017/10/18/Introduce-B-Tree-and-B-Plus-Tree/#more" rel="contents">阅读全文 &raquo;</a></div></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><link itemprop="mainEntityOfPage" href="http://blog.atecher.com/2017/10/18/Introduce-Red-Black-Tree/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="Atecher"><meta itemprop="description" content=""><meta itemprop="image" content="//qn.atecher.com/mts/20180418/3853594527466496"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Atecher's blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a class="post-title-link" href="/2017/10/18/Introduce-Red-Black-Tree/" itemprop="url">浅谈算法和数据结构之平衡查找树之红黑树</a></h2><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-18T19:00:10+00:00">2017-10-18 </time></span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Data-Structures/" itemprop="url" rel="index"><span itemprop="name">Data Structures</span> </a></span></span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/2017/10/18/Introduce-Red-Black-Tree/#SOHUCS" itemprop="discussionUrl"><span id="url::http://blog.atecher.com/2017/10/18/Introduce-Red-Black-Tree/" class="cy_cmt_count" data-xid="2017/10/18/Introduce-Red-Black-Tree/" itemprop="commentsCount"></span> </a><span id="/2017/10/18/Introduce-Red-Black-Tree/" class="leancloud_visitors" data-flag-title="浅谈算法和数据结构之平衡查找树之红黑树"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数 </span><span class="leancloud-visitors-count"></span></span></span></div></header><div class="post-body" itemprop="articleBody"><p>前面一篇文章介绍了2-3查找树，可以看到，2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgN，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，本文介绍一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）。</p><div class="post-button text-center"><a class="btn" href="/2017/10/18/Introduce-Red-Black-Tree/#more" rel="contents">阅读全文 &raquo;</a></div></div><div></div><div></div><div></div><footer class="post-footer"><div class="post-eof"></div></footer></article></section><nav class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a></nav></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><section class="site-overview sidebar-panel sidebar-panel-active"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="//qn.atecher.com/mts/20180418/3853594527466496" alt="Atecher"><p class="site-author-name" itemprop="name">Atecher</p><p class="site-description motion-element" itemprop="description"></p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">66</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">13</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">43</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/atecher" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i> GitHub </a></span><span class="links-of-author-item"><a href="http://weibo.com/atecher" target="_blank" title="微博"><i class="fa fa-fw fa-weibo"></i> 微博 </a></span><span class="links-of-author-item"><a href="http://www.jianshu.com/u/649bbf6c8e00" target="_blank" title="简书"><i class="fa fa-fw fa-heartbeat"></i> 简书</a></span></div></section></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Atecher</span></div><div class="powered-by">由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动</div><div class="theme-info">主题 - <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script type="text/javascript">"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery/2.1.3/jquery.min.js"></script><script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script><script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script><script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/velocity/1.2.1/velocity.min.js"></script><script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/velocity/1.2.1/velocity.ui.min.js"></script><script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/fancybox/2.1.5/jquery.fancybox.js"></script><script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/canvas-nest.js/1.0.0/canvas-nest.min.js"></script><script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script><script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script><script id="cy_cmt_num" src="https://changyan.sohu.com/upload/plugins/plugins.list.count.js?clientId=cyt9KwbIC"></script><link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/instantsearch.js/1.5.0/instantsearch.min.css"><script src="//cdn.bootcdn.net/ajax/libs/instantsearch.js/1.5.0/instantsearch.min.js"></script><script src="/js/src/algolia-search.js?v=5.1.1"></script><script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script><script>AV.initialize("iKJa9lh8QllLpxC5NKCTW8rO-gzGzoHsz","3iKSyFgeNgGq801gTFotjTFW")</script><script>function showTime(e){var t=new AV.Query(e),c=[],u=$(".leancloud_visitors");u.each(function(){c.push($(this).attr("id").trim())}),t.containedIn("url",c),t.find().done(function(e){var t=".leancloud-visitors-count";if(0!==e.length){for(var n=0;n<e.length;n++){var o=e[n],i=o.get("url"),s=o.get("time"),r=document.getElementById(i);$(r).find(t).text(s)}for(n=0;n<c.length;n++){var i=c[n],r=document.getElementById(i),l=$(r).find(t);""==l.text()&&l.text(0)}}else u.find(t).text(0)}).fail(function(e,t){console.log("Error: "+t.code+" "+t.message)})}function addCount(i){var e=$(".leancloud_visitors"),s=e.attr("id").trim(),r=e.attr("data-flag-title").trim(),t=new AV.Query(i);t.equalTo("url",s),t.find({success:function(e){var t,n,o;0<e.length?((t=e[0]).fetchWhenSave(!0),t.increment("time"),t.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to save Visitor num, with error message: "+t.message)}})):(n=new i,(o=new AV.ACL).setPublicReadAccess(!0),o.setPublicWriteAccess(!0),n.setACL(o),n.set("title",r),n.set("url",s),n.set("time",1),n.save(null,{success:function(e){$(document.getElementById(s)).find(".leancloud-visitors-count").text(e.get("time"))},error:function(e,t){console.log("Failed to create")}}))},error:function(e){console.log("Error:"+e.code+" "+e.message)}})}$(function(){var e=AV.Object.extend("Counter");1==$(".leancloud_visitors").length?addCount(e):1<$(".post-title-link").length&&showTime(e)})</script></body></html>