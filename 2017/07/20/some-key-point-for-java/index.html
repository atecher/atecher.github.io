<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
    
  
  <link href="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css">







  

<link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Java基础,">





  <link rel="alternate" href="/atom.xml" title="Atecher's blog" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="//qn.atecher.com/mts/20180418/3853306649789440?v=5.1.1">






<meta name="description" content="基础这东西很重要，各个公司都很看重。基础这些东西无非几部分：逻辑思维，语言，操作系统，网络，数据结构和算法，再加上行业和领域的相关知识。这些都需要我们在平时积累和学习，今天这篇文章主要罗列一下Java语言中的一些技术点，内容会随着时间不断添加。">
<meta name="keywords" content="Java基础">
<meta property="og:type" content="article">
<meta property="og:title" content="Java的一些关键技术点">
<meta property="og:url" content="http://blog.atecher.com/2017/07/20/some-key-point-for-java/index.html">
<meta property="og:site_name" content="Atecher&#39;s blog">
<meta property="og:description" content="基础这东西很重要，各个公司都很看重。基础这些东西无非几部分：逻辑思维，语言，操作系统，网络，数据结构和算法，再加上行业和领域的相关知识。这些都需要我们在平时积累和学习，今天这篇文章主要罗列一下Java语言中的一些技术点，内容会随着时间不断添加。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2022-01-28T10:43:41.505Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java的一些关键技术点">
<meta name="twitter:description" content="基础这东西很重要，各个公司都很看重。基础这些东西无非几部分：逻辑思维，语言，操作系统，网络，数据结构和算法，再加上行业和领域的相关知识。这些都需要我们在平时积累和学习，今天这篇文章主要罗列一下Java语言中的一些技术点，内容会随着时间不断添加。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'PITP4EHINM',
      apiKey: '8123eba2f0fd8a9eacbaf3113776710f',
      indexName: 'atecher_hexo',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.atecher.com/2017/07/20/some-key-point-for-java/">



<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  <title>Java的一些关键技术点 | Atecher's blog</title>
  














</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>
	<a href="https://github.com/atecher" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Atecher's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">胸有丘壑,目有山川</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            站点地图
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://blog.atecher.com/2017/07/20/some-key-point-for-java/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Atecher">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="//qn.atecher.com/mts/20180418/3853594527466496">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Atecher's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Java的一些关键技术点</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-20T10:35:46+00:00">
                2017-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/开发技巧/" itemprop="url" rel="index">
                    <span itemprop="name">开发技巧</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2017/07/20/some-key-point-for-java/#SOHUCS" itemprop="discussionUrl">
                  <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="2017/07/20/some-key-point-for-java/" itemprop="commentsCount"></span>
                </a>
              
            
          

          
          
             <span id="/2017/07/20/some-key-point-for-java/" class="leancloud_visitors" data-flag-title="Java的一些关键技术点">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </span></div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>基础这东西很重要，各个公司都很看重。基础这些东西无非几部分：逻辑思维，语言，操作系统，网络，数据结构和算法，再加上行业和领域的相关知识。这些都需要我们在平时积累和学习，今天这篇文章主要罗列一下Java语言中的一些技术点，内容会随着时间不断添加。<br><a id="more"></a></p>
<h2 id="Switch能否用string做参数"><a href="#Switch能否用string做参数" class="headerlink" title="Switch能否用string做参数"></a>Switch能否用string做参数</h2><p>在jdk 7 之前，switch 只能支持 byte、short、char、int 这几个基本数据类型和其对应的封装类型。switch后面的括号里面只能放int类型的值，但由于byte，short，char类型，它们会 自动 转换为int类型（精精度小的向大的转化），所以它们也支持。</p>
<blockquote>
<p>对于精度比int大的类型，比如long、float，doulble，不会自动转换为int，如果想使用，就必须强转为int，如(int)float;</p>
</blockquote>
<h3 id="JDK7之前"><a href="#JDK7之前" class="headerlink" title="JDK7之前"></a>JDK7之前</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">switchTest</span><span class="params">(<span class="keyword">int</span> expression)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (expression)&#123;    <span class="comment">// 括号里是一个表达式，结果是个整数</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:     <span class="comment">// 括号里是一个表达式，结果是个整数</span></span><br><span class="line">            System.out.println(<span class="string">"this is one"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            System.out.println(<span class="string">"this is two"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            System.out.println(<span class="string">"this is three"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">"other"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JDK7之后"><a href="#JDK7之后" class="headerlink" title="JDK7之后"></a>JDK7之后</h3><p>jdk7以后，整形，枚举类型，boolean，字符串都可以。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String string = <span class="string">"123"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (string) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"123"</span>:</span><br><span class="line">            System.out.println(<span class="string">"123"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"abc"</span>:</span><br><span class="line">            System.out.println(<span class="string">"abc"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">"defauls"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h3><p>jdk7并没有新的指令来处理switch，而是通过调用switch中String.hashCode,将String转换为int从而进行判断。</p>
<h2 id="equals和-的区别"><a href="#equals和-的区别" class="headerlink" title="equals和==的区别"></a>equals和==的区别</h2><p>这个问题我们就不撸代码了，纯文字分析一下。</p>
<p>简单来讲：</p>
<ol>
<li>==是判断两者是不是同一个东西;</li>
<li>equals是判断两者是否一样，可能是同一个东西，也可以是两个东西长得完全一样。</li>
</ol>
<p>详细来讲：</p>
<p><strong>如果比较对象是值变量</strong>：只能使用==。因为基本类型不是对象，equals()是对象的方法。<br><strong>如果比较对象是引用型变量</strong>：</p>
<ul>
<li>==是判断两个引用是否指向同一个实例。</li>
<li>equals是Object方法，默认使用了==进行比较。如果您自己写了一个类，没有重写equals方法，那对不住了–跟==没毛区别。</li>
<li>但是如果列位如果重写了equals方法，那么比较规则就由各位自己定义了。</li>
</ul>
<h2 id="Java的基本数据类型以及封装类"><a href="#Java的基本数据类型以及封装类" class="headerlink" title="Java的基本数据类型以及封装类"></a>Java的基本数据类型以及封装类</h2><p>java提供了九种基本数据类型，包括：boolean, byte, char, short,  int, long, float, double, void（存在异议）。<br>同时，java也提供了这些类型的封装类，分别为：Boolean, Byte, Character, Short, Integer, Long, Float, Double, Void。</p>
<h3 id="为什么Java会这么做"><a href="#为什么Java会这么做" class="headerlink" title="为什么Java会这么做"></a>为什么Java会这么做</h3><p>在java中使用基本类型来存储语言支持的基本数据类型，这里没有采用对象，而是使用了传统的面向过程语言所采用的基本类在型，主要是从性能方面来考虑的：因为即使最简单的数学计算，<strong>使用对象来处理也会引起一些开销</strong>，而这些开销对于数学计算本来是毫无必要的。但是在java中，<strong>泛型类包括预定义的集合，使用的参数都是对象类型</strong>，无法直接使用这些基本数据类型，所以java又提供了这些基本类型的包装器。</p>
<h3 id="有什么区别"><a href="#有什么区别" class="headerlink" title="有什么区别"></a>有什么区别</h3><ul>
<li>基本数据类型只能按值传递，而封装类按引用传递。</li>
<li>基本类型在堆栈中创建；而对于对象类型，对象在堆中创建，对象的引用在堆栈中创建。基本类型由于在堆栈中，效率会比较高，但是可能会存在内存泄漏的问题。</li>
</ul>
<h3 id="基本数据类型介绍"><a href="#基本数据类型介绍" class="headerlink" title="基本数据类型介绍"></a>基本数据类型介绍</h3><p>Java基本数据类型分为两大类：boolean类型和数值类型。数值类型可分为整数类型和浮点类型，而其中字符类型可单独对待。所以Java只包含8种基本数据类型。</p>
<blockquote>
<p>注意！字符串不是基本数据类型，字符串是一个类，是一个引用类型。这个在下一篇我们会仔细讨论它！</p>
</blockquote>
<ul>
<li><strong>boolean</strong>:数值只有true和false，不能用0代替。其他数值类型不能转换成boolean。包装类–Boolean</li>
<li><strong>byte</strong>:内存8位，无符号位时最大存储255，表数范围：-128~127。包装类–Byte</li>
<li><strong>short</strong>:内存16位，无符号位时最大存储65536，表数范围：-32768~32767。包装类–Short</li>
<li><strong>int</strong>:内存32位，无符号位时最大存储2的32次方减1，表数范围：负的2的31次方到正的2的31次方减1。包装类–Integer。</li>
<li><strong>long</strong>:内存64位，无符号位时最大存储2的64次方减1，表数范围：负的2的63次方到正的2的63次方减1。包装类–Long。</li>
<li><strong>float</strong>:内存32位，数据范围在3.4e-45~1.4e38，直接赋值时必须在数字后加上f或F。包装类–Float。</li>
<li><strong>double</strong>:内存64位，数据范围在4.9e-324~1.8e308，赋值时可以加d或D也可以不加。包装类–Double。</li>
<li><strong>char</strong>:16位，存储Unicode字符集，用单引号赋值。可以参与加减乘除运算的，也可以比较大小的！！包装类–Character。</li>
</ul>
<h3 id="封装类的共性"><a href="#封装类的共性" class="headerlink" title="封装类的共性"></a>封装类的共性</h3><ol>
<li>带有基本值参数并创建包装类对象的构造函数.如可以利用Integer包装类创建对象:Integer obj=new Integer(145);</li>
<li>带有字符串参数并创建包装类对象的构造函数.如:new Integer(“-45.36”);</li>
<li>可生成对象基本值的typeValue方法,如:int num=obj.intValue();</li>
<li>将字符串转换为基本值的 parseType方法,如Integer.parseInt(args[0]);</li>
<li>因为有装进Map的几率，所以java设计了包装类里的哈希值，生成哈稀表代码的hashCode方法,如:obj.hasCode();</li>
<li>对同一个类的两个对象进行比较的equals()方法,如:obj1.eauqls(obj2);</li>
<li>生成字符串表示法的toString()方法,如:obj.toString().</li>
<li>自动装包/拆包大大方便了基本类型数据和它们包装类地使用。</li>
</ol>
<h3 id="一些知识点"><a href="#一些知识点" class="headerlink" title="一些知识点"></a>一些知识点</h3><h4 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a1 = <span class="number">1</span>;</span><br><span class="line">        Integer a2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        Integer b1 = <span class="number">200</span>;</span><br><span class="line">        Integer b2 = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">        Integer c1 = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//        Integer c2 = new Integer(1);      官方不推荐这种建对象的方法喔</span></span><br><span class="line">        Integer c2 = Integer.valueOf(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Integer d1 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line">        Integer d2 = Integer.valueOf(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"a1==a2?"</span> + (a1 == a2));</span><br><span class="line">        System.out.println(<span class="string">"b1==b2?"</span> + (b1 == b2));</span><br><span class="line">        System.out.println(<span class="string">"c1==c2?"</span> + (c1 == c2));</span><br><span class="line">        System.out.println(<span class="string">"d1==d2?"</span> + (d1 == d2));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>上面一段代码的运行结果就是我们要深思的东西啦，也是结合源码要懂的东西。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a1==a2? true </span><br><span class="line">b1==b2? false </span><br><span class="line">c1==c2? false </span><br><span class="line">d1==d2? false</span><br></pre></td></tr></table></figure>
<p>第一个为什么是true呢，因为Integer的缓存机制嘛，刚刚我们看到的，缓存了[-128,127],这些可以直接取出。而剩余的为什么是false，因为他们都超过了缓存的那个范围，就建了个新对象咯。</p>
<h2 id="Object有哪些公用方法"><a href="#Object有哪些公用方法" class="headerlink" title="Object有哪些公用方法"></a>Object有哪些公用方法</h2><p>Object是所有类的父类，任何类都默认继承Object。<br>Object类到底实现了哪些方法？</p>
<h3 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a>clone方法</h3><p>创建并返回此对象的一个副本<br>保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。<br>PS:浅复制是指当对象的字段值被复制时，字段引用的对象不会被复制<br>例如，如果一个对象有一个指向字符串的字段，并且我们对该对象做了一个浅复制，那么两个对象将引用同一个字符串</p>
<h3 id="getClass方法"><a href="#getClass方法" class="headerlink" title="getClass方法"></a>getClass方法</h3><p>final方法，获得运行时类型。</p>
<h3 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h3><p>该方法用得比较多，一般子类都有覆盖，返回该对象字符串。</p>
<h3 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h3><p>该方法用于释放资源(由垃圾回收器调用)。因为无法确定该方法什么时候被调用，很少使用。</p>
<h3 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h3><p>该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。</p>
<h3 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h3><p>该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。<br>一般必须满足obj1.equals(obj2)==true。可以推出obj1.hashCode()==obj2.hashCode()。<br>但是hashCode相等不一定就满足equals。<br>不过为了提高效率，应该尽量使上面两个条件接近等价。</p>
<h3 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a>wait方法</h3><p>wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。<br>wait()方法一直等待，直到获得锁或者被中断。<br>wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。<br>调用该方法后当前线程进入睡眠状态，直到以下事件发生。</p>
<ol>
<li>其他线程调用了该对象的notify方法。</li>
<li>其他线程调用了该对象的notifyAll方法。</li>
<li>其他线程调用了interrupt中断该线程。</li>
<li>时间间隔到了。</li>
</ol>
<p>此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。</p>
<h3 id="notify方法"><a href="#notify方法" class="headerlink" title="notify方法"></a>notify方法</h3><p>该方法唤醒在该对象上等待的某个线程。</p>
<h3 id="notifyAll方法"><a href="#notifyAll方法" class="headerlink" title="notifyAll方法"></a>notifyAll方法</h3><p>该方法唤醒在该对象上等待的所有线程。</p>
<h2 id="Java的四种引用，强弱软虚，用到的场景"><a href="#Java的四种引用，强弱软虚，用到的场景" class="headerlink" title="Java的四种引用，强弱软虚，用到的场景"></a>Java的四种引用，强弱软虚，用到的场景</h2><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>强引用不会被GC回收，并且在java.lang.ref里也没有实际的对应类型，平时工作接触的最多的就是强引用。<br>Object obj = new Object();这里的obj引用便是一个强引用。<br>如果一个对象具有强引用，那就类似于必不可少的生活用品，垃圾回收器绝不会回收它。<br>当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>如果一个对象只具有软引用，那就类似于可有可物的生活用品。<br>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。<br>只 要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用（weak reference）在强度上弱于软引用，通过类WeakReference来表示。<br>它的作用是引用一个对象，但是并不阻止该对象被回收。如果使用一个强引用的话，只要该引用存在，那么被引用的对象是不能被回收的。<br>弱引用则没有这个问题。在垃圾回收器运行的时候，如果一个对象的所有引用都是弱引用的话，该对象会被回收。<br>弱引用的作用在于解决强引用所带来的对象之间在存活时间上的耦合关系。<br>弱引用最常见的用处是在集合类中，尤其在哈希表中。哈希表的接口允许使用任何Java对象作为键来使用。<br>当一个键值对被放入到哈希表中之后，哈希表对象本身就有了对这些键和值对象的引用。<br>如果这种引用是强引用的话，那么只要哈希表对象本身还存活，其中所包含的键和值对象是不会被回收的。<br>如果某个存活时间很长的哈希表中包含的键值对很多，最终就有可能消耗掉JVM中全部的内存。<br>对于这种情况的解决办法就是使用弱引用来引用这些对象，这样哈希表中的键和值对象都能被垃圾回收。<br>Java中提供了WeakHashMap来满足这一常见需求。</p>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>在介绍幽灵引用之前，要先介绍Java提供的<strong>对象终止化机制</strong>（finalization）。在Object类里面有个<strong>finalize</strong>方法，其设计的初衷是在一个对象被真正回收之前，可以用来执行一些清理的工作。<br>因为Java并没有提供类似C++的析构函数一样的机制，就通过 finalize方法来实现。但是问题在于垃圾回收器的运行时间是不固定的，所以这些清理工作的实际运行时间也是不能预知的。<br>幽灵引用（phantom reference）可以解决这个问题。在创建幽灵引用PhantomReference的时候必须要指定一个引用队列。<br>当一个对象的finalize方法已经被调用了之后，这个对象的幽灵引用会被加入到队列中。<br>通过检查该队列里面的内容就知道一个对象是不是已经准备要被回收了。<br>幽灵引用及其队列的使用情况并不多见，主要用来实现比较精细的内存使用控制，这对于<strong>移动设备</strong>来说是很有意义的。<br>程序可以在确定一个对象要被回收之后，再申请内存创建新的对象。<strong>通过这种方式可以使得程序所消耗的内存维持在一个相对较低的数量。</strong></p>
<h2 id="Hashcode的作用"><a href="#Hashcode的作用" class="headerlink" title="Hashcode的作用"></a>Hashcode的作用</h2><p>Java中的集合（Collection）有两类，一类是List，再有一类是Set。<br>前者集合内的元素是有序的，元素可以重复；后者元素无序，但元素不可重复。<br>那么这里就有一个比较严重的问题了：要想保证元素不重复，可两个元素是否重复应该依据什么来判断呢？<br>这就是Object.equals方法了。但是，如果每增加一个元素就检查一次，那么当元素很多时，后添加到集合中的元素比较的次数就非常多了。<br>也就是说，如果集合中现在已经有1000个元素，那么第1001个元素加入集合时，它就要调用1000次equals方法。这显然会大大降低效率。<br>于是，Java采用了哈希表的原理。<br>哈希算法也称为散列算法，是将数据依特定算法直接指定到一个地址上。<br>put方法是用来向HashMap中添加新的元素，从put方法的具体实现可知，会先调用hashCode方法得到该元素的hashCode值，然后查看table中是否存在该hashCode值，如果存在则调用equals方法重新确定是否存在该元素，如果存在，则更新value值，否则将新的元素添加到HashMap中。从这里可以看出，hashCode方法的存在是为了减少equals方法的调用次数，从而提高程序效率。</p>
<p>因此有人会说，可以直接根据hashcode值判断两个对象是否相等吗？肯定是不可以的，因为不同的对象可能会生成相同的hashcode值。虽然不能根据hashcode值判断两个对象是否相等，但是可以直接根据hashcode值判断两个对象不等，如果两个对象的hashcode值不等，则必定是两个不同的对象。如果要判断两个对象是否真正相等，必须通过equals方法。</p>
<p>　1. 也就是说对于两个对象，如果调用equals方法得到的结果为true，则两个对象的hashcode值必定相等；<br>　2. 如果equals方法得到的结果为false，则两个对象的hashcode值不一定不同；<br>　3. 如果两个对象的hashcode值不等，则equals方法得到的结果必定为false；<br>　4. 如果两个对象的hashcode值相等，则equals方法得到的结果未知。
　　</p>
<h2 id="ArrayList、Vector、LinkedList"><a href="#ArrayList、Vector、LinkedList" class="headerlink" title="ArrayList、Vector、LinkedList"></a>ArrayList、Vector、LinkedList</h2><p>ArrayList,LinkedList,Vestor这三个类都实现了java.util.List接口，但它们有各自不同的特性，主要如下： </p>
<h3 id="同步性"><a href="#同步性" class="headerlink" title="同步性"></a>同步性</h3><p>ArrayList,LinkedList是不同步的，而Vestor是同步的。所以如果不要求线程安全的话，可以使用ArrayList或LinkedList，可以节省为同步而耗费的开销。但在多线程的情况下，有时候就不得不使用Vector了。当然，也可以通过一些办法包装ArrayList,LinkedList，使他们也达到同步，但效率可能会有所降低。 </p>
<h3 id="数据增长"><a href="#数据增长" class="headerlink" title="数据增长"></a>数据增长</h3><p>从内部实现机制来讲ArrayList和Vector都是使用Objec的数组形式来存储的。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%,所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。 </p>
<h3 id="检索、插入、删除对象的效率"><a href="#检索、插入、删除对象的效率" class="headerlink" title="检索、插入、删除对象的效率"></a>检索、插入、删除对象的效率</h3><p>ArrayList和Vector中,从指定的位置(index)检索一个对象，或在集合的末尾插入、删除一个对象的时间是一样的，可表示为O(1)。<br>但是，如果在集合的其他位置增加或移除元素那么花费的时间会呈线形增长:O(n-i),其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置。<br>为什么会这样呢？因为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行(n-i)个对象的位移操作。LinkedList中，在插入、删除集合中任何位置的元素所花费的时间都是一样的—O(1)，但它在索引一个元素的时候比较慢，为O(i),其中i是索引的位置。 </p>
<hr>
<p>一般大家都知道ArrayList和LinkedList的大致区别：</p>
<ol>
<li>ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。</li>
<li>对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。</li>
<li>对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。</li>
</ol>
<p>ArrayList和LinkedList是两个集合类，用于存储一系列的对象引用(references)。例如我们可以用ArrayList来存储一系列的String或者Integer。那么ArrayList和LinkedList在性能上有什么差别呢？什么时候应该用ArrayList什么时候又该用LinkedList呢？</p>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>首先一点关键的是，ArrayList的内部实现是基于基础的对象数组的，因此，它使用get方法访问列表中的任意一个元素时(random access)，它的速度要比LinkedList快。LinkedList中的get方法是按照顺序从列表的一端开始检查，直到另外一端。对LinkedList而言，访问列表中的某个指定元素没有更快的方法了。<br>假设我们有一个很大的列表，它里面的元素已经排好序了，这个列表可能是ArrayList类型的也可能是LinkedList类型的，现在我们对这个列表来进行二分查找(binary search)，比较列表是ArrayList和LinkedList时的查询速度，看下面的程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.mangocity.test;   </span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;   </span><br><span class="line"><span class="keyword">import</span> java.util.List;   </span><br><span class="line"><span class="keyword">import</span> java.util.Random;   </span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;   </span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;   </span><br><span class="line"><span class="keyword">import</span> java.util.Collections;   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestList</span> </span>&#123;   </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">50000</span>;   </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> List values;   </span><br><span class="line">     <span class="keyword">static</span> &#123;   </span><br><span class="line">         Integer vals[]=<span class="keyword">new</span> Integer[N];   </span><br><span class="line">         Random r=<span class="keyword">new</span> Random();   </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>,currval=<span class="number">0</span>;i&lt;N;i++)&#123;   </span><br><span class="line">             vals=<span class="keyword">new</span> Integer(currval);   </span><br><span class="line">             currval+=r.nextInt(<span class="number">100</span>)+<span class="number">1</span>;   </span><br><span class="line">         &#125;   </span><br><span class="line">         values=Arrays.asList(vals);   </span><br><span class="line">     &#125;   </span><br><span class="line">  </span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">timeList</span><span class="params">(List lst)</span></span>&#123;   </span><br><span class="line">         <span class="keyword">long</span> start=System.currentTimeMillis();   </span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;   </span><br><span class="line">             <span class="keyword">int</span> index=Collections.binarySearch(lst, values.get(i));   </span><br><span class="line">             <span class="keyword">if</span>(index!=i)   </span><br><span class="line">                 System.out.println(<span class="string">"***错误***"</span>);   </span><br><span class="line">         &#125;   </span><br><span class="line">         <span class="keyword">return</span> System.currentTimeMillis()-start;   </span><br><span class="line">     &#125;   </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;   </span><br><span class="line">         System.out.println(<span class="string">"ArrayList消耗时间："</span>+timeList(<span class="keyword">new</span> ArrayList(values)));   </span><br><span class="line">         System.out.println(<span class="string">"LinkedList消耗时间："</span>+timeList(<span class="keyword">new</span> LinkedList(values)));   </span><br><span class="line">     &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我得到的输出 是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList消耗时间：15 </span><br><span class="line">LinkedList消耗时间：2596</span><br></pre></td></tr></table></figure>
<p>这个结果不是固定的，但是基本上ArrayList的时间要明显小于LinkedList的时间。因此在这种情况下不宜用LinkedList。二分查找法使用的随机访问(random access)策略，而LinkedList是不支持快速的随机访问的。对一个LinkedList做随机访问所消耗的时间与这个list的大小是成比例的。而相应的，在ArrayList中进行随机访问所消耗的时间是固定的。</p>
<p>这是否表明ArrayList总是比LinkedList性能要好呢？这并不一定，在某些情况下LinkedList的表现要优于ArrayList，有些算法在LinkedList中实现时效率更高。比方说，利用 Collections.reverse方法对列表进行反转时，其性能就要好些。</p>
<p>看这样一个例子，加入我们有一个列表，要对其进行大量的插入和删除操作，在这种情况下LinkedList就是一个较好的选择。请看如下一个极端的例子，我们重复的在一个列表的开端插入一个元素： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mangocity.test;   </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> java.util.*;   </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;   </span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N=<span class="number">50000</span>;   </span><br><span class="line">     <span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">timeList</span><span class="params">(List list)</span></span>&#123;   </span><br><span class="line">     <span class="keyword">long</span> start=System.currentTimeMillis();   </span><br><span class="line">     Object o = <span class="keyword">new</span> Object();   </span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)   </span><br><span class="line">         list.add(<span class="number">0</span>, o);   </span><br><span class="line">     <span class="keyword">return</span> System.currentTimeMillis()-start;   </span><br><span class="line">     &#125;   </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;   </span><br><span class="line">         System.out.println(<span class="string">"ArrayList耗时："</span>+timeList(<span class="keyword">new</span> ArrayList()));   </span><br><span class="line">         System.out.println(<span class="string">"LinkedList耗时："</span>+timeList(<span class="keyword">new</span> LinkedList()));   </span><br><span class="line">     &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这时我的输出结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ArrayList耗时：2463 </span><br><span class="line">LinkedList耗时：15</span><br></pre></td></tr></table></figure></p>
<p>这和前面一个例子的结果截然相反，当一个元素被加到ArrayList的最开端时，所有已经存在的元素都会后移，这就意味着数据移动和复制上的开销。相反的，将一个元素加到LinkedList的最开端只是简单的未这个元素分配一个记录，然后调整两个连接。在LinkedList的开端增加一个元素的开销是固定的，而在ArrayList的开端增加一个元素的开销是与ArrayList的大小成比例的。</p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>在LinkedList中有一个私有的内部类，定义如下： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;   </span><br><span class="line">     Object element;   </span><br><span class="line">     Entry next;   </span><br><span class="line">     Entry previous;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个Entry对象 reference列表中的一个元素，同时还有在LinkedList中它的上一个元素和下一个元素。一个有1000个元素的LinkedList对象将有1000个链接在一起的Entry对象，每个对象都对应于列表中的一个元素。这样的话，在一个LinkedList结构中将有一个很大的空间开销，因为它要存储这1000个Entity对象的相关信息。</p>
<p>ArrayList使用一个内置的数组来存储元素，这个数组的起始容量是10.当数组需要增长时，新的容量按 如下公式获得：新容量=(旧容量*3)/2+1，也就是说每一次容量大概会增长50%。这就意味着，如果你有一个包含大量元素的ArrayList对象， 那么最终将有很大的空间会被浪费掉，这个浪费是由ArrayList的工作方式本身造成的。如果没有足够的空间来存放新的元素，数组将不得不被重新进行分 配以便能够增加新的元素。对数组进行重新分配，将会导致性能急剧下降。如果我们知道一个ArrayList将会有多少个元素，我们可以通过构造方法来指定容量。我们还可以通过trimToSize方法在ArrayList分配完毕之后去掉浪费掉的空间。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>ArrayList和LinkedList在性能上各 有优缺点，都有各自所适用的地方，总的说来可以描述如下：</p>
<p>1．对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是 统一的，分配一个内部Entry对象。<br>2．在ArrayList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。</p>
<p>3．LinkedList不 支持高效的随机元素访问。<br>4．ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间 </p>
<p>可以这样说：当操作是在一列 数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能；当你的操作是在一列数据的前面或中 间添加或删除数据,并且按照顺序访问其中的元素时,就应该使用LinkedList了。 </p>
<p>所以，如果只是查找特定位置的元素或只在集合的末端增加、移除元素，那么使用Vector或ArrayList都可以。如果是对其它指定位置的插入、删除操作，最好选择LinkedList。</p>
<h2 id="String、StringBuffer和StringBuilder"><a href="#String、StringBuffer和StringBuilder" class="headerlink" title="String、StringBuffer和StringBuilder"></a>String、StringBuffer和StringBuilder</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String：字符串常量，字符串长度不可变。Java中String是immutable（不可变）的。<br>String类的包含如下定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The value is used for character storage. */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** The offset is the first index of the storage that is used. */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** The count is the number of characters in the String. */</span>  </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure></p>
<p>用于存放字符的数组被声明为final的，因此只能赋值一次，不可再更改。</p>
<h3 id="StringBuffer（JDK1-0）"><a href="#StringBuffer（JDK1-0）" class="headerlink" title="StringBuffer（JDK1.0）"></a>StringBuffer（JDK1.0）</h3><p>StringBuffer：字符串变量（Synchronized，即线程安全）。如果要频繁对字符串内容进行修改，出于效率考虑最好使用StringBuffer，如果想转成String类型，可以调用StringBuffer的toString()方法。</p>
<p>Java.lang.StringBuffer线程安全的可变字符序列。在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。</p>
<p>StringBuffer上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而insert方法则在指定的点添加字符。例如，如果z引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用z.append(“le”)会使字符串缓冲区包含“startle”，而z.insert(4, “le”)将更改字符串缓冲区，使之包含“starlet”。</p>
<h3 id="StringBuilder（JDK5-0）"><a href="#StringBuilder（JDK5-0）" class="headerlink" title="StringBuilder（JDK5.0）"></a>StringBuilder（JDK5.0）</h3><p>StringBuilder：字符串变量（非线程安全）。在内部，StringBuilder对象被当作是一个包含字符序列的变长数组。</p>
<p>java.lang.StringBuilder是一个可变的字符序列，是JDK5.0新增的。此类提供一个与StringBuffer兼容的API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。</p>
<p>其构造方法如下：</p>
<table>
<thead>
<tr>
<th>构造方法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>StringBuilder()</td>
<td style="text-align:left">创建一个容量为16的StringBuilder对象（16个空元素）</td>
</tr>
<tr>
<td>StringBuilder(CharSequence cs)</td>
<td style="text-align:left">创建一个包含cs的StringBuilder对象，末尾附加16个空元素 </td>
</tr>
<tr>
<td>StringBuilder(int initCapacity)</td>
<td style="text-align:left">创建一个容量为initCapacity的StringBuilder对象 </td>
</tr>
<tr>
<td>StringBuilder(String s)</td>
<td style="text-align:left">创建一个包含s的StringBuilder对象，末尾附加16个空元素 </td>
</tr>
</tbody>
</table>
<p>在大部分情况下，StringBuilder &gt; StringBuffer。这主要是由于前者不需要考虑线程安全。</p>
<h3 id="三者区别"><a href="#三者区别" class="headerlink" title="三者区别"></a>三者区别</h3><p>String 类型和StringBuffer的主要性能区别：String是不可变的对象,因此在每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象，所以经常改变内容的字符串最好不要用String，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，性能就会降低。</p>
<p>使用StringBuffer类时，每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。所以多数情况下推荐使用StringBuffer，特别是字符串对象经常改变的情况下。</p>
<p>在某些特别情况下，String对象的字符串拼接其实是被JavaCompiler编译成了StringBuffer对象的拼接，所以这些时候String对象的速度并不会比StringBuffer对象慢，例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"This is only a"</span> + <span class="string">" simple"</span> + <span class="string">" test"</span>;  </span><br><span class="line">StringBuffer Sb = <span class="keyword">new</span> StringBuilder(<span class="string">"This is only a"</span>).append(<span class="string">" simple"</span>).append(<span class="string">" test"</span>);</span><br></pre></td></tr></table></figure></p>
<p>生成 String s1对象的速度并不比 StringBuffer慢。其实在Java Compiler里，自动做了如下转换：<br>Java Compiler直接把上述第一条语句编译为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"This is only a simple test"</span>;</span><br></pre></td></tr></table></figure></p>
<p>所以速度很快。但要注意的是，如果拼接的字符串来自另外的String对象的话，Java Compiler就不会自动转换了，速度也就没那么快了，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s2 = <span class="string">"This is only a"</span>;  </span><br><span class="line">String s3 = <span class="string">" simple"</span>;  </span><br><span class="line">String s4 = <span class="string">" test"</span>;  </span><br><span class="line">String s1 = s2 + s3 + s4;</span><br></pre></td></tr></table></figure>
<p>这时候，Java Compiler会规规矩矩的按照原来的方式去做，String的concatenation（即+）操作利用了StringBuilder（或StringBuffer）的append方法实现，此时，对于上述情况，若s2，s3，s4采用String定义，拼接时需要额外创建一个StringBuffer（或StringBuilder），之后将StringBuffer转换为String；若采用StringBuffer（或StringBuilder），则不需额外创建StringBuffer。</p>
<h3 id="使用策略"><a href="#使用策略" class="headerlink" title="使用策略"></a>使用策略</h3><ol>
<li><p>基本原则：如果要操作少量的数据，用String；单线程操作大量数据，用StringBuilder；多线程操作大量数据，用StringBuffer。</p>
</li>
<li><p>不要使用String类的”+”来进行频繁的拼接，因为那样的性能极差的，应该使用StringBuffer或StringBuilder类，这在Java的优化上是一条比较重要的原则。例如：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String result = <span class="string">""</span>;  </span><br><span class="line"><span class="keyword">for</span> (String s : hugeArray) &#123;  </span><br><span class="line">    result = result + s;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 使用StringBuilder  </span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();  </span><br><span class="line"><span class="keyword">for</span> (String s : hugeArray) &#123;  </span><br><span class="line">    sb.append(s);  </span><br><span class="line">&#125;  </span><br><span class="line">String result = sb.toString();</span><br></pre></td></tr></table></figure>
<p>当出现上面的情况时，显然我们要采用第二种方法，因为第一种方法，每次循环都会创建一个String result用于保存结果，除此之外二者基本相同（对于jdk1.5及之后版本）。</p>
<ol>
<li><p>为了获得更好的性能，在构造StringBuffer或StringBuilder时应尽可能指定它们的容量。当然，如果你操作的字符串长度（length）不超过16个字符就不用了，当不指定容量（capacity）时默认构造一个容量为16的对象。不指定容量会显著降低性能。</p>
</li>
<li><p>StringBuilder一般使用在方法内部来完成类似”+”功能，因为是线程不安全的，所以用完以后可以丢弃。StringBuffer主要用在全局变量中。</p>
</li>
<li><p>相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。而在现实的模块化编程中，负责某一模块的程序员不一定能清晰地判断该模块是否会放入多线程的环境中运行，因此：除非确定系统的瓶颈是在StringBuffer上，并且确定你的模块不会运行在多线程模式下，才可以采用StringBuilder；否则还是用StringBuffer。</p>
</li>
</ol>
<h2 id="Map、Set、List、Queue、Stack的特点与用法"><a href="#Map、Set、List、Queue、Stack的特点与用法" class="headerlink" title="Map、Set、List、Queue、Stack的特点与用法"></a>Map、Set、List、Queue、Stack的特点与用法</h2><p>这个篇幅太长，另起一篇:<a href="/2017/09/27/Map-Set-List-Queue-Stack/">Map、Set、List、Queue、Stack的特点与用法</a>。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java基础/" rel="tag"># Java基础</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/12/22/Introduce-2-3-Search-Tree/" rel="next" title="浅谈算法和数据结构之平衡查找树之2-3树">
                <i class="fa fa-chevron-left"></i> 浅谈算法和数据结构之平衡查找树之2-3树
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/07/28/Java-规避-不要随便设置随机种子/" rel="prev" title="Java_规避_不要随便设置随机种子">
                Java_规避_不要随便设置随机种子 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="SOHUCS"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="//qn.atecher.com/mts/20180418/3853594527466496" alt="Atecher">
          <p class="site-author-name" itemprop="name">Atecher</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">66</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/atecher" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/atecher" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/649bbf6c8e00" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-heartbeat"></i>
                  
                  简书
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Switch能否用string做参数"><span class="nav-number">1.</span> <span class="nav-text">Switch能否用string做参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK7之前"><span class="nav-number">1.1.</span> <span class="nav-text">JDK7之前</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK7之后"><span class="nav-number">1.2.</span> <span class="nav-text">JDK7之后</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Why"><span class="nav-number">1.3.</span> <span class="nav-text">Why</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#equals和-的区别"><span class="nav-number">2.</span> <span class="nav-text">equals和==的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java的基本数据类型以及封装类"><span class="nav-number">3.</span> <span class="nav-text">Java的基本数据类型以及封装类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么Java会这么做"><span class="nav-number">3.1.</span> <span class="nav-text">为什么Java会这么做</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有什么区别"><span class="nav-number">3.2.</span> <span class="nav-text">有什么区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本数据类型介绍"><span class="nav-number">3.3.</span> <span class="nav-text">基本数据类型介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#封装类的共性"><span class="nav-number">3.4.</span> <span class="nav-text">封装类的共性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一些知识点"><span class="nav-number">3.5.</span> <span class="nav-text">一些知识点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Integer"><span class="nav-number">3.5.1.</span> <span class="nav-text">Integer</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Object有哪些公用方法"><span class="nav-number">4.</span> <span class="nav-text">Object有哪些公用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#clone方法"><span class="nav-number">4.1.</span> <span class="nav-text">clone方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getClass方法"><span class="nav-number">4.2.</span> <span class="nav-text">getClass方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#toString方法"><span class="nav-number">4.3.</span> <span class="nav-text">toString方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#finalize方法"><span class="nav-number">4.4.</span> <span class="nav-text">finalize方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#equals方法"><span class="nav-number">4.5.</span> <span class="nav-text">equals方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hashCode方法"><span class="nav-number">4.6.</span> <span class="nav-text">hashCode方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#wait方法"><span class="nav-number">4.7.</span> <span class="nav-text">wait方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#notify方法"><span class="nav-number">4.8.</span> <span class="nav-text">notify方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#notifyAll方法"><span class="nav-number">4.9.</span> <span class="nav-text">notifyAll方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java的四种引用，强弱软虚，用到的场景"><span class="nav-number">5.</span> <span class="nav-text">Java的四种引用，强弱软虚，用到的场景</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#强引用"><span class="nav-number">5.1.</span> <span class="nav-text">强引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软引用"><span class="nav-number">5.2.</span> <span class="nav-text">软引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#弱引用"><span class="nav-number">5.3.</span> <span class="nav-text">弱引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚引用"><span class="nav-number">5.4.</span> <span class="nav-text">虚引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Hashcode的作用"><span class="nav-number">6.</span> <span class="nav-text">Hashcode的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ArrayList、Vector、LinkedList"><span class="nav-number">7.</span> <span class="nav-text">ArrayList、Vector、LinkedList</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#同步性"><span class="nav-number">7.1.</span> <span class="nav-text">同步性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据增长"><span class="nav-number">7.2.</span> <span class="nav-text">数据增长</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#检索、插入、删除对象的效率"><span class="nav-number">7.3.</span> <span class="nav-text">检索、插入、删除对象的效率</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度"><span class="nav-number">7.3.1.</span> <span class="nav-text">时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空间复杂度"><span class="nav-number">7.3.2.</span> <span class="nav-text">空间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结"><span class="nav-number">7.3.3.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#String、StringBuffer和StringBuilder"><span class="nav-number">8.</span> <span class="nav-text">String、StringBuffer和StringBuilder</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#String"><span class="nav-number">8.1.</span> <span class="nav-text">String</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuffer（JDK1-0）"><span class="nav-number">8.2.</span> <span class="nav-text">StringBuffer（JDK1.0）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#StringBuilder（JDK5-0）"><span class="nav-number">8.3.</span> <span class="nav-text">StringBuilder（JDK5.0）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三者区别"><span class="nav-number">8.4.</span> <span class="nav-text">三者区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用策略"><span class="nav-number">8.5.</span> <span class="nav-text">使用策略</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map、Set、List、Queue、Stack的特点与用法"><span class="nav-number">9.</span> <span class="nav-text">Map、Set、List、Queue、Stack的特点与用法</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Atecher</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/velocity/1.2.1/velocity.min.js"></script>

  
  <script type="text/javascript" src="//cdn.bootcdn.net/ajax/libs/velocity/1.2.1/velocity.ui.min.js"></script>

  
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  




  
    <script type="text/javascript">
    (function(){
      var appid = 'cyt9KwbIC';
      var conf = 'bc0e6852e38545fe217c021fe412293e';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){
        window.changyan.api.config({appid:appid,conf:conf})});
      }
    })();
    </script>
    <script type="text/javascript" src="https://changyan.sohu.com/upload/plugins/plugins.count.js"></script>
  



  




  
  
  
    
  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/instantsearch.js/1.5.0/instantsearch.min.css">

  
  
    
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/instantsearch.js/1.5.0/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.1"></script>



  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("080EavKIlkfhitmF8Eu2gKDd-gzGzoHsz", "so1s6UPhJO8sKEbMoBgkYMhm");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
