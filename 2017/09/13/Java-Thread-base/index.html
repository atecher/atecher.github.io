<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
    
  
  <link href="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet" type="text/css">







  

<link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.2/css/font-awesome.min.css" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Java,Thread,">





  <link rel="alternate" href="/atom.xml" title="Atecher's blog" type="application/atom+xml">




  <link rel="shortcut icon" type="image/x-icon" href="http://qn.atecher.com/mts/20180418/3853306649789440?v=5.1.1">






<meta name="description" content="我们使用多线程的目的是为了更好的利用CPU资源，从而达到提升系统性能的目的。当然还会有一些其他的一些原因，诸如改善程序结构，异步处理等… 很多人都对其中的一些概念不够明确,如同步、并发等等,让我们先建立一个数据字典,以免产生误会。">
<meta name="keywords" content="Java,Thread">
<meta property="og:type" content="article">
<meta property="og:title" content="Java-Thread-基础">
<meta property="og:url" content="http://atecher.com/2017/09/13/Java-Thread-base/index.html">
<meta property="og:site_name" content="Atecher&#39;s blog">
<meta property="og:description" content="我们使用多线程的目的是为了更好的利用CPU资源，从而达到提升系统性能的目的。当然还会有一些其他的一些原因，诸如改善程序结构，异步处理等… 很多人都对其中的一些概念不够明确,如同步、并发等等,让我们先建立一个数据字典,以免产生误会。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://qn.atecher.com/mts/20180403/3832334064026624">
<meta property="og:image" content="http://qn.atecher.com/Thread_State.png">
<meta property="og:image" content="http://qn.atecher.com/thread_status_from_new_2_dead.jpg">
<meta property="og:image" content="http://qn.atecher.com/mts/20180403/3832334095647744">
<meta property="og:image" content="http://qn.atecher.com/thread_status_from_new_2_dead_with_methods.jpg">
<meta property="og:image" content="http://qn.atecher.com/a_java_monitor.png">
<meta property="og:image" content="http://qn.atecher.com/main_memory.png">
<meta property="og:image" content="http://qn.atecher.com/thread_exception_catch.png">
<meta property="og:image" content="http://qn.atecher.com/synchronize_Lock_performance.png">
<meta property="og:image" content="http://qn.atecher.com/BlockingQueue.png">
<meta property="og:image" content="http://qn.atecher.com/ThreadPoolExecutor.png">
<meta property="og:updated_time" content="2022-01-28T06:25:55.771Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java-Thread-基础">
<meta name="twitter:description" content="我们使用多线程的目的是为了更好的利用CPU资源，从而达到提升系统性能的目的。当然还会有一些其他的一些原因，诸如改善程序结构，异步处理等… 很多人都对其中的一些概念不够明确,如同步、并发等等,让我们先建立一个数据字典,以免产生误会。">
<meta name="twitter:image" content="http://qn.atecher.com/mts/20180403/3832334064026624">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: 'PITP4EHINM',
      apiKey: '8123eba2f0fd8a9eacbaf3113776710f',
      indexName: 'atecher_hexo',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://atecher.com/2017/09/13/Java-Thread-base/">



<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  <title>Java-Thread-基础 | Atecher's blog</title>
  














</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>
	<a href="https://github.com/atecher" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Atecher's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">胸有丘壑,目有山川</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            站点地图
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  
  <div class="algolia-popup popup search-popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
  </div>




    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://atecher.com/2017/09/13/Java-Thread-base/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Atecher">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://qn.atecher.com/mts/20180418/3853594527466496">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Atecher's blog">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">Java-Thread-基础</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-13T19:15:33+00:00">
                2017-09-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-comment-o"></i>
              </span>
              
                <a href="/2017/09/13/Java-Thread-base/#SOHUCS" itemprop="discussionUrl">
                  <span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="2017/09/13/Java-Thread-base/" itemprop="commentsCount"></span>
                </a>
              
            
          

          
          
             <span id="/2017/09/13/Java-Thread-base/" class="leancloud_visitors" data-flag-title="Java-Thread-基础">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </span></div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>我们使用多线程的目的是为了更好的利用CPU资源，从而达到提升系统性能的目的。当然还会有一些其他的一些原因，诸如改善程序结构，异步处理等…</p>
<p>很多人都对其中的一些概念不够明确,如同步、并发等等,让我们先建立一个数据字典,以免产生误会。</p>
<a id="more"></a>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>多线程：指的是这个程序（一个进程）运行时产生了不止一个线程</li>
<li>并行与并发：<ul>
<li>并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。</li>
<li>并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。并发往往在场景中有公用的资源，那么针对这个公用的资源往往产生瓶颈，我们会用TPS或者QPS来反应这个系统的处理能力。</li>
</ul>
</li>
</ul>
<p><a href="http://qn.atecher.com/mts/20180403/3832334064026624" target="_blank" rel="noopener"><img src="http://qn.atecher.com/mts/20180403/3832334064026624" alt=""></a></p>
<p>并发与并行</p>
<ul>
<li>线程安全：经常用来描绘一段代码。指在并发的情况之下，该代码经过多线程使用，线程的调度顺序不影响任何结果。这个时候使用多线程，我们只需要关注系统的内存，cpu是不是够用即可。反过来，线程不安全就意味着线程的调度顺序会影响最终结果，如不加事务的转账代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transferMoney</span><span class="params">(User from, User to, <span class="keyword">float</span> amount)</span></span>&#123;</span><br><span class="line">        to.setMoney(to.getBalance() + amount);</span><br><span class="line">        from.setMoney(from.getBalance() - amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>同步：Java中的同步指的是通过人为的控制和调度，保证共享资源的多线程访问成为线程安全，来保证结果的准确。如上面的代码简单加入<code>@synchronized</code>关键字。在保证结果准确的同时，提高性能，才是优秀的程序。线程安全的优先级高于性能。</li>
</ul>
<h2 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h2><p>对于单核CPU来说(对于多核CPU,此处就理解为一个核),CPU在一个时刻只能运行一个线程,当在运行一个线程的过程中转去运行另外一个线程,这个叫做线程上下文切换(对于进程也是类似)。</p>
<p>由于可能当前线程的任务并没有执行完毕,所以在切换时需要保存线程的运行状态,以便下次重新切换回来时能够继续切换之前的状态运行。举个简单的例子:比如一个线程A正在读取一个文件的内容,正读到文件的一半,此时需要暂停线程A,转去执行线程B,当再次切换回来执行线程A的时候,我们不希望线程A又从文件的开头来读取。</p>
<p>因此需要记录线程A的运行状态,那么会记录哪些数据呢？因为下次恢复时需要知道在这之前当前线程已经执行到哪条指令了,所以需要记录程序计数器的值,另外比如说线程正在进行某个计算的时候被挂起了,那么下次继续执行的时候需要知道之前挂起时变量的值时多少,因此需要记录CPU寄存器的状态。所以一般来说,线程上下文切换过程中会记录程序计数器、CPU寄存器状态等数据。</p>
<p>说简单点的:对于线程的上下文切换实际上就是 <strong>存储和恢复CPU状态的过程,它使得线程执行能够从中断点恢复执行。</strong></p>
<p>虽然多线程可以使得任务执行的效率得到提升,但是由于在线程切换时同样会带来一定的开销代价,并且多个线程会导致系统资源占用的增加,所以在进行多线程编程时要注意这些因素。</p>
<h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>在java.lang包中定义, 继承Thread类必须重写run()方法<br>创建好了自己的线程类之后,就可以创建线程对象了,然后通过start()方法去启动线程。注意,不是调用run()方法启动线程,run方法中只是定义需要执行的任务,如果调用run方法,即相当于在主线程中执行run方法,跟普通的方法调用没有任何区别,此时并不会创建一个新的线程来执行定义的任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        num++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"主动创建的第"</span>+num+<span class="string">"个线程"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在上面代码中,通过调用start()方法,就会创建一个新的线程了。为了分清start()方法调用和run()方法调用的区别,请看下面一个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"name:"</span>+name+<span class="string">" 子线程ID:"</span>+Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"主线程ID:"</span>+Thread.currentThread().getId());</span><br><span class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread(<span class="string">"thread1"</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        MyThread thread2 = <span class="keyword">new</span> MyThread(<span class="string">"thread2"</span>);</span><br><span class="line">        thread2.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果:</span></span><br><span class="line"><span class="comment">主线程ID:1</span></span><br><span class="line"><span class="comment">name:thread2 子线程ID:1</span></span><br><span class="line"><span class="comment">name:thread1 子线程ID:8</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>从输出结果可以得出以下结论:</p>
<ol>
<li>thread1和thread2的线程ID不同,thread2和主线程ID相同,说明通过run方法调用并不会创建新的线程,而是在主线程中直接运行run方法,跟普通的方法调用没有任何区别；</li>
<li>虽然thread1的start方法调用在thread2的run方法前面调用,但是先输出的是thread2的run方法调用的相关信息,说明新线程创建的过程不会阻塞主线程的后续执行。</li>
</ol>
<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>在Java中创建线程除了继承Thread类之外,还可以通过实现Runnable接口来实现类似的功能。实现Runnable接口必须重写其run方法。<br>下面是一个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"主线程ID:"</span>+Thread.currentThread().getId());</span><br><span class="line">        MyRunnable runnable = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(runnable);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyRunnable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子线程ID:"</span>+Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Runnable的中文意思是“任务”,顾名思义,通过实现Runnable接口,我们定义了一个子任务,然后将子任务交由Thread去执行。注意,这种方式必须将Runnable作为Thread类的参数,然后通过Thread的start方法来创建一个新线程来执行该子任务。如果调用Runnable的run方法的话,是不会创建新线程的,这根普通的方法调用没有任何区别。</p>
<p>事实上,查看Thread类的实现源代码会发现Thread类是实现了Runnable接口的。</p>
<p>在Java中,这2种方式都可以用来创建线程去执行子任务,具体选择哪一种方式要看自己的需求。直接继承Thread类的话,可能比实现Runnable接口看起来更加简洁,但是由于Java只允许单继承,所以如果自定义类需要继承其他类,则只能选择实现Runnable接口。</p>
<h3 id="使用ExecutorService、Callable、Future实现有返回结果的多线程"><a href="#使用ExecutorService、Callable、Future实现有返回结果的多线程" class="headerlink" title="使用ExecutorService、Callable、Future实现有返回结果的多线程"></a>使用ExecutorService、Callable、Future实现有返回结果的多线程</h3><p>ExecutorService、Callable、Future这个对象实际上都是属于Executor框架中的功能类。想要详细了解Executor框架的可以访问 <a href="http://www.iteye.com/topic/366591" target="_blank" rel="noopener">http://www.iteye.com/topic/366591</a> ,这里面对该框架做了很详细的解释。返回结果的线程是在JDK1.5中引入的新特征,有了这种特征我就不需要再为了得到返回值而大费周折了。</p>
<p>可返回值的任务必须实现Callable接口,类似的,无返回值的任务必须Runnable接口。执行Callable任务后,可以获取一个Future的对象,在该对象上调用get就可以获取到Callable任务返回的Object了,再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程了。下面提供了一个完整的有返回结果的多线程测试例子,在JDK1.5下验证过没问题可以直接使用。代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 有返回值的线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"----程序开始运行----"</span>);</span><br><span class="line">        Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> taskSize = <span class="number">5</span>;</span><br><span class="line">        <span class="comment">// 创建一个线程池  </span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(taskSize);</span><br><span class="line">        <span class="comment">// 创建多个有返回值的任务  </span></span><br><span class="line">        List&lt;Future&gt; list = <span class="keyword">new</span> ArrayList&lt;Future&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskSize; i++) &#123;</span><br><span class="line">            Callable c = <span class="keyword">new</span> MyCallable(i + <span class="string">" "</span>);</span><br><span class="line">            <span class="comment">// 执行任务并获取Future对象  </span></span><br><span class="line">            Future f = pool.submit(c);</span><br><span class="line">            list.add(f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭线程池  </span></span><br><span class="line">        pool.shutdown();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取所有并发任务的运行结果  </span></span><br><span class="line">        <span class="keyword">for</span> (Future f : list) &#123;</span><br><span class="line">            <span class="comment">// 从Future对象上获取任务的返回值,并输出到控制台  </span></span><br><span class="line">            System.out.println(<span class="string">"&gt;&gt;&gt;"</span> + f.get().toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Date date2 = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">"----程序结束运行----,程序运行时间【"</span></span><br><span class="line">                + (date2.getTime() - date1.getTime()) + <span class="string">"毫秒】"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String taskNum;</span><br><span class="line"></span><br><span class="line">    MyCallable(String taskNum) &#123;</span><br><span class="line">        <span class="keyword">this</span>.taskNum = taskNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;"</span> + taskNum + <span class="string">"任务启动"</span>);</span><br><span class="line">        Date dateTmp1 = <span class="keyword">new</span> Date();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        Date dateTmp2 = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="keyword">long</span> time = dateTmp2.getTime() - dateTmp1.getTime();</span><br><span class="line">        System.out.println(<span class="string">"&gt;&gt;&gt;"</span> + taskNum + <span class="string">"任务终止"</span>);</span><br><span class="line">        <span class="keyword">return</span> taskNum + <span class="string">"任务返回运行结果,当前任务时间【"</span> + time + <span class="string">"毫秒】"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码说明:<br>上述代码中Executors类,提供了一系列工厂方法用于创先线程池,返回的线程池都实现了ExecutorService接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span></span>;</span><br></pre></td></tr></table></figure>
<p>创建固定数目线程的线程池。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>创建一个可缓存的线程池,调用execute 将重用以前构造的线程(如果线程可用)。如果现有线程没有可用的,则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>创建一个单线程化的Executor。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span></span></span><br></pre></td></tr></table></figure>
<p>创建一个支持定时及周期性的任务执行的线程池,多数情况下可用来替代Timer类。</p>
<p>ExecutoreService提供了submit()方法,传递一个Callable,或Runnable,返回Future。如果Executor后台线程池还没有完成Callable的计算,这调用返回Future对象的get()方法,会阻塞直到计算完成。</p>
<h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>在正式学习Thread类中的具体方法之前,我们先来了解一下线程有哪些状态,这个将会有助于后面对Thread类中的方法的理解。</p>
<p><a href="http://qn.atecher.com/Thread_State.png" target="_blank" rel="noopener"><img src="http://qn.atecher.com/Thread_State.png" alt=""></a></p>
<ul>
<li>创建(new)状态: 准备好了一个多线程的对象</li>
<li>就绪(runnable)状态: 调用了start()方法, 等待CPU进行调度</li>
<li>运行(running)状态: 执行run()方法</li>
<li>阻塞(blocked)状态: 暂时停止执行, 可能将资源交给其它线程使用</li>
<li>终止(dead)状态: 线程销毁</li>
</ul>
<p>当需要新起一个线程来执行某个子任务时,就创建了一个线程。但是线程创建之后,不会立即进入就绪状态,因为线程的运行需要一些条件(比如内存资源,在前面的JVM内存区域划分一篇博文中知道程序计数器、Java栈、本地方法栈都是线程私有的,所以需要为线程分配一定的内存空间),只有线程运行需要的所有条件满足了,才进入就绪状态。</p>
<p>当线程进入就绪状态后,不代表立刻就能获取CPU执行时间,也许此时CPU正在执行其他的事情,因此它要等待。当得到CPU执行时间之后,线程便真正进入运行状态。</p>
<p>线程在运行状态过程中,可能有多个原因导致当前线程不继续运行下去,比如用户主动让线程睡眠(睡眠一定的时间之后再重新执行)、用户主动让线程等待,或者被同步块给阻塞,此时就对应着多个状态:time waiting(睡眠或等待一定的事件)、waiting(等待被唤醒)、blocked(阻塞)。</p>
<p>当由于突然中断或者子任务执行完毕,线程就会被消亡。</p>
<p>下面这副图描述了线程从创建到消亡之间的状态:</p>
<p><a href="http://qn.atecher.com/thread_status_from_new_2_dead.jpg" target="_blank" rel="noopener"><img src="http://qn.atecher.com/thread_status_from_new_2_dead.jpg" alt=""></a></p>
<p>下图是从别处摘来的线程状态转换, 可结合以供参考</p>
<p><a href="http://qn.atecher.com/mts/20180403/3832334095647744" target="_blank" rel="noopener"><img src="http://qn.atecher.com/mts/20180403/3832334095647744" alt=""></a></p>
<p>各种状态一目了然,值得一提的是”blocked”这个状态:<br>线程在Running的过程中可能会遇到阻塞(Blocked)情况</p>
<ol>
<li>调用join()和sleep()方法,sleep()时间结束或被打断,join()中断,IO完成都会回到Runnable状态,等待JVM的调度。</li>
<li>调用wait(),使该线程处于等待池(wait blocked pool),直到notify()/notifyAll(),线程被唤醒被放到锁定池(lock blocked pool ),释放同步锁使线程回到可运行状态(Runnable)</li>
<li>对Running状态的线程加同步锁(Synchronized)使其进入(lock blocked pool ),同步锁被释放进入可运行状态(Runnable)。</li>
</ol>
<p>此外,在runnable状态的线程是处于被调度的线程,此时的调度顺序是不一定的。Thread类中的yield方法可以让一个running状态的线程转入runnable。</p>
<p>注:sleep和wait的区别:</p>
<ul>
<li>sleep是Thread类的方法,wait是Object类中定义的方法.</li>
<li>Thread.sleep不会导致锁行为的改变, 如果当前线程是拥有锁的, 那么Thread.sleep不会让线程释放锁.</li>
<li>Thread.sleep和Object.wait都会暂停当前的线程. OS会将执行时间分配给其它线程. 区别是, 调用wait后, 需要别的线程执行notify/notifyAll才能够重新获得CPU执行时间.</li>
</ul>
<h2 id="线程的常用方法"><a href="#线程的常用方法" class="headerlink" title="线程的常用方法"></a>线程的常用方法</h2><table>
<thead>
<tr>
<th style="text-align:left">编号</th>
<th style="text-align:left">方法</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">public void start()</td>
<td style="text-align:left">使该线程开始执行；Java 虚拟机调用该线程的 run 方法。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">public void run()</td>
<td style="text-align:left">如果该线程是使用独立的 Runnable 运行对象构造的,则调用该 Runnable 对象的 run 方法；否则,该方法不执行任何操作并返回。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left">public final void setName(String name)</td>
<td style="text-align:left">改变线程名称,使之与参数 name 相同。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left">public final void setPriority(int priority)</td>
<td style="text-align:left">更改线程的优先级。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">public final void setDaemon(boolean on)</td>
<td style="text-align:left">将该线程标记为守护线程或用户线程。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left">public final void join(long millisec)</td>
<td style="text-align:left">等待该线程终止的时间最长为 millis 毫秒。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left">public void interrupt()</td>
<td style="text-align:left">中断线程。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left">public final boolean isAlive()</td>
<td style="text-align:left">测试线程是否处于活动状态。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left">public static void yield()</td>
<td style="text-align:left">暂停当前正在执行的线程对象,并执行其他线程。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left">public static void sleep(long millisec)</td>
<td style="text-align:left">在指定的毫秒数内让当前正在执行的线程休眠(暂停执行),此操作受到系统计时器和调度程序精度和准确性的影响。</td>
</tr>
</tbody>
</table>
<h3 id="currentThread-方法"><a href="#currentThread-方法" class="headerlink" title="currentThread()方法"></a>currentThread()方法</h3><p>currentThread()方法可以返回代码段正在被哪个线程调用的信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run1</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;                 </span><br><span class="line">    System.out.println(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="sleep-方法"><a href="#sleep-方法" class="headerlink" title="sleep()方法"></a>sleep()方法</h3><p>方法sleep()的作用是在指定的毫秒数内让当前“正在执行的线程”休眠(暂停执行)。这个“正在执行的线程”是指this.currentThread()返回的线程。<br>sleep方法有两个重载版本:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sleep(<span class="keyword">long</span> millis)     <span class="comment">//参数为毫秒</span></span><br><span class="line">sleep(<span class="keyword">long</span> millis,<span class="keyword">int</span> nanoseconds)    <span class="comment">//第一参数为毫秒,第二个参数为纳秒</span></span><br></pre></td></tr></table></figure></p>
<p>sleep相当于让线程睡眠,交出CPU,让CPU去执行其他的任务。<br>但是有一点要非常注意,sleep方法不会释放锁,也就是说如果当前线程持有对某个对象的锁,则即使调用sleep方法,其他线程也无法访问这个对象。看下面这个例子就清楚了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> Object object = <span class="keyword">new</span> Object();</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        MyThread thread1 = test.new MyThread();</span><br><span class="line">        MyThread thread2 = test.new MyThread();</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                System.out.println(<span class="string">"i:"</span>+i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"进入睡眠状态"</span>);</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">10000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> handle exception</span></span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"线程"</span>+Thread.currentThread().getName()+<span class="string">"睡眠结束"</span>);</span><br><span class="line">                i++;</span><br><span class="line">                System.out.println(<span class="string">"i:"</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">i:11</span></span><br><span class="line"><span class="comment">线程Thread-1进入睡眠状态</span></span><br><span class="line"><span class="comment">线程Thread-1睡眠结束</span></span><br><span class="line"><span class="comment">i:12</span></span><br><span class="line"><span class="comment">i:13</span></span><br><span class="line"><span class="comment">线程Thread-0进入睡眠状态</span></span><br><span class="line"><span class="comment">线程Thread-0睡眠结束</span></span><br><span class="line"><span class="comment">i:14</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<p>从上面输出结果可以看出,当Thread-1进入睡眠状态之后,Thread-0并没有去执行具体的任务。只有当Thread-1执行完之后,此时Thread-1释放了对象锁,Thread-0才开始执行。</p>
<p>注意,如果调用了sleep方法,必须捕获InterruptedException异常或者将该异常向上层抛出。当线程睡眠时间满后,不一定会立即得到执行,因为此时可能CPU正在执行其他的任务。所以说调用sleep方法相当于让线程进入阻塞状态。</p>
<h3 id="yield-方法"><a href="#yield-方法" class="headerlink" title="yield()方法"></a>yield()方法</h3><p>调用yield方法会让当前线程交出CPU权限,让CPU去执行其他的线程。它跟sleep方法类似,同样不会释放锁。但是yield不能控制具体的交出CPU的时间,另外,yield方法只能让拥有相同优先级的线程有获取CPU执行时间的机会。</p>
<p>注意,调用yield方法并不会让线程进入阻塞状态,而是让线程重回就绪状态,它只需要等待重新获取CPU执行时间,这一点是和sleep方法不一样的。<br>代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>  <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> beginTime=System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">50000000</span>;i++)&#123;</span><br><span class="line">            count=count+(i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//Thread.yield();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> endTime=System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"用时:"</span>+(endTime-beginTime)+<span class="string">" 毫秒！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Run</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread t= <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行结果:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">用时:3 毫秒！</span></span><br><span class="line"><span class="comment">如果将 //Thread.yield();的注释去掉,执行结果如下:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">用时:16080 毫秒！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>
<h3 id="start-方法"><a href="#start-方法" class="headerlink" title="start()方法"></a>start()方法</h3><p>start()用来启动一个线程,当调用start方法后,系统才会开启一个新的线程来执行用户定义的子任务,在这个过程中,会为相应的线程分配需要的资源。</p>
<h3 id="run-方法"><a href="#run-方法" class="headerlink" title="run()方法"></a>run()方法</h3><p>run()方法是<strong>不需要用户来调用</strong>的,当通过start方法启动一个线程之后,当线程获得了CPU执行时间,便进入run方法体去执行具体的任务。注意,继承Thread类必须重写run方法,在run方法中定义具体要执行的任务。</p>
<h3 id="getId"><a href="#getId" class="headerlink" title="getId()"></a>getId()</h3><p>getId()的作用是取得线程的唯一标识</p>
<h3 id="isAlive-方法"><a href="#isAlive-方法" class="headerlink" title="isAlive()方法"></a>isAlive()方法</h3><p>方法isAlive()的功能是判断当前线程是否处于活动状态<br>什么是活动状态呢？活动状态就是线程已经启动且尚未终止。线程处于正在运行或准备开始运行的状态,就认为线程是“存活”的。</p>
<h3 id="join-方法"><a href="#join-方法" class="headerlink" title="join()方法"></a>join()方法</h3><p>在很多情况下,主线程创建并启动了线程,如果子线程中药进行大量耗时运算,主线程往往将早于子线程结束之前结束。这时,如果主线程想等待子线程执行完成之后再结束,比如子线程处理一个数据,主线程要取得这个数据中的值,就要用到join()方法了。方法join()的作用是等待线程对象销毁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread4</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Thread4</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">"  "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 启动子进程</span></span><br><span class="line">        <span class="keyword">new</span> Thread4(<span class="string">"new thread"</span>).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                Thread4 th = <span class="keyword">new</span> Thread4(<span class="string">"joined thread"</span>);</span><br><span class="line">                th.start();</span><br><span class="line">                th.join();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"  "</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>执行结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">main  0</span><br><span class="line">main  1</span><br><span class="line">main  2</span><br><span class="line">main  3</span><br><span class="line">main  4</span><br><span class="line">new thread  0</span><br><span class="line">new thread  1</span><br><span class="line">new thread  2</span><br><span class="line">new thread  3</span><br><span class="line">new thread  4</span><br><span class="line">joined thread  0</span><br><span class="line">joined thread  1</span><br><span class="line">joined thread  2</span><br><span class="line">joined thread  3</span><br><span class="line">joined thread  4</span><br><span class="line">main  5</span><br><span class="line">main  6</span><br><span class="line">main  7</span><br><span class="line">main  8</span><br><span class="line">main  9</span><br></pre></td></tr></table></figure></p>
<p>由上可以看出main主线程等待joined thread线程先执行完了才结束的。如果把th.join()这行注释掉,运行结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">main  0</span><br><span class="line">main  1</span><br><span class="line">main  2</span><br><span class="line">main  3</span><br><span class="line">main  4</span><br><span class="line">main  5</span><br><span class="line">main  6</span><br><span class="line">main  7</span><br><span class="line">main  8</span><br><span class="line">main  9</span><br><span class="line">new thread  0</span><br><span class="line">new thread  1</span><br><span class="line">new thread  2</span><br><span class="line">new thread  3</span><br><span class="line">new thread  4</span><br><span class="line">joined thread  0</span><br><span class="line">joined thread  1</span><br><span class="line">joined thread  2</span><br><span class="line">joined thread  3</span><br><span class="line">joined thread  4</span><br></pre></td></tr></table></figure></p>
<h3 id="getName和setName"><a href="#getName和setName" class="headerlink" title="getName和setName"></a>getName和setName</h3><p>用来得到或者设置线程名称。</p>
<h3 id="getPriority和setPriority"><a href="#getPriority和setPriority" class="headerlink" title="getPriority和setPriority"></a>getPriority和setPriority</h3><p>用来获取和设置线程优先级。</p>
<h3 id="setDaemon和isDaemon"><a href="#setDaemon和isDaemon" class="headerlink" title="setDaemon和isDaemon"></a>setDaemon和isDaemon</h3><p>用来设置线程是否成为守护线程和判断线程是否是守护线程。</p>
<p>守护线程和用户线程的区别在于:守护线程依赖于创建它的线程,而用户线程则不依赖。举个简单的例子:如果在main线程中创建了一个守护线程,当main方法运行完毕之后,守护线程也会随着消亡。而用户线程则不会,用户线程会一直运行直到其运行完毕。在JVM中,像垃圾收集器线程就是守护线程。</p>
<p>在上面已经说到了Thread类中的大部分方法,那么Thread类中的方法调用到底会引起线程状态发生怎样的变化呢？下面一幅图就是在上面的图上进行改进而来的:</p>
<p><a href="http://qn.atecher.com/thread_status_from_new_2_dead_with_methods.jpg" target="_blank" rel="noopener"><img src="http://qn.atecher.com/thread_status_from_new_2_dead_with_methods.jpg" alt=""></a><br>thread_status_from_new_2_dead_with_methods</p>
<p>ps:<br>Thread类最佳实践:<br>写的时候最好要设置线程名称 Thread.name,并设置线程组 ThreadGroup,目的是方便管理。在出现问题的时候,打印线程栈 (jstack -pid) 一眼就可以看出是哪个线程出的问题,这个线程是干什么的。</p>
<h2 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h2><p>停止线程是在多线程开发时很重要的技术点,掌握此技术可以对线程的停止进行有效的处理。<br>停止一个线程可以使用Thread.stop()方法,但最好不用它。该方法是不安全的,已被弃用。<br>在Java中有以下3种方法可以终止正在运行的线程:</p>
<ul>
<li>使用退出标志,使线程正常退出,也就是当run方法完成后线程终止</li>
<li>使用stop方法强行终止线程,但是不推荐使用这个方法,因为stop和suspend及resume一样,都是作废过期的方法,使用他们可能产生不可预料的结果。</li>
<li>使用interrupt方法中断线程,但这个不会终止一个正在运行的线程,还需要加入一个判断才可以完成线程的停止。</li>
</ul>
<h2 id="暂停线程"><a href="#暂停线程" class="headerlink" title="暂停线程"></a>暂停线程</h2><p>interrupt()方法</p>
<h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>在操作系统中,线程可以划分优先级,优先级较高的线程得到的CPU资源较多,也就是CPU优先执行优先级较高的线程对象中的任务。<br>设置线程优先级有助于帮“线程规划器”确定在下一次选择哪一个线程来优先执行。<br>设置线程的优先级使用setPriority()方法,此方法在JDK的源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPriority</span><span class="params">(<span class="keyword">int</span> newPriority)</span> </span>&#123;</span><br><span class="line">    ThreadGroup g;</span><br><span class="line">    checkAccess();</span><br><span class="line">    <span class="keyword">if</span> (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((g = getThreadGroup()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newPriority &gt; g.getMaxPriority()) &#123;</span><br><span class="line">            newPriority = g.getMaxPriority();</span><br><span class="line">        &#125;</span><br><span class="line">        setPriority0(priority = newPriority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在Java中,线程的优先级分为1~10这10个等级,如果小于1或大于10,则JDK抛出异常throw new IllegalArgumentException()。<br>JDK中使用3个常量来预置定义优先级的值,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MIN_PRIORITY = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NORM_PRIORITY = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_PRIORITY = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<p>线程优先级特性:</p>
<ul>
<li>继承性<br>比如A线程启动B线程,则B线程的优先级与A是一样的。</li>
<li>规则性<br>高优先级的线程总是大部分先执行完,但不代表高优先级线程全部先执行完。</li>
<li>随机性<br>优先级较高的线程不一定每一次都先执行完。</li>
</ul>
<h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>在Java线程中有两种线程,一种是User Thread(用户线程),另一种是Daemon Thread(守护线程)。<br>Daemon的作用是为其他线程的运行提供服务,比如说GC线程。其实User Thread线程和Daemon Thread守护线程本质上来说去没啥区别的,唯一的区别之处就在虚拟机的离开:如果User Thread全部撤离,那么Daemon Thread也就没啥线程好服务的了,所以虚拟机也就退出了。</p>
<p>守护线程并非虚拟机内部可以提供,用户也可以自行的设定守护线程,方法:public final void setDaemon(boolean on) ；但是有几点需要注意:</p>
<ul>
<li>thread.setDaemon(true)必须在thread.start()之前设置,否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。 (备注:这点与守护进程有着明显的区别,守护进程是创建后,让进程摆脱原会话的控制+让进程摆脱原进程组的控制+让进程摆脱原控制终端的控制；所以说寄托于虚拟机的语言机制跟系统级语言有着本质上面的区别)</li>
<li>在Daemon线程中产生的新线程也是Daemon的。 (这一点又是有着本质的区别了:守护进程fork()出来的子进程不再是守护进程,尽管它把父进程的进程相关信息复制过去了,但是子进程的进程的父进程不是init进程,所谓的守护进程本质上说就是“父进程挂掉,init收养,然后文件0,1,2都是/dev/null,当前目录到/”)</li>
<li>不是所有的应用都可以分配给Daemon线程来进行服务,比如读写操作或者计算逻辑。因为在Daemon Thread还没来的及进行操作时,虚拟机可能已经退出了。</li>
</ul>
<h2 id="每个对象都有的方法-机制"><a href="#每个对象都有的方法-机制" class="headerlink" title="每个对象都有的方法(机制)"></a>每个对象都有的方法(机制)</h2><p>synchronized, wait, notify 是任何对象都具有的同步工具。让我们先来了解他们<br>monitor</p>
<p><a href="http://qn.atecher.com/a_java_monitor.png" target="_blank" rel="noopener"><img src="http://qn.atecher.com/a_java_monitor.png" alt=""></a></p>
<p>他们是应用于同步问题的人工线程调度工具。讲其本质,首先就要明确monitor的概念,Java中的每个对象都有一个监视器,来监测并发代码的重入。在非多线程编码时该监视器不发挥作用,反之如果在synchronized 范围内,监视器发挥作用。</p>
<p>wait/notify必须存在于synchronized块中。并且,这三个关键字针对的是同一个监视器(某对象的监视器)。这意味着wait之后,其他线程可以进入同步块执行。</p>
<p>当某代码并不持有监视器的使用权时(如图中5的状态,即脱离同步块)去wait或notify,会抛出java.lang.IllegalMonitorStateException。也包括在synchronized块中去调用另一个对象的wait/notify,因为不同对象的监视器不同,同样会抛出此异常。</p>
<ul>
<li><p>synchronized单独使用:</p>
<ul>
<li><p>代码块:如下,在多线程环境下,synchronized块中的方法获取了lock实例的monitor,如果实例相同,那么只有一个线程能执行该块内容</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   Object lock;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">synchronized</span>(lock)&#123;</span><br><span class="line">         <span class="comment">//..do something</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接用于方法: 相当于上面代码中用lock来锁定的效果,实际获取的是Thread1类的monitor。更进一步,如果修饰的是static方法,则锁定该类所有实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        ..<span class="keyword">do</span> something</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>synchronized, wait, notify结合:典型场景生产者消费者问题</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 生产者生产出来的产品交给店员</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.product &gt;= MAX_PRODUCT) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait();  </span><br><span class="line">            System.out.println(<span class="string">"产品已满,请稍候再生产"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.product++;</span><br><span class="line">    System.out.println(<span class="string">"生产者生产第"</span> + <span class="keyword">this</span>.product + <span class="string">"个产品."</span>);</span><br><span class="line">    notifyAll();   <span class="comment">//通知等待区的消费者可以取出产品了</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 消费者从店员取产品</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.product &lt;= MIN_PRODUCT) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            wait(); </span><br><span class="line">            System.out.println(<span class="string">"缺货,稍候再取"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e)  &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">"消费者取走了第"</span> + <span class="keyword">this</span>.product + <span class="string">"个产品."</span>);</span><br><span class="line">    <span class="keyword">this</span>.product--;</span><br><span class="line">    notifyAll();   <span class="comment">//通知等待去的生产者可以生产产品了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>volatile</p>
<p>多线程的内存模型:main memory(主存)、working memory(线程栈),在处理数据时,线程会把值从主存load到本地栈,完成操作后再save回去(volatile关键词的作用:每次针对该变量的操作都激发一次load and save)。</p>
<p><a href="http://qn.atecher.com/main_memory.png" target="_blank" rel="noopener"><img src="http://qn.atecher.com/main_memory.png" alt=""></a></p>
<p>针对多线程使用的变量如果不是volatile或者final修饰的,很有可能产生不可预知的结果(另一个线程修改了这个值,但是之后在某线程看到的是修改之前的值)。其实道理上讲同一实例的同一属性本身只有一个副本。但是多线程是会缓存值的,本质上,volatile就是不去缓存,直接取值。在线程安全的情况下加volatile会牺牲性能。</p>
<h2 id="如何获取线程中的异常"><a href="#如何获取线程中的异常" class="headerlink" title="如何获取线程中的异常"></a>如何获取线程中的异常</h2><p><a href="http://qn.atecher.com/thread_exception_catch.png" target="_blank" rel="noopener"><img src="http://qn.atecher.com/thread_exception_catch.png" alt=""></a><br>thread_exception_catch</p>
<p>不能用try,catch来获取线程中的异常</p>
<h2 id="高级多线程控制类"><a href="#高级多线程控制类" class="headerlink" title="高级多线程控制类"></a>高级多线程控制类</h2><p>以上都属于内功心法,接下来是实际项目中常用到的工具了,Java1.5提供了一个非常高效实用的多线程包:java.util.concurrent, 提供了大量高级工具,可以帮助开发者编写高效、易维护、结构清晰的Java多线程程序。</p>
<h3 id="ThreadLocal类"><a href="#ThreadLocal类" class="headerlink" title="ThreadLocal类"></a>ThreadLocal类</h3><p>用处:保存线程的独立变量。对一个线程类(继承自Thread)<br>当使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程提供独立的变量副本,所以每一个线程都可以独立地改变自己的副本,而不会影响其它线程所对应的副本。常用于用户登录控制,如记录session信息。</p>
<p>实现:每个Thread都持有一个TreadLocalMap类型的变量(该类是一个轻量级的Map,功能与map一样,区别是桶里放的是entry而不是entry的链表。功能还是一个map。)以本身为key,以目标为value。<br>主要方法是get()和set(T a),set之后在map里维护一个threadLocal -&gt; a,get时将a返回。ThreadLocal是一个特殊的容器。</p>
<h3 id="原子类-AtomicInteger、AtomicBoolean……"><a href="#原子类-AtomicInteger、AtomicBoolean……" class="headerlink" title="原子类(AtomicInteger、AtomicBoolean……)"></a>原子类(AtomicInteger、AtomicBoolean……)</h3><p>如果使用atomic wrapper class如atomicInteger,或者使用自己保证原子的操作,则等同于synchronized<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值为boolean</span></span><br><span class="line">AtomicInteger.compareAndSet(<span class="keyword">int</span> expect,<span class="keyword">int</span> update)</span><br></pre></td></tr></table></figure></p>
<p>该方法可用于实现乐观锁,考虑文中最初提到的如下场景:a给b付款10元,a扣了10元,b要加10元。此时c给b2元,但是b的加十元代码约为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(b.value.compareAndSet(old, value))&#123;</span><br><span class="line">   <span class="keyword">return</span> ;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   <span class="comment">//try again</span></span><br><span class="line">   <span class="comment">// if that fails, rollback and log</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AtomicReference<br>对于AtomicReference 来讲,也许对象会出现,属性丢失的情况,即oldObject == current,但是oldObject.getPropertyA != current.getPropertyA。<br>这时候,AtomicStampedReference就派上用场了。这也是一个很常用的思路,即加上版本号</p>
<h3 id="Lock类"><a href="#Lock类" class="headerlink" title="Lock类"></a>Lock类</h3><p>lock: 在java.util.concurrent包内。共有三个实现:</p>
<ul>
<li>ReentrantLock</li>
<li>ReentrantReadWriteLock.ReadLock</li>
<li>ReentrantReadWriteLock.WriteLock</li>
</ul>
<p>主要目的是和synchronized一样, 两者都是为了解决同步问题,处理资源争端而产生的技术。功能类似但有一些区别。</p>
<p>区别如下:</p>
<ul>
<li>lock更灵活,可以自由定义多把锁的枷锁解锁顺序(synchronized要按照先加的后解顺序)</li>
<li>提供多种加锁方案,lock 阻塞式, trylock 无阻塞式, lockInterruptily 可打断式,还有trylock的带超时时间版本。</li>
<li>本质上和监视器锁(即synchronized是一样的)</li>
<li>能力越大,责任越大,必须控制好加锁和解锁,否则会导致灾难。</li>
<li>和Condition类的结合。</li>
<li>性能更高,对比如下图:<br>synchronized和Lock性能对比</li>
</ul>
<p><a href="http://qn.atecher.com/synchronize_Lock_performance.png" target="_blank" rel="noopener"><img src="http://qn.atecher.com/synchronize_Lock_performance.png" alt=""></a><br> synchronize_Lock_performance</p>
<p>ReentrantLock<br>可重入的意义在于持有锁的线程可以继续持有,并且要释放对等的次数后才真正释放该锁。<br>使用方法是:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.先new一个实例</span></span><br><span class="line"><span class="keyword">static</span> ReentrantLock r=<span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.加锁</span></span><br><span class="line">r.lock()<span class="comment">//或r.lockInterruptibly();</span></span><br><span class="line"><span class="comment">/*此处也是个不同,后者可被打断。当a线程lock后,b线程阻塞,此时如果是lockInterruptibly,那么在调用b.interrupt()之后,b线程退出阻塞,并放弃对资源的争抢,进入catch块。(如果使用后者,必须throw interruptable exception 或catch)*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.释放锁</span></span><br><span class="line">r.unlock()</span><br><span class="line"></span><br><span class="line"><span class="comment">/*必须做！何为必须做呢,要放在finally里面。以防止异常跳出了正常流程,导致灾难。这里补充一个小知识点,finally是可以信任的:经过测试,哪怕是发生了OutofMemoryError,finally块中的语句执行也能够得到保证。*/</span></span><br></pre></td></tr></table></figure>
<p>ReentrantReadWriteLock</p>
<p>可重入读写锁(读写锁的一个实现)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock()</span><br><span class="line">ReadLock r = lock.readLock();</span><br><span class="line">WriteLock w = lock.writeLock();</span><br></pre></td></tr></table></figure></p>
<p>两者都有lock,unlock方法。写写,写读互斥；读读不互斥。可以实现并发读的高效线程安全代码</p>
<h3 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h3><p>这里就讨论比较常用的两个:</p>
<ul>
<li>BlockingQueue</li>
<li>ConcurrentHashMap</li>
</ul>
<p>BlockingQueue<br>阻塞队列。该类是java.util.concurrent包下的重要类,通过对Queue的学习可以得知,这个queue是单向队列,可以在队列头添加元素和在队尾删除或取出元素。类似于一个管　　道,特别适用于先进先出策略的一些应用场景。普通的queue接口主要实现有PriorityQueue(优先队列),有兴趣可以研究</p>
<p>BlockingQueue在队列的基础上添加了多线程协作的功能:</p>
<p><a href="http://qn.atecher.com/BlockingQueue.png" target="_blank" rel="noopener"><img src="http://qn.atecher.com/BlockingQueue.png" alt=""></a><br>BlockingQueue</p>
<p>除了传统的queue功能(表格左边的两列)之外,还提供了阻塞接口put和take,带超时功能的阻塞接口offer和poll。put会在队列满的时候阻塞,直到有空间时被唤醒；take在队　列空的时候阻塞,直到有东西拿的时候才被唤醒。用于生产者-消费者模型尤其好用,堪称神器。</p>
<p>常见的阻塞队列有:</p>
<ul>
<li>ArrayListBlockingQueue</li>
<li>LinkedListBlockingQueue</li>
<li>DelayQueue</li>
<li>SynchronousQueue</li>
</ul>
<p>ConcurrentHashMap<br>高效的线程安全哈希map。请对比hashTable , concurrentHashMap, HashMap</p>
<h3 id="管理类"><a href="#管理类" class="headerlink" title="管理类"></a>管理类</h3><p>管理类的概念比较泛,用于管理线程,本身不是多线程的,但提供了一些机制来利用上述的工具做一些封装。<br>了解到的值得一提的管理类:ThreadPoolExecutor和 JMX框架下的系统级管理类 ThreadMXBean<br>ThreadPoolExecutor<br>如果不了解这个类,应该了解前面提到的ExecutorService,开一个自己的线程池非常方便:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService e = Executors.newCachedThreadPool();</span><br><span class="line">ExecutorService e = Executors.newSingleThreadExecutor();</span><br><span class="line">ExecutorService e = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 第一种是可变大小线程池,按照任务数来分配线程,</span></span><br><span class="line"><span class="comment">// 第二种是单线程池,相当于FixedThreadPool(1)</span></span><br><span class="line"><span class="comment">// 第三种是固定大小线程池。</span></span><br><span class="line"><span class="comment">// 然后运行</span></span><br><span class="line">e.execute(<span class="keyword">new</span> MyRunnableImpl());</span><br></pre></td></tr></table></figure></p>
<p>该类内部是通过ThreadPoolExecutor实现的,掌握该类有助于理解线程池的管理,本质上,他们都是ThreadPoolExecutor类的各种实现版本。请参见javadoc:</p>
<p><a href="http://qn.atecher.com/ThreadPoolExecutor.png" target="_blank" rel="noopener"><img src="http://qn.atecher.com/ThreadPoolExecutor.png" alt=""></a><br>ThreadPoolExecutor</p>
<p>ThreadPoolExecutor参数解释<br>翻译一下:<br>corePoolSize:池内线程初始值与最小值,就算是空闲状态,也会保持该数量线程。<br>maximumPoolSize:线程最大值,线程的增长始终不会超过该值。<br>keepAliveTime:当池内线程数高于corePoolSize时,经过多少时间多余的空闲线程才会被回收。回收前处于wait状态<br>unit:时间单位,可以使用TimeUnit的实例,如TimeUnit.MILLISECONDS<br>workQueue:待入任务(Runnable)的等待场所,该参数主要影响调度策略,如公平与否,是否产生饿死(starving)<br>threadFactory:线程工厂类,有默认实现,如果有自定义的需要则需要自己实现ThreadFactory接口并作为参数传入。</p>
<p>ref:<br><a href="http://www.importnew.com/21089.html" target="_blank" rel="noopener">http://www.importnew.com/21089.html</a><br><a href="http://www.importnew.com/21136.html" target="_blank" rel="noopener">http://www.importnew.com/21136.html</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/Thread/" rel="tag"># Thread</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/13/Java-Thread-线程池调整/" rel="next" title="Java-Thread-线程池调整">
                <i class="fa fa-chevron-left"></i> Java-Thread-线程池调整
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/13/Java-Thread-UncaughtExceptionHandler/" rel="prev" title="Java-Thread-UncaughtExceptionHandler-处理非正常的线程中止">
                Java-Thread-UncaughtExceptionHandler-处理非正常的线程中止 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="SOHUCS"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="http://qn.atecher.com/mts/20180418/3853594527466496" alt="Atecher">
          <p class="site-author-name" itemprop="name">Atecher</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">66</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/atecher" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/atecher" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.jianshu.com/u/649bbf6c8e00" target="_blank" title="简书">
                  
                    <i class="fa fa-fw fa-heartbeat"></i>
                  
                  简书
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概念"><span class="nav-number">1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#上下文切换"><span class="nav-number">2.</span> <span class="nav-text">上下文切换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的实现方式"><span class="nav-number">3.</span> <span class="nav-text">线程的实现方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#继承Thread类"><span class="nav-number">3.1.</span> <span class="nav-text">继承Thread类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现Runnable接口"><span class="nav-number">3.2.</span> <span class="nav-text">实现Runnable接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用ExecutorService、Callable、Future实现有返回结果的多线程"><span class="nav-number">3.3.</span> <span class="nav-text">使用ExecutorService、Callable、Future实现有返回结果的多线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的状态"><span class="nav-number">4.</span> <span class="nav-text">线程的状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的常用方法"><span class="nav-number">5.</span> <span class="nav-text">线程的常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#currentThread-方法"><span class="nav-number">5.1.</span> <span class="nav-text">currentThread()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep-方法"><span class="nav-number">5.2.</span> <span class="nav-text">sleep()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#yield-方法"><span class="nav-number">5.3.</span> <span class="nav-text">yield()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#start-方法"><span class="nav-number">5.4.</span> <span class="nav-text">start()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#run-方法"><span class="nav-number">5.5.</span> <span class="nav-text">run()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getId"><span class="nav-number">5.6.</span> <span class="nav-text">getId()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#isAlive-方法"><span class="nav-number">5.7.</span> <span class="nav-text">isAlive()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#join-方法"><span class="nav-number">5.8.</span> <span class="nav-text">join()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getName和setName"><span class="nav-number">5.9.</span> <span class="nav-text">getName和setName</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getPriority和setPriority"><span class="nav-number">5.10.</span> <span class="nav-text">getPriority和setPriority</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setDaemon和isDaemon"><span class="nav-number">5.11.</span> <span class="nav-text">setDaemon和isDaemon</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#停止线程"><span class="nav-number">6.</span> <span class="nav-text">停止线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#暂停线程"><span class="nav-number">7.</span> <span class="nav-text">暂停线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的优先级"><span class="nav-number">8.</span> <span class="nav-text">线程的优先级</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#守护线程"><span class="nav-number">9.</span> <span class="nav-text">守护线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#每个对象都有的方法-机制"><span class="nav-number">10.</span> <span class="nav-text">每个对象都有的方法(机制)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何获取线程中的异常"><span class="nav-number">11.</span> <span class="nav-text">如何获取线程中的异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高级多线程控制类"><span class="nav-number">12.</span> <span class="nav-text">高级多线程控制类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal类"><span class="nav-number">12.1.</span> <span class="nav-text">ThreadLocal类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子类-AtomicInteger、AtomicBoolean……"><span class="nav-number">12.2.</span> <span class="nav-text">原子类(AtomicInteger、AtomicBoolean……)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lock类"><span class="nav-number">12.3.</span> <span class="nav-text">Lock类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器类"><span class="nav-number">12.4.</span> <span class="nav-text">容器类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管理类"><span class="nav-number">12.5.</span> <span class="nav-text">管理类</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Atecher</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>

  
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js"></script>

  
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery_lazyload/1.9.7/jquery.lazyload.min.js"></script>

  
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.min.js"></script>

  
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/velocity/1.2.1/velocity.ui.min.js"></script>

  
  <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/fancybox/2.1.5/jquery.fancybox.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  




  
    <script type="text/javascript">
    (function(){
      var appid = 'cyt9KwbIC';
      var conf = 'bc0e6852e38545fe217c021fe412293e';
      var width = window.innerWidth || document.documentElement.clientWidth;
      if (width < 960) {
      window.document.write('<script id="changyan_mobile_js" charset="utf-8" type="text/javascript" src="https://changyan.sohu.com/upload/mobile/wap-js/changyan_mobile.js?client_id=' + appid + '&conf=' + conf + '"><\/script>'); } else { var loadJs=function(d,a){var c=document.getElementsByTagName("head")[0]||document.head||document.documentElement;var b=document.createElement("script");b.setAttribute("type","text/javascript");b.setAttribute("charset","UTF-8");b.setAttribute("src",d);if(typeof a==="function"){if(window.attachEvent){b.onreadystatechange=function(){var e=b.readyState;if(e==="loaded"||e==="complete"){b.onreadystatechange=null;a()}}}else{b.onload=a}}c.appendChild(b)};loadJs("https://changyan.sohu.com/upload/changyan.js",function(){
        window.changyan.api.config({appid:appid,conf:conf})});
      }
    })();
    </script>
    <script type="text/javascript" src="https://changyan.sohu.com/upload/plugins/plugins.count.js"></script>
  



  




  
  
  
    
  
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/instantsearch.js/1.5.0/instantsearch.min.css">

  
  
    
  
  <script src="//cdnjs.cloudflare.com/ajax/libs/instantsearch.js/1.5.0/instantsearch.min.js"></script>
  

  <script src="/js/src/algolia-search.js?v=5.1.1"></script>



  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("080EavKIlkfhitmF8Eu2gKDd-gzGzoHsz", "so1s6UPhJO8sKEbMoBgkYMhm");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
