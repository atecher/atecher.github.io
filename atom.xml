<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Atecher&#39;s blog</title>
  
  <subtitle>胸有丘壑,目有山川</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.atecher.com/"/>
  <updated>2022-01-28T10:28:39.119Z</updated>
  <id>http://blog.atecher.com/</id>
  
  <author>
    <name>Atecher</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java23种设计模式</title>
    <link href="http://blog.atecher.com/2018/04/11/Java-Design-Patterns/"/>
    <id>http://blog.atecher.com/2018/04/11/Java-Design-Patterns/</id>
    <published>2018-04-11T16:00:10.000Z</published>
    <updated>2022-01-28T10:28:39.119Z</updated>
    
    <content type="html"><![CDATA[<p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。本章系<strong>Java之美[从菜鸟到高手演变]系列</strong>之设计模式，我们会以理论与实践相结合的方式来进行本章的学习，希望广大程序爱好者，学好设计模式，做一个优秀的软件工程师！</p><a id="more"></a><h1 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h1><p>总体来说设计模式分为三大类：</p><p>创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。</p><p>结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。</p><p>行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。</p><p>其实还有两类：并发型模式和线程池模式。用一个图片来整体描述一下：</p><p><img src="//qn.atecher.com/mts/20180411/3843700752729088" alt="点击查看原始大小图片"></p><h1 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h1><h2 id="开闭原则（Open-Close-Principle）"><a href="#开闭原则（Open-Close-Principle）" class="headerlink" title="开闭原则（Open Close Principle）"></a>开闭原则（Open Close Principle）</h2><p>开闭原则就是说<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><h2 id="里氏代换原则（Liskov-Substitution-Principle）"><a href="#里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle）"></a>里氏代换原则（Liskov Substitution Principle）</h2><p>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科</p><h2 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h2><p>这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。</p><h2 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h2><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。</p><h2 id="迪米特法则（最少知道原则）（Demeter-Principle）"><a href="#迪米特法则（最少知道原则）（Demeter-Principle）" class="headerlink" title="迪米特法则（最少知道原则）（Demeter Principle）"></a>迪米特法则（最少知道原则）（Demeter Principle）</h2><p>为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h2 id="合成复用原则（Composite-Reuse-Principle）"><a href="#合成复用原则（Composite-Reuse-Principle）" class="headerlink" title="合成复用原则（Composite Reuse Principle）"></a>合成复用原则（Composite Reuse Principle）</h2><p>原则是尽量使用合成/聚合的方式，而不是使用继承。</p><h1 id="Java的23种设计模式"><a href="#Java的23种设计模式" class="headerlink" title="Java的23种设计模式"></a>Java的23种设计模式</h1><p>从这一块开始，我们详细介绍Java中23种设计模式的概念，应用场景等情况，并结合他们的特点及设计模式的原则进行分析。</p><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><h3 id="工厂方法模式（Factory-Method）"><a href="#工厂方法模式（Factory-Method）" class="headerlink" title="工厂方法模式（Factory Method）"></a>工厂方法模式（Factory Method）</h3><p>工厂方法模式分为三种：</p><h4 id="普通工厂模式"><a href="#普通工厂模式" class="headerlink" title="普通工厂模式"></a>普通工厂模式</h4><p>就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。首先看下关系图：</p><p><img src="//qn.atecher.com/mts/20180411/3843700761920512" alt="Image-4"></p><p>举例如下：（我们举一个发送邮件和短信的例子）</p><p>首先，创建二者的共同接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，创建实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"this is mailsender!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"this is sms sender!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，建工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"mail"</span>.equals(type)) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"sms"</span>.equals(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">"请输入正确的类型!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SendFactory factory = <span class="keyword">new</span> SendFactory();</span><br><span class="line">      Sender sender = factory.produce(<span class="string">"sms"</span>);</span><br><span class="line">      sender.Send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br>    this is sms sender!</p><h4 id="多个工厂方法模式"><a href="#多个工厂方法模式" class="headerlink" title="多个工厂方法模式"></a>多个工厂方法模式</h4><p>是对普通工厂方法模式的改进，在普通工厂方法模式中，如果传递的字符串出错，则不能正确创建对象，而多个工厂方法模式是提供多个工厂方法，分别创建对象。关系图：</p><p><img src="//qn.atecher.com/mts/20180411/3843700784923648" alt="点击查看原始大小图片"></p><p>将上面的代码做下修改，改动下SendFactory类就行，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Sender <span class="title">produceMail</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Sender <span class="title">produceSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      SendFactory factory = <span class="keyword">new</span> SendFactory();</span><br><span class="line">      Sender sender = factory.produceMail();</span><br><span class="line">      sender.Send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br>    this is mailsender!</p><h4 id="静态工厂方法模式"><a href="#静态工厂方法模式" class="headerlink" title="静态工厂方法模式"></a>静态工厂方法模式</h4><p>将上面的多个工厂方法模式里的方法置为静态的，不需要创建实例，直接调用即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produceMail</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sender <span class="title">produceSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">      Sender sender = SendFactory.produceMail();</span><br><span class="line">      sender.Send();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this is mailsender!</span><br></pre></td></tr></table></figure><p>总体来说，工厂模式适合：凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。在以上的三种模式中，第一种如果传入的字符串有误，不能正确创建对象，第三种相对于第二种，不需要实例化工厂类，所以，大多数情况下，我们会选用第三种——静态工厂方法模式。</p><h3 id="抽象工厂模式（Abstract-Factory）"><a href="#抽象工厂模式（Abstract-Factory）" class="headerlink" title="抽象工厂模式（Abstract Factory）"></a>抽象工厂模式（Abstract Factory）</h3><p>工厂方法模式有一个问题就是，类的创建依赖工厂类，也就是说，如果想要拓展程序，必须对工厂类进行修改，这违背了闭包原则，所以，从设计角度考虑，有一定的问题，如何解决？就用到抽象工厂模式，创建多个工厂类，这样一旦需要增加新的功能，直接增加新的工厂类就可以了，不需要修改之前的代码。因为抽象工厂不太好理解，我们先看看图，然后就和代码，就比较容易理解。</p><p><img src="//qn.atecher.com/mts/20180411/3843700791395328" alt="点击查看原始大小图片"></p><p>请看例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"this is mailsender!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"this is sms sender!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMailFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MailSender();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendSmsFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在提供一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Provider provider = <span class="keyword">new</span> SendMailFactory();</span><br><span class="line">      Sender sender = provider.produce();</span><br><span class="line">      sender.Send();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个模式的好处就是，如果你现在想增加一个功能：发及时信息，则只需做一个实现类，实现Sender接口，同时做一个工厂类，实现Provider接口，就OK了，无需去改动现成的代码。这样做，拓展性较好！</p><h3 id="单例模式（Singleton）"><a href="#单例模式（Singleton）" class="headerlink" title="单例模式（Singleton）"></a>单例模式（Singleton）</h3><p>单例对象（Singleton）是一种常用的设计模式。在Java应用中，单例对象能保证在一个JVM中，该对象只有一个实例存在。这样的模式有几个好处：</p><p>1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。</p><p>2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。</p><p>3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。</p><p>首先我们写一个简单的单例类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 持有私有静态实例，防止被引用，此处赋值为null，目的是实现延迟加载 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 私有构造方法，防止被实例化 */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 静态工程方法，创建实例 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类可以满足基本要求，但是，像这样毫无线程安全保护的类，如果我们把它放入多线程的环境下，肯定就会出现问题了，如何解决？我们首先会想到对getInstance方法加synchronized关键字，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，synchronized关键字锁住的是这个对象，这样的用法，在性能上会有所下降，因为每次调用getInstance()，都要对对象上锁，事实上，只有在第一次创建对象的时候需要加锁，之后就不需要了，所以，这个地方需要改进。我们改成下面这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">synchronized</span> (instance) &#123;</span><br><span class="line">              <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>似乎解决了之前提到的问题，将synchronized关键字加在了内部，也就是说当调用的时候是不需要加锁的，只有在instance为null，并创建对象的时候才需要加锁，性能有一定的提升。但是，这样的情况，还是有可能有问题的，看下面的情况：在Java指令中创建对象和赋值操作是分开进行的，也就是说instance = new Singleton();语句是分两步执行的。但是JVM并不保证这两个操作的先后顺序，也就是说有可能JVM会为新的Singleton实例分配空间，然后直接赋值给instance成员，然后再去初始化这个Singleton实例。这样就可能出错了，我们以A、B两个线程为例：</p><ol><li><p>A、B线程同时进入了第一个if判断</p></li><li><p>A首先进入synchronized块，由于instance为null，所以它执行instance = new Singleton();</p></li><li><p>由于JVM内部的优化机制，JVM先画出了一些分配给Singleton实例的空白内存，并赋值给instance成员（注意此时JVM没有开始初始化这个实例），然后A离开了synchronized块。</p></li><li><p>B进入synchronized块，由于instance此时不是null，因此它马上离开了synchronized块并将结果返回给调用该方法的程序。</p></li><li><p>此时B线程打算使用Singleton实例，却发现它没有被初始化，于是错误发生了。</p></li></ol><p>所以程序还是有可能发生错误，其实程序在运行过程是很复杂的，从这点我们就可以看出，尤其是在写多线程环境下的程序更有难度，有挑战性。我们对该程序做进一步优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span></span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> SingletonFactory.instance;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>实际情况是，单例模式使用内部类来维护单例的实现，JVM内部的机制能够保证当一个类被加载的时候，这个类的加载过程是线程互斥的。这样当我们第一次调用getInstance的时候，JVM能够帮我们保证instance只被创建一次，并且会保证把赋值给instance的内存初始化完毕，这样我们就不用担心上面的问题。同时该方法也只会在第一次调用的时候使用互斥机制，这样就解决了低性能问题。这样我们暂时总结一个完美的单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 私有构造方法，防止被实例化 */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 此处使用一个内部类来维护单例 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonFactory</span> </span>&#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 获取实例 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> SingletonFactory.instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 如果该对象被用于序列化，可以保证对象在序列化前后保持一致 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getInstance();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实说它完美，也不一定，如果在构造函数中抛出异常，实例将永远得不到创建，也会出错。所以说，十分完美的东西是没有的，我们只能根据实际情况，选择最适合自己应用场景的实现方法。也有人这样实现：因为我们只需要在创建类的时候进行同步，所以只要将创建和getInstance()分开，单独为创建加synchronized关键字，也是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> SingletonTest instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">SingletonTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonTest();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonTest <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          syncInit();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>考虑性能的话，整个程序只需创建一次实例，所以性能也不会有什么影响。</p><p><strong>补充：采用”影子实例”的办法为单例对象的属性同步更新</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> SingletonTest instance = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">private</span> Vector properties = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Vector <span class="title">getProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">syncInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          instance = <span class="keyword">new</span> SingletonTest();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonTest <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">          syncInit();</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateProperties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      SingletonTest shadow = <span class="keyword">new</span> SingletonTest();</span><br><span class="line">      properties = shadow.getProperties();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过单例模式的学习告诉我们：</p><ol><li><p>单例模式理解起来简单，但是具体实现起来还是有一定的难度。</p></li><li><p>synchronized关键字锁定的是对象，在用的时候，一定要在恰当的地方使用（注意需要使用锁的对象和过程，可能有的时候并不是整个对象及整个过程都需要锁）。</p></li></ol><p>到这儿，单例模式基本已经讲完了，结尾处，笔者突然想到另一个问题，就是采用类的静态方法，实现单例模式的效果，也是可行的，此处二者有什么不同？</p><p>首先，静态类不能实现接口。（从类的角度说是可以的，但是那样就破坏了静态了。因为接口中不允许有static修饰的方法，所以即使实现了也是非静态的）</p><p>其次，单例可以被延迟初始化，静态类一般在第一次加载是初始化。之所以延迟加载，是因为有些类比较庞大，所以延迟加载有助于提升性能。</p><p>再次，单例类可以被继承，他的方法可以被覆写。但是静态类内部方法都是static，无法被覆写。</p><p>最后一点，单例类比较灵活，毕竟从实现上只是一个普通的Java类，只要满足单例的基本需求，你可以在里面随心所欲的实现一些其它功能，但是静态类不行。从上面这些概括中，基本可以看出二者的区别，但是，从另一方面讲，我们上面最后实现的那个单例模式，内部就是用一个静态类来实现的，所以，二者有很大的关联，只是我们考虑问题的层面不同罢了。两种思想的结合，才能造就出完美的解决方案，就像HashMap采用数组+链表来实现一样，其实生活中很多事情都是这样，单用不同的方法来处理问题，总是有优点也有缺点，最完美的方法是，结合各个方法的优点，才能最好的解决问题！</p><h3 id="建造者模式（Builder）"><a href="#建造者模式（Builder）" class="headerlink" title="建造者模式（Builder）"></a>建造者模式（Builder）</h3><p>工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性，其实建造者模式就是前面抽象工厂模式和最后的Test结合起来得到的。我们看一下代码：</p><p>还和前面一样，一个Sender接口，两个实现类MailSender和SmsSender。最后，建造者类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> List&lt;Sender&gt; list = <span class="keyword">new</span> ArrayList&lt;Sender&gt;();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceMailSender</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">      **<span class="keyword">for</span>**(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++)&#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> MailSender());</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produceSmsSender</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">      **<span class="keyword">for</span>**(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;count; i++)&#123;</span><br><span class="line">          list.add(<span class="keyword">new</span> SmsSender());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Builder builder = <span class="keyword">new</span> Builder();</span><br><span class="line">      builder.produceMailSender(<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从这点看出，建造者模式将很多功能集成到一个类里，这个类可以创造出比较复杂的东西。所以与工程模式的区别就是：工厂模式关注的是创建单个产品，而建造者模式则关注创建符合对象，多个部分。因此，是选择工厂模式还是建造者模式，依实际情况而定。</p><h3 id="原型模式（Prototype）"><a href="#原型模式（Prototype）" class="headerlink" title="原型模式（Prototype）"></a>原型模式（Prototype）</h3><p>原型模式虽然是创建型的模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将一个对象作为原型，对其进行复制、克隆，产生一个和原对象类似的新对象。本小结会通过对象的复制，进行讲解。在Java中，复制对象是通过clone()实现的，先创建一个原型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">      Prototype proto = (Prototype) <span class="keyword">super</span>.clone();</span><br><span class="line">      <span class="keyword">return</span> proto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，一个原型类，只需要实现Cloneable接口，覆写clone方法，此处clone方法可以改成任意的名称，因为Cloneable接口是个空接口，你可以任意定义实现类的方法名，如cloneA或者cloneB，因为此处的重点是super.clone()这句话，super.clone()调用的是Object的clone()方法，而在Object类中，clone()是native的，具体怎么实现，我会在另一篇文章中，关于解读Java中本地方法的调用，此处不再深究。在这儿，我将结合对象的浅复制和深复制来说一下，首先需要了解对象深、浅复制的概念：</p><p>浅复制：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。</p><p>深复制：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。</p><p>此处，写一个深浅复制的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> staticfinal <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">  <span class="keyword">private</span> String string;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> SerializableObject obj;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 浅复制 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Prototype proto = (Prototype) <span class="keyword">super</span>.clone();</span><br><span class="line">      <span class="keyword">return</span> proto;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 深复制 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 写入当前对象的二进制流 */</span></span><br><span class="line">      ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">      ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">      oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 读出二进制流产生的新对象 */</span></span><br><span class="line">      ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">      ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">      <span class="keyword">return</span> ois.readObject();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setString</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.string = string;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SerializableObject <span class="title">getObj</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setObj</span><span class="params">(SerializableObject obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SerializableObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> staticfinal <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要实现深复制，需要采用流的形式读入当前对象的二进制输入，再写出二进制数据对应的对象。</p><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>我们接着讨论设计模式，上篇文章我讲完了5种创建型模式，这章开始，我将讲下7种结构型模式：适配器模式、装饰模式、代理模式、外观模式、桥接模式、组合模式、享元模式。其中对象的适配器模式是各种模式的起源，我们看下面的图：</p><p><img src="//qn.atecher.com/mts/20180411/3843705087329280" alt="点击查看原始大小图片"></p><h3 id="适配器模式（Adaptor）"><a href="#适配器模式（Adaptor）" class="headerlink" title="适配器模式（Adaptor）"></a>适配器模式（Adaptor）</h3><p> 适配器模式将某个类的接口转换成客户端期望的另一个接口表示，目的是消除由于接口不匹配所造成的类的兼容性问题。主要分为三类：类的适配器模式、对象的适配器模式、接口的适配器模式。首先，我们来看看，先看类图：</p><p><strong>类的适配器模式</strong></p><p><img src="//qn.atecher.com/mts/20180411/3843705106596864" alt="Image-9"></p><p>核心思想就是：有一个Source类，拥有一个方法，待适配，目标接口时Targetable，通过Adapter类，将Source的功能扩展到Targetable里，看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"this is original method!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 与原类中的方法相同 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 新类的方法 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"this is the targetable method!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Adapter类继承Source类，实现Targetable接口，下面是测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Targetable target = <span class="keyword">new</span> Adapter();</span><br><span class="line">      target.method1();</span><br><span class="line">      target.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this is original method!</span><br><span class="line">this is the targetable method!</span><br></pre></td></tr></table></figure></p><p>这样Targetable接口的实现类就具有了Source类的功能。</p><p><strong>对象的适配器模式</strong></p><p>基本思路和类的适配器模式相同，只是将Adapter类作修改，这次不继承Source类，而是持有Source类的实例，以达到解决兼容性的问题。看图：</p><p><img src="//qn.atecher.com/mts/20180411/3843705115329536" alt="Image-11"></p><p>只需要修改Adapter类的源码即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span> <span class="keyword">implements</span> <span class="title">Targetable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Source source;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Wrapper</span><span class="params">(Source source)</span></span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"this is the targetable method!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      source.method1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Source source = <span class="keyword">new</span> Source();</span><br><span class="line">      Targetable target = <span class="keyword">new</span> Wrapper(source);</span><br><span class="line">      target.method1();</span><br><span class="line">        target.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出与第一种一样，只是适配的方法不同而已。</p><p><strong>接口的适配器模式</strong></p><p>第三种适配器模式是<strong>接口的适配器模式</strong>，接口的适配器是这样的：有时我们写的一个接口中有多个抽象方法，当我们写该接口的实现类时，必须实现该接口的所有方法，这明显有时比较浪费，因为并不是所有的方法都是我们需要的，有时只需要某一些，此处为了解决这个问题，我们引入了接口的适配器模式，借助于一个抽象类，该抽象类实现了该接口，实现了所有的方法，而我们不和原始的接口打交道，只和该抽象类取得联系，所以我们写一个类，继承该抽象类，重写我们需要的方法就行。看一下类图：</p><p><img src="//qn.atecher.com/mts/20180411/3843705122096128" alt="Image-12"></p><p>这个很好理解，在实际开发中，我们也常会遇到这种接口中定义了太多的方法，以致于有时我们在一些实现类中并不是都需要。看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类Wrapper2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Wrapper2</span> <span class="keyword">implements</span> <span class="title">Sourceable</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceSub1</span> <span class="keyword">extends</span> <span class="title">Wrapper2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"the sourceable interface's first Sub1!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceSub2</span> <span class="keyword">extends</span> <span class="title">Wrapper2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"the sourceable interface's second Sub2!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrapperTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Sourceable source1 = <span class="keyword">new</span> SourceSub1();</span><br><span class="line">      Sourceable source2 = <span class="keyword">new</span> SourceSub2();</span><br><span class="line">      source1.method1();</span><br><span class="line">      source1.method2();</span><br><span class="line">      source2.method1();</span><br><span class="line">      source2.method2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试输出：</p><pre><code>the sourceable interface&apos;s first Sub1!the sourceable interface&apos;s second Sub2!</code></pre><p>达到了我们的效果！</p><p>讲了这么多，总结一下三种适配器模式的应用场景：</p><p>类的适配器模式：当希望将<strong>一个类</strong>转换成满足<strong>另一个新接口</strong>的类时，可以使用类的适配器模式，创建一个新类，继承原有的类，实现新的接口即可。</p><p>对象的适配器模式：当希望将一个对象转换成满足另一个新接口的对象时，可以创建一个Wrapper类，持有原类的一个实例，在Wrapper类的方法中，调用实例的方法就行。</p><p>接口的适配器模式：当不希望实现一个接口中所有的方法时，可以创建一个抽象类Wrapper，实现所有方法，我们写别的类的时候，继承抽象类即可。</p><h3 id="装饰模式（Decorator）"><a href="#装饰模式（Decorator）" class="headerlink" title="装饰模式（Decorator）"></a>装饰模式（Decorator）</h3><p>顾名思义，装饰模式就是给一个对象增加一些新的功能，而且是动态的，要求装饰对象和被装饰对象实现同一个接口，装饰对象持有被装饰对象的实例，关系图如下：</p><p><img src="//qn.atecher.com/mts/20180411/3843705129616384" alt="Image-13"></p><p>Source类是被装饰类，Decorator类是一个装饰类，可以为Source类动态的添加一些功能，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"the original method!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Sourceable source;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Sourceable source)</span></span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.source = source;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"before decorator!"</span>);</span><br><span class="line">      source.method();</span><br><span class="line">      System.out.println(<span class="string">"after decorator!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Sourceable source = <span class="keyword">new</span> Source();</span><br><span class="line">      Sourceable obj = <span class="keyword">new</span> Decorator(source);</span><br><span class="line">      obj.method();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">before decorator!</span><br><span class="line">the original method!</span><br><span class="line">after decorator!</span><br></pre></td></tr></table></figure></p><p>装饰器模式的应用场景：</p><ol><li><p>需要扩展一个类的功能。</p></li><li><p>动态的为一个对象增加功能，而且还能动态撤销。（继承不能做到这一点，继承的功能是静态的，不能动态增删。）</p></li></ol><p>缺点：产生过多相似的对象，不易排错！</p><h3 id="代理模式（Proxy）"><a href="#代理模式（Proxy）" class="headerlink" title="代理模式（Proxy）"></a>代理模式（Proxy）</h3><p>其实每个模式名称就表明了该模式的作用，代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。先来看看关系图：</p><p><img src="//qn.atecher.com/mts/20180411/3843705139627008" alt="Image-14"></p><p>根据上文的阐述，代理模式就比较容易的理解了，我们看下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Source</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"the original method!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Source source;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">super</span>();</span><br><span class="line">      <span class="keyword">this</span>.source = <span class="keyword">new</span> Source();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">      source.method();</span><br><span class="line">      atfer();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">atfer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"after proxy!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"before proxy!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Sourceable source = <span class="keyword">new</span> Proxy();</span><br><span class="line">      source.method();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br>    before proxy!<br>    the original method!<br>    after proxy!</p><p>代理模式的应用场景：</p><p>如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：</p><ol><li><p>修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。</p></li><li><p>就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。</p></li></ol><p>使用代理模式，可以将功能划分的更加清晰，有助于后期维护！</p><h3 id="外观模式（Facade）"><a href="#外观模式（Facade）" class="headerlink" title="外观模式（Facade）"></a>外观模式（Facade）</h3><p>外观模式是为了解决类与类之家的依赖关系的，像spring一样，可以将类和类之间的关系配置到配置文件中，而外观模式就是将他们的关系放在一个Facade类中，降低了类类之间的耦合度，该模式中没有涉及到接口，看下类图：（我们以一个计算机的启动过程为例）</p><p><img src="//qn.atecher.com/mts/20180411/3843705145754624" alt="Image-15"></p><p>我们先看下实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CPU</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"cpu startup!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cpu shutdown!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"memory startup!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"memory shutdown!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Disk</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"disk startup!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"disk shutdown!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> CPU cpu;</span><br><span class="line">  <span class="keyword">private</span> Memory memory;</span><br><span class="line">  <span class="keyword">private</span> Disk disk;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cpu = <span class="keyword">new</span> CPU();</span><br><span class="line">        memory = <span class="keyword">new</span> Memory();</span><br><span class="line">      disk = <span class="keyword">new</span> Disk();</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startup</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"start the computer!"</span>);</span><br><span class="line">      cpu.startup();</span><br><span class="line">      memory.startup();</span><br><span class="line">      disk.startup();</span><br><span class="line">      System.out.println(<span class="string">"start computer finished!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"begin to close the computer!"</span>);</span><br><span class="line">        cpu.shutdown();</span><br><span class="line">      memory.shutdown();</span><br><span class="line">      disk.shutdown();</span><br><span class="line">      System.out.println(<span class="string">"computer closed!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User类如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">      computer.startup();</span><br><span class="line">      computer.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：</p><pre><code>start the computer!cpu startup!memory startup!disk startup!start computer finished!begin to close the computer!cpu shutdown!memory shutdown!disk shutdown!computer closed!</code></pre><p>如果我们没有Computer类，那么，CPU、Memory、Disk他们之间将会相互持有实例，产生关系，这样会造成严重的依赖，修改一个类，可能会带来其他类的修改，这不是我们想要看到的，有了Computer类，他们之间的关系被放在了Computer类里，这样就起到了解耦的作用，这，就是外观模式！</p><h3 id="桥接模式（Bridge）"><a href="#桥接模式（Bridge）" class="headerlink" title="桥接模式（Bridge）"></a>桥接模式（Bridge）</h3><p>桥接模式就是把事物和其具体实现分开，使他们可以各自独立的变化。桥接的用意是：<strong>将抽象化与实现化解耦，使得二者可以独立变化</strong>，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。我们来看看关系图：</p><p><img src="//qn.atecher.com/mts/20180411/3843705159123968" alt="Image-16"></p><p>实现代码：</p><p>先定义接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别定义两个实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceSub1</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"this is the first sub!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceSub2</span> <span class="keyword">implements</span> <span class="title">Sourceable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"this is the second sub!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义一个桥，持有Sourceable的一个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Bridge</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Sourceable source;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">      source.method();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Sourceable <span class="title">getSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> source;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSource</span><span class="params">(Sourceable source)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.source = source;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBridge</span> <span class="keyword">extends</span> <span class="title">Bridge</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">      getSource().method();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      Bridge bridge = <span class="keyword">new</span> MyBridge();</span><br><span class="line">        <span class="comment">/*调用第一个对象*/</span></span><br><span class="line">        Sourceable source1 = <span class="keyword">new</span> SourceSub1();</span><br><span class="line">      bridge.setSource(source1);</span><br><span class="line">        bridge.method();</span><br><span class="line">      <span class="comment">/*调用第二个对象*/</span></span><br><span class="line">      Sourceable source2 = <span class="keyword">new</span> SourceSub2();</span><br><span class="line">      bridge.setSource(source2);</span><br><span class="line">      bridge.method();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output：</p><pre><code>this is the first sub!this is the second sub!</code></pre><p>这样，就通过对Bridge类的调用，实现了对接口Sourceable的实现类SourceSub1和SourceSub2的调用。接下来我再画个图，大家就应该明白了，因为这个图是我们JDBC连接的原理，有数据库学习基础的，一结合就都懂了。</p><p><img src="//qn.atecher.com/mts/20180411/3843705165382656" alt="Image-17"></p><h3 id="组合模式（Composite）"><a href="#组合模式（Composite）" class="headerlink" title="组合模式（Composite）"></a>组合模式（Composite）</h3><p>组合模式有时又叫<strong>部分-整体</strong>模式在处理类似树形结构的问题时比较方便，看看关系图：</p><p><img src="//qn.atecher.com/mts/20180411/3843705171149824" alt="Image-18"></p><p>直接来看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="keyword">private</span> TreeNode parent;</span><br><span class="line">  <span class="keyword">private</span> Vector&lt;TreeNode&gt; children = <span class="keyword">new</span> Vector&lt;TreeNode&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> TreeNode <span class="title">getParent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> parent;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setParent</span><span class="params">(TreeNode parent)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.parent = parent;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加孩子节点</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">      children.add(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//删除孩子节点</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(TreeNode node)</span></span>&#123;</span><br><span class="line">      children.remove(node);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//取得孩子节点</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Enumeration&lt;TreeNode&gt; <span class="title">getChildren</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> children.elements();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  TreeNode root = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Tree</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      root = <span class="keyword">new</span> TreeNode(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Tree tree = <span class="keyword">new</span> Tree(<span class="string">"A"</span>);</span><br><span class="line">      TreeNode nodeB = <span class="keyword">new</span> TreeNode(<span class="string">"B"</span>);</span><br><span class="line">      TreeNode nodeC = <span class="keyword">new</span> TreeNode(<span class="string">"C"</span>);</span><br><span class="line"></span><br><span class="line">      nodeB.add(nodeC);</span><br><span class="line">      tree.root.add(nodeB);</span><br><span class="line">      System.out.println(<span class="string">"build the tree finished!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景：将多个对象组合在一起进行操作，常用于表示树形结构中，例如二叉树，数等。</p><h3 id="享元模式（Flyweight）"><a href="#享元模式（Flyweight）" class="headerlink" title="享元模式（Flyweight）"></a>享元模式（Flyweight）</h3><p>享元模式的主要目的是实现对象的共享，即共享池，当系统中对象多的时候可以减少内存的开销，通常与工厂模式一起使用。</p><p><img src="//qn.atecher.com/mts/20180411/3843705176458240" alt="Image-19"></p><p>FlyWeightFactory负责创建和管理享元单元，当一个客户端请求时，工厂需要检查当前对象池中是否有符合条件的对象，如果有，就返回已经存在的对象，如果没有，则创建一个新对象，FlyWeight是超类。一提到共享池，我们很容易联想到Java里面的JDBC连接池，想想每个连接的特点，我们不难总结出：适用于作共享的一些个对象，他们有一些共有的属性，就拿数据库连接池来说，url、driverClassName、username、password及dbname，这些属性对于每个连接来说都是一样的，所以就适合用享元模式来处理，建一个工厂类，将上述类似属性作为内部数据，其它的作为外部数据，在方法调用时，当做参数传进来，这样就节省了空间，减少了实例的数量。</p><p>看个例子：</p><p><img src="//qn.atecher.com/mts/20180411/3843705182536704" alt="Image-20"></p><p>看下数据库连接池的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Vector&lt;Connection&gt; pool;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*公有属性*/</span></span><br><span class="line">  <span class="keyword">private</span> String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line">  <span class="keyword">private</span> String username = <span class="string">"root"</span>;</span><br><span class="line">  <span class="keyword">private</span> String password = <span class="string">"root"</span>;</span><br><span class="line">  <span class="keyword">private</span> String driverClassName = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> poolSize = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> ConnectionPool instance = <span class="keyword">null</span>;</span><br><span class="line">  Connection conn = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*构造方法，做一些初始化工作*/</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ConnectionPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      pool = <span class="keyword">new</span> Vector&lt;Connection&gt;(poolSize);</span><br><span class="line"></span><br><span class="line">      **<span class="keyword">for</span>** (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">          **<span class="keyword">try</span>** &#123;</span><br><span class="line">              Class.forName(driverClassName);</span><br><span class="line">                conn = DriverManager.getConnection(url, username, password);</span><br><span class="line">              pool.add(conn);</span><br><span class="line">          &#125; **<span class="keyword">catch</span>** (ClassNotFoundException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125; **<span class="keyword">catch</span>** (SQLException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 返回连接到连接池 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      pool.add(conn);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 返回连接池中的一个数据库连接 */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (pool.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          Connection conn = pool.get(<span class="number">0</span>);</span><br><span class="line">            pool.remove(conn);</span><br><span class="line">          <span class="keyword">return</span> conn;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过连接池的管理，实现了数据库连接的共享，不需要每一次都重新创建连接，节省了数据库重新创建的开销，提升了系统的性能！本章讲解了7种结构型模式，因为篇幅的问题，剩下的11种行为型模式。</p><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>本章是关于设计模式的最后一讲，会讲到第三种设计模式——行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。这段时间一直在写关于设计模式的东西，终于写到一半了，写博文是个很费时间的东西，因为我得为读者负责，不论是图还是代码还是表述，都希望能尽量写清楚，以便读者理解，我想不论是我还是读者，都希望看到高质量的博文出来，从我本人出发，我会一直坚持下去，不断更新，源源动力来自于读者朋友们的不断支持，我会尽自己的努力，写好每一篇文章！希望大家能不断给出意见和建议，共同打造完美的博文！</p><p>先来张图，看看这11中模式的关系：</p><p>第一类：通过父类与子类的关系进行实现。第二类：两个类之间。第三类：类的状态。第四类：通过中间类</p><p><img src="//qn.atecher.com/mts/20180411/3843710545871872" alt="Image-21"></p><h3 id="策略模式（strategy）"><a href="#策略模式（strategy）" class="headerlink" title="策略模式（strategy）"></a>策略模式（strategy）</h3><p>策略模式定义了一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。需要设计一个接口，为一系列实现类提供统一的方法，多个实现类实现该接口，设计一个抽象类（可有可无，属于辅助类），提供辅助函数，关系图如下：</p><p><img src="//qn.atecher.com/mts/20180411/3843710548296704" alt="Image-22"></p><p>图中ICalculator提供同意的方法，AbstractCalculator是辅助类，提供辅助方法，接下来，依次实现下每个类：</p><p>首先统一接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICalculator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String exp)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>辅助类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCalculator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] split(String exp,String opt)&#123;</span><br><span class="line">      String array[] = exp.split(opt);</span><br><span class="line">      <span class="keyword">int</span> arrayInt[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">      arrayInt[<span class="number">0</span>] = Integer.parseInt(array[<span class="number">0</span>]);</span><br><span class="line">        arrayInt[<span class="number">1</span>] = Integer.parseInt(array[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> arrayInt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>三个实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plus</span> <span class="keyword">extends</span> <span class="title">AbstractCalculator</span> <span class="keyword">implements</span> <span class="title">ICalculator</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String exp)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> arrayInt[] = split(exp,<span class="string">"\\+"</span>);</span><br><span class="line">      <span class="keyword">return</span> arrayInt[<span class="number">0</span>]+arrayInt[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minus</span> <span class="keyword">extends</span> <span class="title">AbstractCalculator</span> <span class="keyword">implements</span> <span class="title">ICalculator</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String exp)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> arrayInt[] = split(exp,<span class="string">"-"</span>);</span><br><span class="line">      <span class="keyword">return</span> arrayInt[<span class="number">0</span>]-arrayInt[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Multiply</span> <span class="keyword">extends</span> <span class="title">AbstractCalculator</span> <span class="keyword">implements</span> <span class="title">ICalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String exp)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> arrayInt[] = split(exp,<span class="string">"\\*"</span>);</span><br><span class="line">      <span class="keyword">return</span> arrayInt[<span class="number">0</span>]*arrayInt[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>简单的测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String exp = <span class="string">"2+8"</span>;</span><br><span class="line">      ICalculator cal = <span class="keyword">new</span> Plus();</span><br><span class="line">      <span class="keyword">int</span> result = cal.calculate(exp);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：10</p><p>策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。</p><h3 id="模板方法模式（Template-Method）"><a href="#模板方法模式（Template-Method）" class="headerlink" title="模板方法模式（Template Method）"></a>模板方法模式（Template Method）</h3><p>解释一下模板方法模式，就是指：一个抽象类中，有一个主方法，再定义1…n个方法，可以是抽象的，也可以是实际的方法，定义一个类，继承该抽象类，重写抽象方法，通过调用抽象类，实现对子类的调用，先看个关系图：</p><p><img src="//qn.atecher.com/mts/20180411/3843710552327168" alt="Image-24"></p><p>就是在AbstractCalculator类中定义一个主方法calculate，calculate()调用spilt()等，Plus和Minus分别继承AbstractCalculator类，通过对AbstractCalculator的调用实现对子类的调用，看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*主方法，实现对本类其它方法的调用*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String exp,String opt)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> array[] = split(exp,opt);</span><br><span class="line">      <span class="keyword">return</span> calculate(array[<span class="number">0</span>],array[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*被子类重写的方法*/</span></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">int</span>[] split(String exp,String opt)&#123;</span><br><span class="line">      String array[] = exp.split(opt);</span><br><span class="line">      <span class="keyword">int</span> arrayInt[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">      arrayInt[<span class="number">0</span>] = Integer.parseInt(array[<span class="number">0</span>]);</span><br><span class="line">      arrayInt[<span class="number">1</span>] = Integer.parseInt(array[<span class="number">1</span>]);</span><br><span class="line">      <span class="keyword">return</span> arrayInt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plus</span> <span class="keyword">extends</span> <span class="title">AbstractCalculator</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1 + num2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      String exp = <span class="string">"8+8"</span>;</span><br><span class="line">      AbstractCalculator cal = <span class="keyword">new</span> Plus();</span><br><span class="line">      <span class="keyword">int</span> result = cal.calculate(exp, <span class="string">"\\+"</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我跟踪下这个小程序的执行过程：首先将exp和”\+”做参数，调用AbstractCalculator类里的calculate(String,String)方法，在calculate(String,String)里调用同类的split()，之后再调用calculate(int ,int)方法，从这个方法进入到子类中，执行完return num1 + num2后，将值返回到AbstractCalculator类，赋给result，打印出来。正好验证了我们开头的思路。</p><h3 id="观察者模式（Observer）"><a href="#观察者模式（Observer）" class="headerlink" title="观察者模式（Observer）"></a>观察者模式（Observer）</h3><p>包括这个模式在内的接下来的四个模式，都是类和类之间的关系，不涉及到继承，学的时候应该 记得归纳，记得本文最开始的那个图。观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。先来看看关系图：</p><p><img src="//qn.atecher.com/mts/20180411/3843710555096064" alt="Image-25"></p><p>我解释下这些类的作用：MySubject类就是我们的主对象，Observer1和Observer2是依赖于MySubject的对象，当MySubject变化时，Observer1和Observer2必然变化。AbstractSubject类中定义着需要监控的对象列表，可以对其进行修改：增加或删除被监控对象，且当MySubject变化时，负责通知在列表内存在的对象。我们看实现代码：</p><p>一个Observer接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两个实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer1</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"observer1 has received!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer2</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"observer2 has received!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Subject接口及实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="comment">/*增加观察者*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">  <span class="comment">/*删除观察者*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">  <span class="comment">/*通知所有的观察者*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">/*自身的操作*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Vector&lt;Observer&gt; vector = <span class="keyword">new</span> Vector&lt;Observer&gt;();</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">      vector.add(observer);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">      vector.remove(observer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Enumeration&lt;Observer&gt; enumo = vector.elements();</span><br><span class="line">      **<span class="keyword">while</span>**(enumo.hasMoreElements())&#123;</span><br><span class="line">          enumo.nextElement().update();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySubject</span> <span class="keyword">extends</span> <span class="title">AbstractSubject</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"update self!"</span>);</span><br><span class="line">      notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Subject sub = <span class="keyword">new</span> MySubject();</span><br><span class="line">      sub.add(<span class="keyword">new</span> Observer1());</span><br><span class="line">      sub.add(<span class="keyword">new</span> Observer2());</span><br><span class="line">      sub.operation();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update self!</span><br><span class="line">observer1 has received!</span><br><span class="line">observer2 has received!</span><br></pre></td></tr></table></figure></p><p>这些东西，其实不难，只是有些抽象，不太容易整体理解，建议读者：<strong>根据关系图，新建项目，自己写代码（或者参考我的代码）,按照总体思路走一遍，这样才能体会它的思想，理解起来容易！</strong></p><h3 id="迭代子模式（Iterator）"><a href="#迭代子模式（Iterator）" class="headerlink" title="迭代子模式（Iterator）"></a>迭代子模式（Iterator）</h3><p>顾名思义，迭代器模式就是顺序访问聚集中的对象，一般来说，集合中非常常见，如果对集合类比较熟悉的话，理解本模式会十分轻松。这句话包含两层意思：一是需要遍历的对象，即聚集对象，二是迭代器对象，用于对聚集对象进行遍历访问。我们看下关系图：</p><p> <img src="//qn.atecher.com/mts/20180411/3843710557897728" alt="Image-26"></p><p>这个思路和我们常用的一模一样，MyCollection中定义了集合的一些操作，MyIterator中定义了一系列迭代操作，且持有Collection实例，我们来看看实现代码：<br>两个接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">/*取得集合元素*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">  <span class="comment">/*取得集合大小*/</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">  <span class="comment">//前移</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">previous</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//后移</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">public</span> **<span class="keyword">boolean</span>** hasNext();</span><br><span class="line">  <span class="comment">//取得第一个元素</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>两个实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCollection</span> <span class="keyword">implements</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> String string[] = &#123;<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="string">"C"</span>,<span class="string">"D"</span>,<span class="string">"E"</span>&#125;;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MyIterator(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> string[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> string.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Collection collection;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyIterator</span><span class="params">(Collection collection)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.collection = collection;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(pos &gt; <span class="number">0</span>)&#123;</span><br><span class="line">          pos--;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> collection.get(pos);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(pos&lt;collection.size()-<span class="number">1</span>)&#123;</span><br><span class="line">          pos++;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">return</span> collection.get(pos);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> **<span class="keyword">boolean</span>** hasNext() &#123;</span><br><span class="line">      <span class="keyword">if</span>(pos&lt;collection.size()-<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">return</span> **<span class="keyword">true</span>**;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          <span class="keyword">return</span> **<span class="keyword">false</span>**;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      pos = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> collection.get(pos);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Collection collection = <span class="keyword">new</span> MyCollection();</span><br><span class="line">      Iterator it = collection.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            System.out.println(it.next());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：A B C D E</p><p>此处我们貌似模拟了一个集合类的过程，感觉是不是很爽？其实JDK中各个类也都是这些基本的东西，加一些设计模式，再加一些优化放到一起的，只要我们把这些东西学会了，掌握好了，我们也可以写出自己的集合类，甚至框架！</p><h3 id="责任链模式（Chain-of-Responsibility）"><a href="#责任链模式（Chain-of-Responsibility）" class="headerlink" title="责任链模式（Chain of Responsibility）"></a>责任链模式（Chain of Responsibility）</h3><p>接下来我们将要谈谈责任链模式，有多个对象，每个对象持有对下一个对象的引用，这样就会形成一条链，请求在这条链上传递，直到某一对象决定处理该请求。但是发出者并不清楚到底最终那个对象会处理该请求，所以，责任链模式可以实现，在隐瞒客户端的情况下，对系统进行动态的调整。先看看关系图：</p><p> <img src="//qn.atecher.com/mts/20180411/3843710561289216" alt="Image-27"></p><p>Abstracthandler类提供了get和set方法，方便MyHandle类设置和修改引用对象，MyHandle类是核心，实例化后生成一系列相互持有的对象，构成一条链。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractHandler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Handler handler;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Handler <span class="title">getHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> handler;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHandler</span><span class="params">(Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">AbstractHandler</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(name+<span class="string">"deal!"</span>);</span><br><span class="line">      <span class="keyword">if</span>(getHandler()!=<span class="keyword">null</span>)&#123;</span><br><span class="line">          getHandler().operator();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      MyHandler h1 = <span class="keyword">new</span> MyHandler(<span class="string">"h1"</span>);</span><br><span class="line">      MyHandler h2 = <span class="keyword">new</span> MyHandler(<span class="string">"h2"</span>);</span><br><span class="line">      MyHandler h3 = <span class="keyword">new</span> MyHandler(<span class="string">"h3"</span>);</span><br><span class="line">      h1.setHandler(h2);</span><br><span class="line">      h2.setHandler(h3);</span><br><span class="line">      h1.operator();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h1deal!</span><br><span class="line">h2deal!</span><br><span class="line">h3deal!</span><br></pre></td></tr></table></figure></p><p>此处强调一点就是，链接上的请求可以是一条链，可以是一个树，还可以是一个环，模式本身不约束这个，需要我们自己去实现，同时，在一个时刻，命令只允许由一个对象传给另一个对象，而不允许传给多个对象。</p><h3 id="命令模式（Command）"><a href="#命令模式（Command）" class="headerlink" title="命令模式（Command）"></a>命令模式（Command）</h3><p>命令模式很好理解，举个例子，司令员下令让士兵去干件事情，从整个事情的角度来考虑，司令员的作用是，发出口令，口令经过传递，传到了士兵耳朵里，士兵去执行。这个过程好在，三者相互解耦，任何一方都不用去依赖其他人，只需要做好自己的事儿就行，司令员要的是结果，不会去关注到底士兵是怎么实现的。我们看看关系图：</p><p><img src="//qn.atecher.com/mts/20180411/3843710565417984" alt="Image-28"></p><p>Invoker是调用者（司令员），Receiver是被调用者（士兵），MyCommand是命令，实现了Command接口，持有接收对象，看实现代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exe</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MyCommand</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      receiver.action();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"command received!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Command command;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>&#123;</span><br><span class="line">        command.exe();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Receiver receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line">      Command cmd = <span class="keyword">new</span> MyCommand(receiver);</span><br><span class="line">      Invoker invoker = <span class="keyword">new</span> Invoker(cmd);</span><br><span class="line">        invoker.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command received!</span><br></pre></td></tr></table></figure></p><p>这个很哈理解，命令模式的目的就是达到命令的发出者和执行者之间解耦，实现请求和执行分开，熟悉Struts的同学应该知道，Struts其实就是一种将请求和呈现分离的技术，其中必然涉及命令模式的思想！</p><p>其实每个设计模式都是很重要的一种思想，看上去很熟，其实是因为我们在学到的东西中都有涉及，尽管有时我们并不知道，其实在Java本身的设计之中处处都有体现，像AWT、JDBC、集合类、IO管道或者是Web框架，里面设计模式无处不在。因为我们篇幅有限，很难讲每一个设计模式都讲的很详细，不过我会尽我所能，尽量在有限的空间和篇幅内，把意思写清楚了，更好让大家明白。本章不出意外的话，应该是设计模式最后一讲了，首先还是上一下上篇开头的那个图：</p><p><img src="//qn.atecher.com/mts/20180411/3843712638370816" alt="点击查看原始大小图片"></p><p>本章讲讲第三类和第四类。</p><h3 id="备忘录模式（Memento）"><a href="#备忘录模式（Memento）" class="headerlink" title="备忘录模式（Memento）"></a>备忘录模式（Memento）</h3><p>主要目的是保存一个对象的某个状态，以便在适当的时候恢复对象，个人觉得叫备份模式更形象些，通俗的讲下：假设有原始类A，A中有各种属性，A可以决定需要备份的属性，备忘录类B是用来存储A的一些内部状态，类C呢，就是一个用来存储备忘录的，且只能存储，不能修改等操作。做个图来分析一下：</p><p><img src="//qn.atecher.com/mts/20180411/3843712644514816" alt="Image-30"></p><p>Original类是原始类，里面有需要保存的属性value及创建一个备忘录类，用来保存value值。Memento类是备忘录类，Storage类是存储备忘录的类，持有Memento类的实例，该模式很好理解。直接看源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Original</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String value;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Original</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Memento <span class="title">createMemento</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Memento(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreMemento</span><span class="params">(Memento memento)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = memento.getValue();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Memento</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Storage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Memento memento;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Storage</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.memento = memento;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 创建原始类</span></span><br><span class="line">      Original origi = <span class="keyword">new</span> Original(<span class="string">"egg"</span>);</span><br><span class="line">        <span class="comment">// 创建备忘录</span></span><br><span class="line">      Storage storage = <span class="keyword">new</span> Storage(origi.createMemento());</span><br><span class="line">      <span class="comment">// 修改原始类的状态</span></span><br><span class="line">      System.out.println(<span class="string">"初始化状态为："</span> + origi.getValue());</span><br><span class="line">      origi.setValue(<span class="string">"niu"</span>);</span><br><span class="line">      System.out.println(<span class="string">"修改后的状态为："</span> + origi.getValue());</span><br><span class="line">      <span class="comment">// 回复原始类的状态</span></span><br><span class="line">      origi.restoreMemento(storage.getMemento());</span><br><span class="line">      System.out.println(<span class="string">"恢复后的状态为："</span> + origi.getValue());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">初始化状态为：egg</span><br><span class="line">修改后的状态为：niu</span><br><span class="line">恢复后的状态为：egg</span><br></pre></td></tr></table></figure></p><p>简单描述下：新建原始类时，value被初始化为egg，后经过修改，将value的值置为niu，最后倒数第二行进行恢复状态，结果成功恢复了。其实我觉得这个模式叫“备份-恢复”模式最形象。</p><h3 id="状态模式（State）"><a href="#状态模式（State）" class="headerlink" title="状态模式（State）"></a>状态模式（State）</h3><p>核心思想就是：当对象的状态改变时，同时改变其行为，很好理解！就拿QQ来说，有几种状态，在线、隐身、忙碌等，每个状态对应不同的操作，而且你的好友也能看到你的状态，所以，状态模式就两点：1、可以通过改变状态来获得不同的行为。2、你的好友能同时看到你的变化。看图：</p><p><img src="//qn.atecher.com/mts/20180411/3843712652493824" alt="Image-32"></p><p>State类是个状态类，Context类可以实现切换，我们来看看代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xtfggef.dp.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态类的核心类</span></span><br><span class="line"><span class="comment"> * 2012-12-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> erqing</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String value;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"execute the first opt!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"execute the second opt!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.xtfggef.dp.state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 状态模式的切换类   2012-12-1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> erqing</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.state = state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> State <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (state.getValue().equals(<span class="string">"state1"</span>)) &#123;</span><br><span class="line">          state.method1();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state.getValue().equals(<span class="string">"state2"</span>)) &#123;</span><br><span class="line">          state.method2();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      State state = <span class="keyword">new</span> State();</span><br><span class="line">      Context context = <span class="keyword">new</span> Context(state);</span><br><span class="line">        <span class="comment">//设置第一种状态</span></span><br><span class="line">      state.setValue(<span class="string">"state1"</span>);</span><br><span class="line">      context.method();</span><br><span class="line">      <span class="comment">//设置第二种状态</span></span><br><span class="line">      state.setValue(<span class="string">"state2"</span>);</span><br><span class="line">      context.method();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execute the first opt!</span><br><span class="line">execute the second opt!</span><br></pre></td></tr></table></figure></p><p>根据这个特性，状态模式在日常开发中用的挺多的，尤其是做网站的时候，我们有时希望根据对象的某一属性，区别开他们的一些功能，比如说简单的权限控制等。</p><h3 id="访问者模式（Visitor）"><a href="#访问者模式（Visitor）" class="headerlink" title="访问者模式（Visitor）"></a>访问者模式（Visitor）</h3><p>访问者模式把数据结构和作用于结构上的操作解耦合，使得操作集合可相对自由地演化。访问者模式适用于数据结构相对稳定算法又易变化的系统。因为访问者模式使得算法操作增加变得容易。若系统数据结构对象易于变化，经常有新的数据对象增加进来，则不适合使用访问者模式。访问者模式的优点是增加操作很容易，因为增加操作意味着增加新的访问者。访问者模式将有关行为集中到一个访问者对象中，其改变不影响系统数据结构。其缺点就是增加新的数据结构很困难。—— From 百科</p><p>简单来说，访问者模式就是一种分离对象数据结构与行为的方法，通过这种分离，可达到为一个被访问者动态添加新的操作而无需做其它的修改的效果。简单关系图：</p><p><img src="//qn.atecher.com/mts/20180411/3843712654705664" alt="Image-33"></p><p>来看看原码：一个Visitor类，存放要访问的对象，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Subject sub)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(Subject sub)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"visit the subject："</span>\+sub.getSubject());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Subject类，accept方法，接受将要访问它的对象，getSubject()获取将要被访问的属性，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getSubject</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">      visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getSubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"love"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Visitor visitor = <span class="keyword">new</span> MyVisitor();</span><br><span class="line">      Subject sub = <span class="keyword">new</span> MySubject();</span><br><span class="line">        sub.accept(visitor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：visit the subject：love</p><p>该模式适用场景：如果我们想为一个现有的类增加新功能，不得不考虑几个事情：</p><ol><li>新功能会不会与现有功能出现兼容性问题？</li><li>以后会不会再需要添加？</li><li>如果类不允许修改代码怎么办？</li></ol><p>面对这些问题，最好的解决方法就是使用访问者模式，访问者模式适用于数据结构相对稳定的系统，把数据结构和算法解耦。</p><h3 id="中介者模式（Mediator）"><a href="#中介者模式（Mediator）" class="headerlink" title="中介者模式（Mediator）"></a>中介者模式（Mediator）</h3><p>中介者模式也是用来降低类类之间的耦合的，因为如果类类之间有依赖关系的话，不利于功能的拓展和维护，因为只要修改一个对象，其它关联的对象都得进行修改。如果使用中介者模式，只需关心和Mediator类的关系，具体类类之间的关系及调度交给Mediator就行，这有点像spring容器的作用。先看看图：</p><p><img src="//qn.atecher.com/mts/20180411/3843712656638976" alt="Image-34"></p><p>User类统一接口，User1和User2分别是不同的对象，二者之间有关联，如果不采用中介者模式，则需要二者相互持有引用，这样二者的耦合度很高，为了解耦，引入了Mediator类，提供统一接口，MyMediator为其实现类，里面持有User1和User2的实例，用来实现对User1和User2的控制。这样User1和User2两个对象相互独立，他们只需要保持好和Mediator之间的关系就行，剩下的全由MyMediator类来维护！基本实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createMediator</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">workAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyMediator</span> <span class="keyword">implements</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> User user1;</span><br><span class="line">  <span class="keyword">private</span> User user2;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getUser1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> user2;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      user1 = <span class="keyword">new</span> User1(<span class="keyword">this</span>);</span><br><span class="line">      user2 = <span class="keyword">new</span> User2(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">workAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        user1.work();</span><br><span class="line">      user2.work();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Mediator mediator;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Mediator <span class="title">getMediator</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mediator;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User1</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">User1</span><span class="params">(Mediator mediator)</span></span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(mediator);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"user1 exe!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User2</span> <span class="keyword">extends</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">User2</span><span class="params">(Mediator mediator)</span></span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(mediator);</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"user2 exe!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Mediator mediator = <span class="keyword">new</span> MyMediator();</span><br><span class="line">      mediator.createMediator();</span><br><span class="line">      mediator.workAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user1 exe!</span><br><span class="line">user2 exe!</span><br></pre></td></tr></table></figure></p><h3 id="解释器模式（Interpreter）"><a href="#解释器模式（Interpreter）" class="headerlink" title="解释器模式（Interpreter）"></a>解释器模式（Interpreter）</h3><p>解释器模式是我们暂时的最后一讲，一般主要应用在OOP开发中的编译器的开发中，所以适用面比较窄。</p><p><img src="//qn.atecher.com/mts/20180411/3843712659293184" alt="Image-35"></p><p>Context类是一个上下文环境类，Plus和Minus分别是用来计算的实现，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plus</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> context.getNum1()+context.getNum2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Minus</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">interpret</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> context.getNum1()-context.getNum2();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num1;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> num2;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num1 = num1;</span><br><span class="line">        <span class="keyword">this</span>.num2 = num2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum1</span><span class="params">(<span class="keyword">int</span> num1)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.num1 = num1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> num2;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum2</span><span class="params">(<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.num2 = num2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 计算9+2-8的值</span></span><br><span class="line">      <span class="keyword">int</span> result = <span class="keyword">new</span> Minus().interpret((<span class="keyword">new</span> Context(<span class="keyword">new</span> Plus().interpret(<span class="keyword">new</span> Context(<span class="number">9</span>, <span class="number">2</span>)), <span class="number">8</span>)));</span><br><span class="line">        System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后输出正确的结果：3。</p><p>基本就这样，解释器模式用来做各种各样的解释器，如正则表达式等的解释器等等！</p><blockquote><p>本文系转载文章，原作者为egg，原文链接:<a href="http://blog.csdn.net/zhangerqing" target="_blank" rel="noopener">请点此处</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理的运用设计模式可以完美的解决很多问题，每种模式在现在中都有相应的原理来与之对应，每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是它能被广泛应用的原因。本章系&lt;strong&gt;Java之美[从菜鸟到高手演变]系列&lt;/strong&gt;之设计模式，我们会以理论与实践相结合的方式来进行本章的学习，希望广大程序爱好者，学好设计模式，做一个优秀的软件工程师！&lt;/p&gt;
    
    </summary>
    
      <category term="软件工程" scheme="http://blog.atecher.com/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="设计模式" scheme="http://blog.atecher.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java算法题汇总</title>
    <link href="http://blog.atecher.com/2018/04/11/Java-Algorithms-Problem/"/>
    <id>http://blog.atecher.com/2018/04/11/Java-Algorithms-Problem/</id>
    <published>2018-04-11T14:00:10.000Z</published>
    <updated>2022-01-28T10:28:39.115Z</updated>
    
    <content type="html"><![CDATA[<h2 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h2><p>有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？</p><p>1.程序分析：这个是典型的<a href="https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97" target="_blank" rel="noopener">斐波那契数列</a>，兔子的规律为数列1,1,2,3,5,8,13,21….</p><p>具体分析如下：</p><blockquote><p>f(1) = 1(第1个月有一对兔子）<br>f(2) = 1(第2个月还是一对兔子）<br>f(3) = 2(原来有一对兔子，第3个开始，每个月生一对兔子）<br>f(4) = 3(原来有两对兔子，有一对可以生育）<br>f(5) = 5(原来有3对兔子，第3个月出生的那对兔子也可以生育了，那么现在有两对兔子可以生育）<br>f(6) = 8(原来有5对兔子，第4个月出生的那对兔子也可以生育了，那么现在有3对兔子可以生育）<br>…………..<br>由以上可以看出，第n个月兔子的对数为<br>f(n) = f(n - 1) + f(n - 2);<br>f(n-1)是上个月的兔子数量，是原来有的。<br>f(n-2)是可以生育的兔子数，即多出来的数量。第n-2个月开始后的第3个月是第n个月，此时第n-2个月时的兔子都可以生育了</p></blockquote><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rabbit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++)</span><br><span class="line">            System.out.println(f(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>||x == <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> f(x - <span class="number">1</span>) + f(x - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断101-200之间有多少个素数，并输出所有素数"><a href="#判断101-200之间有多少个素数，并输出所有素数" class="headerlink" title="判断101-200之间有多少个素数，并输出所有素数"></a>判断101-200之间有多少个素数，并输出所有素数</h2><p>1.程序分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除，则表明此数不是素数，反之是素数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeNumber</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">200</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i%j==<span class="number">0</span>)&#123;</span><br><span class="line">                    flag=<span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.print(<span class="string">" "</span>+i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印出所有的“水仙花数”"><a href="#打印出所有的“水仙花数”" class="headerlink" title="打印出所有的“水仙花数”"></a>打印出所有的“水仙花数”</h2><p>所谓水仙花数是指一个三位数，其各位数字立方和等于该数本身。例如：153是一个 水仙花数 ，因为153=1的三次方＋5的三次方＋3的三次方。</p><p>1.程序分析：利用for循环控制100-999个数，每个数分解出个位，十位，百位。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo03</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        math mymath = <span class="keyword">new</span> math();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">100</span>; i &lt;= <span class="number">999</span>; i++)</span><br><span class="line">            <span class="keyword">if</span> (mymath.shuixianhua(i) == <span class="keyword">true</span>)</span><br><span class="line">                System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">math</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shuixianhua</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">        i = x/<span class="number">100</span>;</span><br><span class="line">        j = (x % <span class="number">100</span>)/<span class="number">10</span>;</span><br><span class="line">        k = x % <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span> (x == i*i*i + j*j*j + k*k*k)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="将一个正整数分解质因数。例如：输入90-打印出90-2-3-3-5。"><a href="#将一个正整数分解质因数。例如：输入90-打印出90-2-3-3-5。" class="headerlink" title="将一个正整数分解质因数。例如：输入90,打印出90=2*3*3*5。"></a>将一个正整数分解质因数。例如：输入90,打印出90=2*3*3*5。</h2><p>1.程序分析：对n进行分解质因数，应先找到一个最小的质数i，然后按下述步骤完成：<br>(1)如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。<br>(2)如果n &gt; i，但n能被i整除，则应打印出i的值，并用n除以i的商,作为新的正整数你,重复执行第一步。<br>(3)如果n不能被i整除，则用i+1作为i的值,重复执行第一步。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeFactorization</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimeFactorization</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">factorization</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.print(i);</span><br><span class="line">                <span class="keyword">if</span>(n!=i)&#123;</span><br><span class="line">                    System.out.print(<span class="string">"*"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                fenjie(n/i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.exit(<span class="number">0</span>); <span class="comment">//退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入N的值："</span>);</span><br><span class="line">        <span class="keyword">int</span> N = in.nextInt();</span><br><span class="line">        System.out.print( <span class="string">"分解质因数："</span> + N +<span class="string">"="</span>);</span><br><span class="line">        <span class="keyword">new</span> PrimeFactorization().factorization(N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="利用条件运算符的嵌套来完成此题：学习成绩-90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。"><a href="#利用条件运算符的嵌套来完成此题：学习成绩-90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。" class="headerlink" title="利用条件运算符的嵌套来完成此题：学习成绩=90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。"></a>利用条件运算符的嵌套来完成此题：学习成绩=90分的同学用A表示，60-89分之间的用B表示，60分以下的用C表示。</h2><p>1.程序分析：(a&gt;b)?a:b这是条件运算符的基本例子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcademicRecord</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请输入N的值："</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> N = in.nextInt();</span><br><span class="line">        System.out.println(N &gt;= <span class="number">90</span> ?<span class="string">"A"</span>: (N &gt;= <span class="number">60</span> ? <span class="string">"B"</span>:<span class="string">"C"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="输入两个正整数m和n，求其最大公约数和最小公倍数。"><a href="#输入两个正整数m和n，求其最大公约数和最小公倍数。" class="headerlink" title="输入两个正整数m和n，求其最大公约数和最小公倍数。"></a>输入两个正整数m和n，求其最大公约数和最小公倍数。</h2><p>1.程序分析：利用辗除法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo06</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a,b,m,n;</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入一个正整数："</span>);</span><br><span class="line">        a=in.nextInt();</span><br><span class="line">        System.out.println(<span class="string">"再输入一个正整数："</span>);</span><br><span class="line">        b=in.nextInt();</span><br><span class="line">        commonDivisor use=<span class="keyword">new</span> commonDivisor();</span><br><span class="line">        m=use.commonDivisor(a,b);</span><br><span class="line">        n=a*b/m;</span><br><span class="line">        System.out.println(<span class="string">"最大公约数："</span>+m);</span><br><span class="line">        System.out.println(<span class="string">"最小公倍数："</span>+n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">commonDivisor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">commonDivisor</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x&lt;y)&#123;</span><br><span class="line">            <span class="keyword">int</span> t=x;</span><br><span class="line">            x=y;</span><br><span class="line">            y=t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(y!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> k=x%y;</span><br><span class="line">                x=y;</span><br><span class="line">                y=k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。"><a href="#输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。" class="headerlink" title="输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。"></a>输入一行字符，分别统计出其中英文字母、空格、数字和其它字符的个数。</h2><p>1.程序分析：利用for循环语句,if条件语句。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo07</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请输入一个字符串;"</span>);</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str=in.nextLine();</span><br><span class="line">        <span class="keyword">char</span>[] ch=str.toCharArray();</span><br><span class="line">        count use=<span class="keyword">new</span> count();</span><br><span class="line">        use.count(ch);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">count</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> digital,character,blank,other;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">(<span class="keyword">char</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;=<span class="string">'0'</span>&amp;&amp;arr[i]&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                digital++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>((arr[i]&gt;=<span class="string">'a'</span>&amp;&amp;arr[i]&lt;=<span class="string">'z'</span>)||(arr[i]&gt;=<span class="string">'A'</span>&amp;&amp;arr[i]&lt;=<span class="string">'Z'</span>))&#123;</span><br><span class="line">                character++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[i]==<span class="string">' '</span>)&#123;</span><br><span class="line">                blank++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                other++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"数字个数："</span>+digital);</span><br><span class="line">        System.out.println(<span class="string">"英文字母个数："</span>+character);</span><br><span class="line">        System.out.println(<span class="string">"空格个数："</span>+blank);</span><br><span class="line">        System.out.println(<span class="string">"其他字符个数："</span>+other);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="求s-a-aa-aaa-aaaa-aa…a的值，其中a是一个数字。"><a href="#求s-a-aa-aaa-aaaa-aa…a的值，其中a是一个数字。" class="headerlink" title="求s = a + aa + aaa + aaaa + aa…a的值，其中a是一个数字。"></a>求s = a + aa + aaa + aaaa + aa…a的值，其中a是一个数字。</h2><p>例如2 + 22 + 222 + 2222 + 22222(此时共有5个数相加)，几个数相加有键盘控制。</p><p>1.程序分析：关键是计算出每一项的值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo08</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(请输入a的值);</span><br><span class="line">        <span class="keyword">int</span> a = in.nextInt();</span><br><span class="line">        System.out.println(请输入n个数);</span><br><span class="line">        <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>,t=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            t += a;</span><br><span class="line">            a = a*<span class="number">10</span>;</span><br><span class="line">            s += t;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="一个数如果恰好等于它的因子之和，这个数就称为”完数”。"><a href="#一个数如果恰好等于它的因子之和，这个数就称为”完数”。" class="headerlink" title="一个数如果恰好等于它的因子之和，这个数就称为”完数”。"></a>一个数如果恰好等于它的因子之和，这个数就称为”完数”。</h2><p>例如6=1＋2＋3。编程找出1000以内的所有完数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)</span><br><span class="line">                <span class="keyword">if</span> (i % j == <span class="number">0</span>)</span><br><span class="line">                    s = s + j;</span><br><span class="line">            <span class="keyword">if</span> (s == i)</span><br><span class="line">                System.out.print(i + <span class="string">" "</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo09</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i,j,sum;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;<span class="number">1000</span>;i++)&#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i/<span class="number">2</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i%j==<span class="number">0</span>)&#123;</span><br><span class="line">                    sum+=j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum==i)&#123;</span><br><span class="line">                System.out.print(i+<span class="string">" its factors are:   "</span>);</span><br><span class="line">                <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=i/<span class="number">2</span>;j++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">                        System.out.print(j+<span class="string">", "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？"><a href="#一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？" class="headerlink" title="一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？"></a>一球从100米高度自由落下，每次落地后反跳回原高度的一半；再落下，求它在第10次落地时，共经过多少米？第10次反弹多高？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo10</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> h = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">            s += h;</span><br><span class="line">            h = h/<span class="number">2</span>;</span><br><span class="line">            s += h;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"经过路程："</span>+s);</span><br><span class="line">        System.out.println(<span class="string">"反弹高度："</span>+h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"><a href="#有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？" class="headerlink" title="有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？"></a>有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？</h2><p>1.程序分析：可填在百位、十位、个位的数字都是1、2、3、4。组成所有的排列后再去掉不满足条件的排列。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo11</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++)</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">4</span>; k++)</span><br><span class="line">              <span class="keyword">if</span> (i != j &amp;&amp; j != k &amp;&amp; i != k) &#123;</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">            System.out.println(i*<span class="number">100</span> + j*<span class="number">10</span> + k);</span><br><span class="line">              &#125;</span><br><span class="line">        System.out.println(<span class="string">"共"</span> + count + <span class="string">"个三位数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="企业发放的奖金根据利润提成。"><a href="#企业发放的奖金根据利润提成。" class="headerlink" title="企业发放的奖金根据利润提成。"></a>企业发放的奖金根据利润提成。</h2><p>利润(I)低于或等于10万元时，奖金可提10%；利润高于10万元，低于20万元时，低于10万元的部分按10%提成，高于10万元的部分，可提成7.5%；20万到40万之间时，高于20万元的部分，可提成5%；40万到60万之间时高于40万元的部分，可提成3%；60万到100万之间时，高于60万元的部分，可提成1.5%，高于100万元时，超过100万元的部分按1%提成，从键盘输入当月利润lirun，求应发放奖金总数sum？</p><p>1.程序分析：请利用数轴来分界，定位。注意定义时需把奖金定义成长整型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo12</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum;</span><br><span class="line">        System.out.println(<span class="string">"输入当月利润：(万元)"</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">double</span> lirun = in.nextDouble();</span><br><span class="line">        <span class="keyword">if</span> (lirun &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">            sum = lirun * <span class="number">0.1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lirun &lt;= <span class="number">20</span>) &#123;</span><br><span class="line">            sum = <span class="number">10</span>*<span class="number">0.1</span> + (lirun - <span class="number">10</span>) * <span class="number">0.075</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lirun &lt;= <span class="number">40</span>) &#123;</span><br><span class="line">            sum = <span class="number">10</span>*<span class="number">0.1</span> + <span class="number">10</span>*<span class="number">0.075</span> + (lirun - <span class="number">20</span>) * <span class="number">0.05</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lirun &lt;= <span class="number">60</span>) &#123;</span><br><span class="line">            sum = <span class="number">10</span>*<span class="number">0.1</span> + <span class="number">10</span>*<span class="number">0.075</span> + <span class="number">10</span>*<span class="number">0.05</span> + (lirun - <span class="number">40</span>) * <span class="number">0.03</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lirun &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">            sum = <span class="number">10</span>*<span class="number">0.1</span> + <span class="number">10</span>*<span class="number">0.075</span> + <span class="number">10</span>*<span class="number">0.05</span> + <span class="number">10</span>*<span class="number">0.03</span> + (lirun - <span class="number">60</span>) * <span class="number">0.015</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum = <span class="number">10</span>*<span class="number">0.1</span> + <span class="number">10</span>*<span class="number">0.075</span> + <span class="number">10</span>*<span class="number">0.05</span> + <span class="number">10</span>*<span class="number">0.03</span> + <span class="number">10</span>*<span class="number">0.015</span> + (lirun - <span class="number">100</span>) * <span class="number">0.01</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"应发的奖金是："</span>+sum+<span class="string">"(万元)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？"><a href="#一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？" class="headerlink" title="一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？"></a>一个整数，它加上100后是一个完全平方数，加上168又是一个完全平方数，请问该数是多少？</h2><p>1.程序分析：在10万以内判断，先将该数加上100后再开方，再将该数加上168后再开方，如果开方后的结果满足如下条件，即是结果。请看具体分析：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo13</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;<span class="number">100000</span>;x++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(Math.sqrt(x+<span class="number">100</span>)%<span class="number">1</span>==<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">if</span>(Math.sqrt(x+<span class="number">100</span>+<span class="number">168</span>)%<span class="number">1</span>==<span class="number">0</span>)</span><br><span class="line">            System.out.println(x+<span class="string">"加上100后是一个完全平方数，加上168又是一个完全平方数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="输入某年某月某日，判断这一天是这一年的第几天？"><a href="#输入某年某月某日，判断这一天是这一年的第几天？" class="headerlink" title="输入某年某月某日，判断这一天是这一年的第几天？"></a>输入某年某月某日，判断这一天是这一年的第几天？</h2><p>1.程序分析：以3月5日为例，应该先把前两个月的加起来，然后再加上5天即本月的第几天，特殊情况，闰年且输入月份大于3时需考虑多加一天。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo14</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请输入年,月,日："</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> year = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> month = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> day = in.nextInt();</span><br><span class="line">        Calendar cal = Calendar.getInstance();</span><br><span class="line">        cal.set(year, month - <span class="number">1</span>, day);</span><br><span class="line">        <span class="keyword">int</span> sum = cal.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">        System.out.println(<span class="string">"这一天是这一年的第"</span> + sum +<span class="string">"天"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo14</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> year,month,day,sum=<span class="number">0</span>;</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"输入年："</span>);</span><br><span class="line">        year=in.nextInt();</span><br><span class="line">        System.out.println(<span class="string">"输入月："</span>);</span><br><span class="line">        month=in.nextInt();</span><br><span class="line">        System.out.println(<span class="string">"输入日："</span>);</span><br><span class="line">        day=in.nextInt();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(month)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            sum=<span class="number">31</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            sum=<span class="number">59</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            sum=<span class="number">90</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            sum=<span class="number">120</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            sum=<span class="number">151</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            sum=<span class="number">181</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            sum=<span class="number">212</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            sum=<span class="number">243</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            sum=<span class="number">273</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">            sum=<span class="number">304</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">            sum=<span class="number">334</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">"wrong input!"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum=sum+day;</span><br><span class="line">        <span class="keyword">boolean</span> leap;</span><br><span class="line">        <span class="keyword">if</span>(year%<span class="number">400</span>==<span class="number">0</span>||(year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>))&#123;</span><br><span class="line">            leap=<span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            leap=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leap&amp;&amp;month&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"It is the "</span>+sum+<span class="string">"th day."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo14</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请输入年 月 日："</span>);</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> year=in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> month=in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> day=in.nextInt();</span><br><span class="line">        System.out.println(<span class="string">"是该年的第"</span>+count(year,month,day)+<span class="string">"天"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> days=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;month;i++)&#123;</span><br><span class="line">            <span class="keyword">switch</span>(i)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">                days=<span class="number">31</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                days=<span class="number">30</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">if</span>(year%<span class="number">400</span>==<span class="number">0</span>||year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>)&#123;</span><br><span class="line">                    days=<span class="number">29</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    days=<span class="number">28</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum+=days;</span><br><span class="line">        &#125;</span><br><span class="line">        sum+=day;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="输入三个整数x-y-z，请把这三个数由小到大输出。"><a href="#输入三个整数x-y-z，请把这三个数由小到大输出。" class="headerlink" title="输入三个整数x,y,z，请把这三个数由小到大输出。"></a>输入三个整数x,y,z，请把这三个数由小到大输出。</h2><p>1.程序分析：我们想办法把最小的数放到x上，先将x与y进行比较，如果x&gt;y则将x与y的值进行交换，然后再用x与z进行比较，如果x&gt;z则将x与z的值进行交换，这样能使x最小。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo15</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"请输入三个数:"</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            arr[i] = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x &gt; y) &#123; <span class="keyword">int</span> t = x; x = y; y = t; &#125; <span class="keyword">if</span>(x &gt; z) &#123; <span class="keyword">int</span> t = x; x = z; z = t; &#125; <span class="keyword">if</span>(y &gt; z) &#123; <span class="keyword">int</span> t = y; y = z; z = t; &#125;</span><br></pre></td></tr></table></figure></p><h2 id="输出9-9口诀乘法表。"><a href="#输出9-9口诀乘法表。" class="headerlink" title="输出9*9口诀乘法表。"></a>输出9*9口诀乘法表。</h2><p>1.程序分析：分行与列考虑，共9行9列，i控制行，j控制列。<br>出现重复的乘积（全矩形）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo16</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">                System.out.print(i + <span class="string">"*"</span> + j + <span class="string">"="</span> + (i*j) + <span class="string">"\\t"</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不现重复的乘积(下三角)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo16</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)</span><br><span class="line">                System.out.print(i + <span class="string">"*"</span> + j + <span class="string">"="</span> + (i*j) + <span class="string">"\\t"</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="猴子吃桃问题"><a href="#猴子吃桃问题" class="headerlink" title="猴子吃桃问题"></a>猴子吃桃问题</h2><p>猴子第一天摘下若干个桃子，当即吃了一半，还不瘾，又多吃了一个第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第10天早上想再吃时，见只剩下一个桃子了。求第一天共摘了多少。<br>1.程序分析：采取逆向思维的方法，从后往前推断。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo17</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">            sum = (sum + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"第一天共摘"</span>+sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="乒乓球比赛"><a href="#乒乓球比赛" class="headerlink" title="乒乓球比赛"></a>乒乓球比赛</h2><p>两个乒乓球队进行比赛，各出三人。甲队为a,b,c三人，乙队为x,y,z三人。已抽签决定比赛名单。有人向队员打听比赛的名单。a说他不和x比，c说他不和x,z比，请编程序找出三队赛手的名单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo18</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span>[] m = &#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span> &#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span>[] n = &#123; <span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span> &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m[i] == <span class="string">'a'</span> &amp;&amp; n[j] == <span class="string">'x'</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (m[i] == <span class="string">'a'</span> &amp;&amp; n[j] == <span class="string">'y'</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((m[i] == <span class="string">'c'</span> &amp;&amp; n[j] == <span class="string">'x'</span>)</span><br><span class="line">                        || (m[i] == <span class="string">'c'</span> &amp;&amp; n[j] == <span class="string">'z'</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((m[i] == <span class="string">'b'</span> &amp;&amp; n[j] == <span class="string">'z'</span>)</span><br><span class="line">                        || (m[i] == <span class="string">'b'</span> &amp;&amp; n[j] == <span class="string">'y'</span>)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span></span><br><span class="line">                    System.out.println(m[i] + <span class="string">" vs "</span> + n[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo18</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String a, b, c;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo18</span><span class="params">(String a, String b, String c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo18 arr_a = <span class="keyword">new</span> Demo18(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>);</span><br><span class="line">        String[] b = &#123; <span class="string">"x"</span>, <span class="string">"y"</span>, <span class="string">"z"</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">                 Demo18 arr_b = <span class="keyword">new</span> Demo18(b[i], b[j], b[k]);</span><br><span class="line">                    <span class="keyword">if</span> (!arr_b.a.equals(arr_b.b) &amp; !arr_b.b.equals(arr_b.c)</span><br><span class="line">                            &amp; !arr_b.c.equals(arr_b.a) &amp; !arr_b.a.equals(<span class="string">"x"</span>)</span><br><span class="line">                            &amp; !arr_b.c.equals(<span class="string">"x"</span>) &amp; !arr_b.c.equals(<span class="string">"z"</span>)) &#123;</span><br><span class="line">                        System.out.println(arr_a.a + <span class="string">"--"</span> + arr_b.a);</span><br><span class="line">                        System.out.println(arr_a.b + <span class="string">"--"</span> + arr_b.b);</span><br><span class="line">                        System.out.println(arr_a.c + <span class="string">"--"</span> + arr_b.c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="打印出如下图案（三角形-菱形）"><a href="#打印出如下图案（三角形-菱形）" class="headerlink" title="打印出如下图案（三角形\菱形）"></a>打印出如下图案（三角形\菱形）</h2><p>1.程序分析：先把图形分成两部分来看待，前四行一个规律，后三行一个规律，利用双重for循环，第一层控制行，第二层控制列。</p><p><strong>三角形：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">***</span><br><span class="line">******</span><br><span class="line">********</span><br><span class="line">******</span><br><span class="line">***</span><br><span class="line">*</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo19</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * i - <span class="number">1</span>; j++)</span><br><span class="line">                System.out.print(<span class="string">"*"</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">3</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> ( j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * i - <span class="number">1</span>; j++)</span><br><span class="line">                System.out.print(<span class="string">"*"</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>菱形：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">   *</span><br><span class="line">  ***</span><br><span class="line"> *****</span><br><span class="line">*******</span><br><span class="line"> *****</span><br><span class="line">  ***</span><br><span class="line">   *</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo19</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">4</span> - i; k++)</span><br><span class="line">                System.out.print( <span class="string">" "</span> );</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * i - <span class="number">1</span>; j++)</span><br><span class="line">                System.out.print(<span class="string">"*"</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">4</span> - i; k++)</span><br><span class="line">                System.out.print( <span class="string">" "</span> );</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= <span class="number">2</span> * i - <span class="number">1</span>; j++)</span><br><span class="line">                System.out.print(<span class="string">"*"</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有一分数序列：2-1，3-2，5-3，8-5，13-8，21-13…求出这个数列的前20项之和。"><a href="#有一分数序列：2-1，3-2，5-3，8-5，13-8，21-13…求出这个数列的前20项之和。" class="headerlink" title="有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13…求出这个数列的前20项之和。"></a>有一分数序列：2/1，3/2，5/3，8/5，13/8，21/13…求出这个数列的前20项之和。</h2><p>1.程序分析：请抓住分子与分母的变化规律。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo20</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> fm = <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">float</span> fz = <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">float</span> temp;</span><br><span class="line">        <span class="keyword">float</span> sum = <span class="number">0f</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            temp = fm;</span><br><span class="line">            fm = fz;</span><br><span class="line">            fz = fz + temp;</span><br><span class="line">            System.out.println((<span class="keyword">int</span>) fz + <span class="string">"/"</span> + (<span class="keyword">int</span>) fm);</span><br><span class="line">            sum += fz / fm;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求1-2-3-…-20-的和"><a href="#求1-2-3-…-20-的和" class="headerlink" title="求1+2!+3!+…+20!的和"></a>求1+2!+3!+…+20!的和</h2><p>1.程序分析：此程序只是把累加变成了累乘。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo21</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> fac = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            fac = fac * i;</span><br><span class="line">            sum += fac;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用递归方法求5"><a href="#利用递归方法求5" class="headerlink" title="利用递归方法求5!"></a>利用递归方法求5!</h2><p>1.程序分析：递归公式：f(n)=f(n-1)*4!<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo22</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">            value = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            value = n * fac(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请输入一个数："</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">        System.out.println(n + <span class="string">"的阶乘为："</span> + fac(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="计算年龄"><a href="#计算年龄" class="headerlink" title="计算年龄"></a>计算年龄</h2><p>有5个人坐在一起，问第五个人多少岁？他说比第4个人大2岁。问第4个人岁数，他说比第3个人大2岁。问第三个人，又说比第2人大两岁。问第2个人，说比第一个人大两岁。最后问第一个人，他说是10岁。请问第五个人多大？</p><p>1.程序分析：利用递归的方法，递归分为回推和递推两个阶段。要想知道第五个人岁数，需知道第四人的岁数，依次类推，推到第一人（10岁），再往回推。</p><p>直接求解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo23</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            n = n + <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"第五个人"</span> + n + <span class="string">"岁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归求解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo23</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> + getAge(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"第五个的年龄为"</span> + getAge(<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。"><a href="#给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。" class="headerlink" title="给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。"></a>给一个不多于5位的正整数，要求：一、求它是几位数，二、逆序打印出各位数字。</h2><p>本题原方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo24</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Demo24 use = <span class="keyword">new</span> Demo24();</span><br><span class="line">        System.out.println(<span class="string">"请输入："</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">long</span> a = in.nextLong();</span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= <span class="number">100000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Error Input, please run this program Again!"</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a &gt;= <span class="number">0</span> &amp;&amp; a &lt;= <span class="number">9</span>) &#123;</span><br><span class="line">            System.out.println(a + <span class="string">"是一位数"</span>);</span><br><span class="line">            System.out.println(<span class="string">"按逆序输出是:"</span>  + a);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt;= <span class="number">10</span> &amp;&amp; a &lt;= <span class="number">99</span>) &#123;</span><br><span class="line">            System.out.println(a + <span class="string">"是二位数"</span>);</span><br><span class="line">            System.out.println(<span class="string">"按逆序输出是:"</span>);</span><br><span class="line">            use.converse(a);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt;= <span class="number">100</span> &amp;&amp; a &lt;= <span class="number">999</span>) &#123;</span><br><span class="line">            System.out.println(a + <span class="string">"是三位数"</span>);</span><br><span class="line">            System.out.println(<span class="string">"按逆序输出是:"</span>);</span><br><span class="line">            use.converse(a);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt;= <span class="number">1000</span> &amp;&amp; a &lt;= <span class="number">9999</span>) &#123;</span><br><span class="line">            System.out.println(a + <span class="string">"是四位数"</span>);</span><br><span class="line">            System.out.println(<span class="string">"按逆序输出是:"</span>);</span><br><span class="line">            use.converse(a);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &gt;= <span class="number">10000</span> &amp;&amp; a &lt;= <span class="number">99999</span>) &#123;</span><br><span class="line">            System.out.println(a + <span class="string">"是五位数"</span>);</span><br><span class="line">            System.out.println(<span class="string">"按逆序输出是:"</span>);</span><br><span class="line">            use.converse(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">converse</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">        String s = Long.toString(l);</span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = ch.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.print(ch[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人版方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo24</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请输入："</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = in.next();</span><br><span class="line">        <span class="keyword">if</span> (str.matches(<span class="string">"\\\\d+"</span>)) &#123; <span class="comment">//正则表达式</span></span><br><span class="line">            System.out.println(<span class="string">"输入的是"</span> + str.length() + <span class="string">"位数"</span>);</span><br><span class="line">            StringBuffer buf = <span class="keyword">new</span> StringBuffer(str);</span><br><span class="line">            System.out.println(buf.reverse());<span class="comment">//字符串反转</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。"><a href="#一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。" class="headerlink" title="一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。"></a>一个5位数，判断它是不是回文数。即12321是回文数，个位与万位相同，十位与千位相同。</h2><p>原方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Palindrom</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> is = <span class="keyword">false</span>;</span><br><span class="line">        System.out.println(<span class="string">"Please input："</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">long</span> l = in.nextLong();</span><br><span class="line">        <span class="keyword">if</span> (l &gt; <span class="number">99999</span> || l &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Input error, please input again!"</span>);</span><br><span class="line">            l = in.nextLong();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">4</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            a[i] = (<span class="keyword">int</span>) (l / (<span class="keyword">long</span>) Math.pow(<span class="number">10</span>, i));</span><br><span class="line">            l = (l % (<span class="keyword">long</span>) Math.pow(<span class="number">10</span>, i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++, j++) &#123;</span><br><span class="line">            b[j] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">4</span>; i &lt; <span class="number">5</span>; i++, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] != b[j]) &#123;</span><br><span class="line">                is = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                is = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is == <span class="keyword">false</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"is not a Palindrom!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (is == <span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"is a Palindrom!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人版：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Palindrom</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请输入："</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String str = in.next();</span><br><span class="line">        <span class="keyword">int</span> l = Integer.parseInt(str);<span class="comment">//转换成整数</span></span><br><span class="line">        <span class="keyword">if</span> (l &lt; <span class="number">10000</span> || l &gt; <span class="number">99999</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"输入错误！"</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> is=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;ch.length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch[i]!=ch[ch.length-i-<span class="number">1</span>])&#123;</span><br><span class="line">                is=<span class="keyword">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                is=<span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is)&#123;</span><br><span class="line">            System.out.println(<span class="string">"这是一个回文!"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"不是一个回文!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。"><a href="#请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。" class="headerlink" title="请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。"></a>请输入星期几的第一个字母来判断一下是星期几，如果第一个字母一样，则继续判断第二个字母。</h2><p>1.程序分析：用情况语句比较好，如果第一个字母一样，则判断用情况语句或if语句判断第二个字母。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo26</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> weekSecond;<span class="comment">//保存第二字母</span></span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);<span class="comment">//接收用户输入</span></span><br><span class="line">        System.out.println(<span class="string">"请输入星期的第一个字母："</span>);</span><br><span class="line">        String letter = in.next();</span><br><span class="line">        <span class="keyword">if</span> (letter.length() == <span class="number">1</span>) &#123;<span class="comment">//判断用户控制台输入字符串长度是否是一个字母</span></span><br><span class="line">            <span class="keyword">char</span> weekFirst = letter.charAt(<span class="number">0</span>);<span class="comment">//取第一个字符</span></span><br><span class="line">            <span class="keyword">switch</span> (weekFirst) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'m'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'M'</span>:</span><br><span class="line">                System.out.println(<span class="string">"星期一(Monday)"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'t'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'T'</span>:</span><br><span class="line">                System.out.print(<span class="string">"由于星期二(Tuesday)与星期四(Thursday)均以字母T开头，故需输入第二个字母才能正确判断："</span>);</span><br><span class="line">                letter = in.next();</span><br><span class="line">                <span class="keyword">if</span> (letter.length() == <span class="number">1</span>) &#123;</span><br><span class="line">                    weekSecond = letter.charAt(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (weekSecond == <span class="string">'U'</span> || weekSecond == <span class="string">'u'</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"星期二(Tuesday)"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (weekSecond == <span class="string">'H'</span> || weekSecond == <span class="string">'h'</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"星期四(Thursday)"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Error!"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"输入错误，只能输入一个字母，程序结束！"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'w'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'W'</span>:</span><br><span class="line">                System.out.println(<span class="string">"星期三(Wednesday)"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'f'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'F'</span>:</span><br><span class="line">                System.out.println(<span class="string">"星期五(Friday)"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'S'</span>:</span><br><span class="line">                System.out.print(<span class="string">"由于星期六(Saturday)与星期日(Sunday)均以字母S开头，故需输入第二个字母才能正确判断："</span>);</span><br><span class="line">                letter = in.next();</span><br><span class="line">                <span class="keyword">if</span> (letter.length() == <span class="number">1</span>) &#123;</span><br><span class="line">                    weekSecond = letter.charAt(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (weekSecond == <span class="string">'A'</span> || weekSecond == <span class="string">'a'</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"星期六(Saturday)"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (weekSecond == <span class="string">'U'</span> || weekSecond == <span class="string">'u'</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"星期日(Sunday)"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Error!"</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"输入错误，只能输入一个字母，程序结束！"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">"输入错误，不能识别的星期值第一个字母，程序结束！"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"输入错误，只能输入一个字母，程序结束！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求100之内的素数"><a href="#求100之内的素数" class="headerlink" title="求100之内的素数"></a>求100之内的素数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo27</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum, i;</span><br><span class="line">        <span class="keyword">for</span> (sum = <span class="number">2</span>; sum &lt;= <span class="number">100</span>; sum++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= sum / <span class="number">2</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sum % i == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; sum / <span class="number">2</span>)</span><br><span class="line">                System.out.println(sum + <span class="string">"是素数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo27</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> w=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;i;j++)&#123;</span><br><span class="line">                w=i%j;</span><br><span class="line">                <span class="keyword">if</span>(w==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(w!=<span class="number">0</span>)</span><br><span class="line">                System.out.println(i+<span class="string">"是素数"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对10个数进行排序。"><a href="#对10个数进行排序。" class="headerlink" title="对10个数进行排序。"></a>对10个数进行排序。</h2><p>1.程序分析：可以利用选择法，即从后9个比较过程中，选择一个最小的与第一个元素交换，下次类推，即用第二个元素与后8个进行比较，并进行交换。<br>本例代码为生成随机10个数排序，并输入1个数，插入重排序输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo28</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">11</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            arr[i] = r.nextInt(<span class="number">100</span>) + <span class="number">1</span>; <span class="comment">//得到10个100以内的整数</span></span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] +<span class="string">"\\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"\nPlease Input a int number:"</span> );</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        arr[<span class="number">10</span>] = in.nextInt();</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] +<span class="string">"\\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>个人代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo28</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请输入10个数："</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            arr[i] = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"原数组为："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x : arr) &#123;<span class="comment">//foreach遍历</span></span><br><span class="line">            System.out.print( x + <span class="string">"\\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">"排序后为："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            System.out.print(arr[i] + <span class="string">"\\t"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求一个3-3矩阵主对角线元素之和"><a href="#求一个3-3矩阵主对角线元素之和" class="headerlink" title="求一个3*3矩阵主对角线元素之和"></a>求一个3*3矩阵主对角线元素之和</h2><p>1.程序分析：利用双重for循环控制输入二维数组，再将a[i][i]累加后输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo29</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> array[][] = &#123; &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;, &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;, &#123; <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span> &#125; &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == j)</span><br><span class="line">                    sum = sum + array[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主负对角线：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">         <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n;j++)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) sum1+=a[i][j];</span><br><span class="line">            <span class="keyword">if</span>(i+j==n-<span class="number">1</span>) sum2+=a[i][j];</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>##有一个已经排好序的数组。现输入一个数，要求按原来的规律将它插入数组中。</p><p>1.程序分析：首先判断此数是否大于最后一个数，然后再考虑插入中间的数的情况，插入后此元素之后的数，依次后移一个位置。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo30</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">12</span>];</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">            arr[i] = r.nextInt(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">10</span>; i++)</span><br><span class="line">            System.out.print(arr[i] + <span class="string">"\\t"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= <span class="number">10</span>; k++)</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; arr[k]) &#123;</span><br><span class="line">                    temp = arr[i];</span><br><span class="line">                    arr[i] = arr[k];</span><br><span class="line">                    arr[k] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">10</span>; k++)</span><br><span class="line">            System.out.print(arr[k] + <span class="string">"\\t"</span>);</span><br><span class="line">        arr[<span class="number">11</span>] = r.nextInt(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">10</span>; k++)</span><br><span class="line">            <span class="keyword">if</span> (arr[k] &gt; arr[<span class="number">11</span>]) &#123;</span><br><span class="line">                temp = arr[<span class="number">11</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">11</span>; j &gt;= k + <span class="number">1</span>; j--)</span><br><span class="line">                    arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                    arr[k] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= <span class="number">11</span>; k++)</span><br><span class="line">            System.out.print(arr[k] + <span class="string">"\\t"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="将一个数组逆序输出"><a href="#将一个数组逆序输出" class="headerlink" title="将一个数组逆序输出"></a>将一个数组逆序输出</h2><p>程序分析：用第一个与最后一个交换。</p><p>用逆序循环控制变量输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo31</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = a.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="取一个整数a从右端开始的第4～7位数字。"><a href="#取一个整数a从右端开始的第4～7位数字。" class="headerlink" title="取一个整数a从右端开始的第4～7位数字。"></a>取一个整数a从右端开始的第4～7位数字。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo32</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">"请输入一个7位以上的正整数："</span>);</span><br><span class="line">        <span class="keyword">long</span> l = in.nextLong();</span><br><span class="line">        String str = Long.toString(l);</span><br><span class="line">        <span class="keyword">char</span>[] ch = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> j=ch.length;</span><br><span class="line">        <span class="keyword">if</span> (j&lt;<span class="number">7</span>)&#123;System.out.println(<span class="string">"输入错误！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"截取从右端开始的4～7位是："</span>+ch[j-<span class="number">7</span>]+ch[j-<span class="number">6</span>]+ch[j-<span class="number">5</span>]+ch[j-<span class="number">4</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo32</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">long</span> b = s.nextLong();</span><br><span class="line">        a = (<span class="keyword">int</span>) (b % <span class="number">10000000</span> / <span class="number">1000</span>);</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="打印出杨辉三角形（要求打印出10行如下图）"><a href="#打印出杨辉三角形（要求打印出10行如下图）" class="headerlink" title="打印出杨辉三角形（要求打印出10行如下图）"></a>打印出杨辉三角形（要求打印出10行如下图）</h2><p>1.程序分析：<br>1<br>1   1<br>1   2   1<br>1   3   3   1<br>1   4   6   4   1<br>1   5   10  10  5   1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo33</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, j;</span><br><span class="line">        <span class="keyword">int</span> a[][];</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            a[i][i] = <span class="number">1</span>;</span><br><span class="line">            a[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                a[i][j] = a[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                System.out.printf(a[i][j] + <span class="string">"\\t"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输入3个数a-b-c，按大小顺序输出。"><a href="#输入3个数a-b-c，按大小顺序输出。" class="headerlink" title="输入3个数a,b,c，按大小顺序输出。"></a>输入3个数a,b,c，按大小顺序输出。</h2><p>（也可互相比较交换排序）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo34</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arrays = &#123; <span class="number">800</span>, <span class="number">56</span>, <span class="number">500</span> &#125;;</span><br><span class="line">        Arrays.sort(arrays);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; arrays.length; n++)</span><br><span class="line">            System.out.println(arrays[n]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(x &gt; y) &#123; <span class="keyword">int</span> t = x; x = y; y = t; &#125; <span class="keyword">if</span>(x &gt; z) &#123; <span class="keyword">int</span> t = x; x = z; z = t; &#125; <span class="keyword">if</span>(y &gt; z) &#123; <span class="keyword">int</span> t = y; y = z; z = t; &#125;</span><br></pre></td></tr></table></figure><h2 id="输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。"><a href="#输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。" class="headerlink" title="输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。"></a>输入数组，最大的与第一个元素交换，最小的与最后一个元素交换，输出数组。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo35</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i, min=<span class="number">0</span>, max=<span class="number">0</span>, n, temp1, temp2;</span><br><span class="line">        <span class="keyword">int</span> a[];</span><br><span class="line">        System.out.println(<span class="string">"定义数组的长度:"</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = in.nextInt();</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">"输入第"</span> + (i + <span class="number">1</span>) + <span class="string">"个数据:"</span>);</span><br><span class="line">            a[i] = in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &gt; a[max])</span><br><span class="line">                max = i;</span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt; a[min])</span><br><span class="line">                min = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp1 = a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>] = a[max];</span><br><span class="line">        a[max] = temp1;</span><br><span class="line"></span><br><span class="line">        temp2 = a[min];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (min != <span class="number">0</span>) &#123; <span class="comment">// 如果最小值不是a[0]，执行下面</span></span><br><span class="line">            a[min] = a[n - <span class="number">1</span>];</span><br><span class="line">            a[n - <span class="number">1</span>] = temp2;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;  <span class="comment">//如果最小值是a[0],执行下面</span></span><br><span class="line">            a[max] = a[n - <span class="number">1</span>];</span><br><span class="line">            a[n - <span class="number">1</span>] = temp1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">" "</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数"><a href="#有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数" class="headerlink" title="有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数"></a>有n个整数，使其前面各数顺序向后移m个位置，最后m个数变成最前面的m个数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo36</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"输入数字个数n："</span>);</span><br><span class="line">        <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">        System.out.println(<span class="string">"输入后移位数m："</span>);</span><br><span class="line">        <span class="keyword">int</span> m = in.nextInt();</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入第"</span>+(i+<span class="number">1</span>)+<span class="string">"个数:"</span>);</span><br><span class="line">            list.add(in.nextInt());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"原数据排序为："</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t : list) &#123;</span><br><span class="line">            System.out.print(t + <span class="string">" "</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        List&lt;Integer&gt; temp1 = list.subList(list.size() - m, list.size());</span><br><span class="line">        List&lt;Integer&gt; temp2 = list.subList(<span class="number">0</span>, list.size() - m);</span><br><span class="line">        temp2.addAll(<span class="number">0</span>, temp1);</span><br><span class="line">        System.out.println(<span class="string">"移动后排序为;"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t : temp2) &#123;</span><br><span class="line">            System.out.print(t + <span class="string">" "</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo36</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请定义数组的长度："</span>);</span><br><span class="line">        <span class="keyword">int</span> n=in.nextInt();</span><br><span class="line">        System.out.println(<span class="string">"请输入移动的位数："</span>);</span><br><span class="line">        <span class="keyword">int</span> m=in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> [] arr=<span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line">        <span class="keyword">int</span> [] brr=<span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入第"</span>+(i+<span class="number">1</span>)+<span class="string">"个数："</span>);</span><br><span class="line">            arr[i]=in.nextInt();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"排序前："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            System.out.print(arr[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            brr[i]=arr[n-m+i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n-m;i++)&#123;</span><br><span class="line">            arr[m+i]=arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            arr[i]=brr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"排序后："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            System.out.print(arr[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>##有n个人围成一圈，顺序排号。从第一个人开始报数（从1到3报数），凡报到3的人退出圈子，问最后留下的是原来第几号的那位。</p><p>（约瑟夫环问题，百度百科有时间复杂度最简单的数学方法）</p><p>原例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo37</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请输人数n："</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">        <span class="keyword">boolean</span>[] arr = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">true</span>; <span class="comment">//下标为TRUE时说明还在圈里</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftCount = n;</span><br><span class="line">        <span class="keyword">int</span> countNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (leftCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[index] == <span class="keyword">true</span>) &#123; <span class="comment">//当在圈里时</span></span><br><span class="line">                countNum++;  <span class="comment">//报数递加</span></span><br><span class="line">                <span class="keyword">if</span> (countNum == <span class="number">3</span>) &#123; <span class="comment">//报数为3时</span></span><br><span class="line">                    countNum = <span class="number">0</span>; <span class="comment">//从零开始继续报数</span></span><br><span class="line">                    arr[index] = <span class="keyword">false</span>; <span class="comment">//此人退出圈子</span></span><br><span class="line">                    leftCount--; <span class="comment">//剩余人数减一</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            index++; <span class="comment">//每报一次数，下标加一</span></span><br><span class="line">            <span class="keyword">if</span> (index == n) &#123; <span class="comment">//是循环数数，当下标大于n时，说明已经数了一圈，</span></span><br><span class="line">                index = <span class="number">0</span>; <span class="comment">//将下标设为零重新开始。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>个人代码1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo37</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请输入人数："</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[in.nextInt()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = a.length;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] == <span class="number">1</span>) &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">3</span>) &#123;</span><br><span class="line">                a[j] = <span class="number">0</span>;</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">            <span class="keyword">if</span> (j == a.length) &#123;</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"最后留下的人是"</span>+ (i + <span class="number">1</span>) + <span class="string">"号"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人代码2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo37</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Integer&gt; l = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        System.out.println(<span class="string">"请输入人数："</span>);</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> len = in.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            l.add(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; sum != len - <span class="number">1</span>;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l.get(i) != <span class="number">0</span>) &#123;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp == <span class="number">3</span>) &#123;</span><br><span class="line">                l.remove(i);</span><br><span class="line">                l.add(i, <span class="number">0</span>);</span><br><span class="line">                temp = <span class="number">0</span>;</span><br><span class="line">                sum++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i == l.size()) &#123;</span><br><span class="line">                i = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> t : l) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"最后留下的人是"</span> + t + <span class="string">"号"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。"><a href="#写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。" class="headerlink" title="写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。"></a>写一个函数，求一个字符串的长度，在main函数中输入字符串，并输出其长度。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo38</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入一个字符串："</span>);</span><br><span class="line">        String mys = in.next();</span><br><span class="line">        System.out.println(str_len(mys));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">str_len</span><span class="params">(String x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo38</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入一个字符串："</span>);</span><br><span class="line">        String mys = in.next();</span><br><span class="line">        System.out.println(mys.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写一个函数，输入n为偶数时，调用函数求1-2-1-4-…-1-n-当输入n为奇数时，调用函数1-1-1-3-…-1-n"><a href="#编写一个函数，输入n为偶数时，调用函数求1-2-1-4-…-1-n-当输入n为奇数时，调用函数1-1-1-3-…-1-n" class="headerlink" title="编写一个函数，输入n为偶数时，调用函数求1/2+1/4+…+1/n,当输入n为奇数时，调用函数1/1+1/3+…+1/n"></a>编写一个函数，输入n为偶数时，调用函数求1/2+1/4+…+1/n,当输入n为奇数时，调用函数1/1+1/3+…+1/n</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo39</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ouShu</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i = i + <span class="number">2</span>) &#123;</span><br><span class="line">            result +=  <span class="number">1</span> / (<span class="keyword">double</span>) i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">jiShu</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i = i + <span class="number">2</span>) &#123;</span><br><span class="line">            result += <span class="number">1</span> / (<span class="keyword">double</span>) i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"输入n的值："</span>);</span><br><span class="line">        <span class="keyword">int</span> n = in.nextInt();</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">//偶数，1/2+1/4+...+1/n</span></span><br><span class="line">            System.out.println(ouShu(n));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//奇数，1/1+1/3+...+1/n</span></span><br><span class="line">            System.out.println(jiShu(n));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符串排序"><a href="#字符串排序" class="headerlink" title="字符串排序"></a>字符串排序</h2><p>（利用容器类中的sort方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo40</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        list.add(<span class="string">"010102"</span>);</span><br><span class="line">        list.add(<span class="string">"010003"</span>);</span><br><span class="line">        list.add(<span class="string">"010201"</span>);</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo40</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请定义字符串的个数："</span>);</span><br><span class="line">        <span class="keyword">int</span> n=in.nextInt();</span><br><span class="line">        String[] str=<span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">            System.out.println(<span class="string">"请输入第"</span>+(i+<span class="number">1</span>)+<span class="string">"字符串："</span>);</span><br><span class="line">            str[i]=in.next();</span><br><span class="line">        &#125;</span><br><span class="line">        strSort(n,str);</span><br><span class="line">        System.out.println(<span class="string">"字符串排序后："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">            System.out.print(str[i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">strSort</span><span class="params">(<span class="keyword">int</span> n,String[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(compare(arr[i], arr[j]) == <span class="keyword">false</span>) &#123;</span><br><span class="line">                    String temp = arr[i]; arr[i] = arr[j]; arr[j] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;s1.length() &amp;&amp; i&lt;s2.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i) &gt; s2.charAt(i)) &#123;</span><br><span class="line">                result = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(s1.charAt(i) &lt;s2.charAt(i)) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(s1.length() &lt; s2.length()) &#123;</span><br><span class="line">                    result = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    result = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="猴子分桃"><a href="#猴子分桃" class="headerlink" title="猴子分桃"></a>猴子分桃</h2><p>海滩上有一堆桃子，五只猴子来分。第一只猴子把这堆桃子平均分为五份，多了一个，这只猴子把多的一个扔入海中，拿走了一份。第二只猴子把剩下的桃子又平均分成五份，又多了一个，它同样把多的一个扔入海中，拿走了一份，第三、第四、第五只猴子都是这样做的，问海滩上原来最少有多少个桃子？</p><p>本题源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo41</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ts = <span class="number">0</span>;<span class="comment">// 桃子总数</span></span><br><span class="line">    <span class="keyword">int</span> fs = <span class="number">1</span>;<span class="comment">// 记录分的次数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> hs = <span class="number">5</span>;<span class="comment">// 猴子数</span></span><br><span class="line">    <span class="keyword">int</span> tsscope = <span class="number">5000</span>;<span class="comment">// 桃子数的取值范围，太大容易溢出。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">fT</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t == tsscope) &#123;</span><br><span class="line">            <span class="comment">// 当桃子数到了最大的取值范围时取消递归</span></span><br><span class="line">            System.out.println(<span class="string">"结束"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((t - <span class="number">1</span>) % hs == <span class="number">0</span> &amp;&amp; fs &lt;= hs) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fs == hs) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"桃子数="</span> + ts + <span class="string">"时满足分桃条件"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                fs += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> fT((t - <span class="number">1</span>) / <span class="number">5</span> * <span class="number">4</span>);<span class="comment">// 返回猴子拿走一份后的剩下的总数</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 没满足条件</span></span><br><span class="line">                fs = <span class="number">1</span>;<span class="comment">// 分的次数重置为1</span></span><br><span class="line">                <span class="keyword">return</span> fT(ts += <span class="number">1</span>);<span class="comment">// 桃子数加+1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Demo41().fT(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>个人修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo41</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">6</span>;; i++) &#123;<span class="comment">// 最少6个分最后一次</span></span><br><span class="line">            sum = i;<span class="comment">// 桃子数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++) &#123;<span class="comment">// 分的次数循环</span></span><br><span class="line">                <span class="keyword">if</span> ((sum - <span class="number">1</span>) % <span class="number">5</span> == <span class="number">0</span> &amp;&amp; j &lt; <span class="number">5</span>) &#123;<span class="comment">// 如果扔一个后能均分5份，继续分</span></span><br><span class="line">                    sum = (sum - <span class="number">1</span>) / <span class="number">5</span> * <span class="number">4</span>;<span class="comment">// 每分一次剩余桃子数</span></span><br><span class="line">                    <span class="keyword">if</span> (j == <span class="number">4</span>) &#123;<span class="comment">// 如果已分5次，且仍能除尽，输出，退出程序</span></span><br><span class="line">                        System.out.println(i);</span><br><span class="line">                        System.exit(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="809-800-9-1。其中-代表的两位数-8-的结果为两位数，9-的结果为3位数。求-代表的两位数，及809-后的结果。"><a href="#809-800-9-1。其中-代表的两位数-8-的结果为两位数，9-的结果为3位数。求-代表的两位数，及809-后的结果。" class="headerlink" title="809??=800??+9??+1。其中??代表的两位数,8??的结果为两位数，9??的结果为3位数。求??代表的两位数，及809??后的结果。"></a>809<em>??=800</em>??+9<em>??+1。其中??代表的两位数,8</em>??的结果为两位数，9<em>??的结果为3位数。求??代表的两位数，及809</em>??后的结果。</h2><p>（本题为无解，去掉1有解）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo42</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">809</span> * i == (<span class="number">800</span> * i + <span class="number">9</span> * i + <span class="number">1</span>) &amp;&amp; <span class="number">8</span> * i &gt;= <span class="number">10</span> &amp;&amp; <span class="number">8</span> * i &lt; <span class="number">100</span></span><br><span class="line">                    &amp;&amp; <span class="number">9</span> * i &gt;= <span class="number">100</span> &amp;&amp; <span class="number">9</span> * i &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"?? ="</span> + i);</span><br><span class="line">                System.out.println(<span class="string">"809*??="</span>+ <span class="number">809</span> * i);</span><br><span class="line">                System.exit(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="求0—7所能组成的奇数个数"><a href="#求0—7所能组成的奇数个数" class="headerlink" title="求0—7所能组成的奇数个数"></a>求0—7所能组成的奇数个数</h2><p>暴力算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo43</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isJiShu</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">fun</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'7'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000000</span>; i++) &#123;</span><br><span class="line">            s = <span class="string">""</span> + i;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">char</span>[] c = s.toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fun(c[j])) &#123;</span><br><span class="line">                    flag = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flag &amp;&amp; isJiShu(i)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            s = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"共"</span> + count + <span class="string">"个。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数学算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo43</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 因为是奇数，所以个位只能是1，3，5，7共4种，前面可随便排列</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">4</span>;<span class="comment">// 个位的4种</span></span><br><span class="line">        <span class="comment">// 2位时，十位有8种，个位4种，8×4</span></span><br><span class="line">        <span class="comment">// 3位时，8×8×4……</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            count = <span class="number">8</span> * count;</span><br><span class="line">            System.out.println(<span class="string">"count:"</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//组成1位数是4个。</span></span><br><span class="line"><span class="comment">//组成2位数是7*4个。</span></span><br><span class="line"><span class="comment">//组成3位数是7*8*4个。</span></span><br><span class="line"><span class="comment">//组成4位数是7*8*8*4个。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo43</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        System.out.println(<span class="string">"组成1位数是 "</span>+sum+<span class="string">" 个"</span>);</span><br><span class="line">        sum=sum*<span class="number">7</span>;</span><br><span class="line">        System.out.println(<span class="string">"组成2位数是 "</span>+sum+<span class="string">" 个"</span>);</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">3</span>;j&lt;=<span class="number">9</span>;j++)&#123;</span><br><span class="line">            sum=sum*<span class="number">8</span>;</span><br><span class="line">            System.out.println(<span class="string">"组成"</span>+j+<span class="string">"位数是 "</span>+sum+<span class="string">" 个"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="一个偶数总能表示为两个素数之和"><a href="#一个偶数总能表示为两个素数之和" class="headerlink" title="一个偶数总能表示为两个素数之和"></a>一个偶数总能表示为两个素数之和</h2><p>哥德巴赫猜想是想证明对任何大于6的自然数n之内的所有偶数可以表示为两个素数之和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo44</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSuShu</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span> || x == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Math.sqrt(x); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 求了下100以内的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i = i + <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= (i + <span class="number">1</span>) / <span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (isSuShu(j) &amp;&amp; isSuShu(i - j))&#123;</span><br><span class="line">                    System.out.println(i + <span class="string">"="</span> + j + <span class="string">"+"</span> + (i - j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo44</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">6</span>;i&lt;=<span class="number">100</span> ;i+=<span class="number">2</span> )&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;<span class="number">100</span> ;j++ )&#123;</span><br><span class="line">                <span class="keyword">if</span>(!isPrime(j)||!isPrime(i-j)||j&gt;=i)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">                System.out.println(i+<span class="string">"="</span>+j+<span class="string">"+"</span>+(i-j));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n ;i++ )&#123;</span><br><span class="line">            <span class="keyword">if</span>(n%i==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断几个9能被一个素数整除"><a href="#判断几个9能被一个素数整除" class="headerlink" title="判断几个9能被一个素数整除"></a>判断几个9能被一个素数整除</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo45</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSuShu</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>|| x == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Math.sqrt(x); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (x % i == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 长度100的素数数组</span></span><br><span class="line">        <span class="keyword">while</span> (n &lt; <span class="number">100</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSuShu(num)) &#123;</span><br><span class="line">                a[n] = num;</span><br><span class="line">                n++;</span><br><span class="line">                num++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* for (int t : a) &#123;</span></span><br><span class="line"><span class="comment">         System.out.println(t);</span></span><br><span class="line"><span class="comment">         &#125;*/</span></span><br><span class="line">        String s = <span class="string">"9"</span>;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s.length() &lt; <span class="number">9</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">new</span> Integer(s).intValue() % a[index] == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(s + <span class="string">"%"</span> + a[index] + <span class="string">"=0"</span>);</span><br><span class="line">                <span class="keyword">if</span> (index &lt; <span class="number">100</span> - <span class="number">1</span>) &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    index = <span class="number">0</span>;</span><br><span class="line">                    s = s + <span class="string">"9"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.exit(0);</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (index &lt; <span class="number">100</span> - <span class="number">1</span>) &#123;</span><br><span class="line">                    index++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    index = <span class="number">0</span>;</span><br><span class="line">                    s = s + <span class="string">"9"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断一个整数能被几个9整除。（原题：一个素数能被几个9整除）"><a href="#判断一个整数能被几个9整除。（原题：一个素数能被几个9整除）" class="headerlink" title="判断一个整数能被几个9整除。（原题：一个素数能被几个9整除）"></a>判断一个整数能被几个9整除。（原题：一个素数能被几个9整除）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo45</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">"请输入一个整数："</span>);</span><br><span class="line">        <span class="keyword">int</span> num = in.nextInt();</span><br><span class="line">        <span class="keyword">int</span> tmp = num;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; tmp%<span class="number">9</span> == <span class="number">0</span> ;)&#123;</span><br><span class="line">            tmp = tmp/<span class="number">9</span>;</span><br><span class="line">            count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(num+<span class="string">" 能够被 "</span>+count+<span class="string">" 个9 整除。"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个字符串连接程序"><a href="#两个字符串连接程序" class="headerlink" title="两个字符串连接程序"></a>两个字符串连接程序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo46</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"输入第一个字符串："</span>);</span><br><span class="line">        String s1 = in.next();</span><br><span class="line">        System.out.println(<span class="string">"输入第一个字符串："</span>);</span><br><span class="line">        String s2 = in.next();</span><br><span class="line">        System.out.println(<span class="string">"连接后：n"</span> + s1 + s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo46</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.print(<span class="string">"请输入一个字符串："</span>);</span><br><span class="line">        String str1 = in.nextLine();</span><br><span class="line">        System.out.print(<span class="string">"请再输入一个字符串："</span>);</span><br><span class="line">        String str2 = in.nextLine();</span><br><span class="line">        String str = str1+str2;</span><br><span class="line">        System.out.println(<span class="string">"连接后的字符串是："</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的-号"><a href="#读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的-号" class="headerlink" title="读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的*号"></a>读取7个数（1—50）的整数值，每读取一个值，程序打印出该值个数的*号</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo47</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">1</span>,num;</span><br><span class="line">        <span class="keyword">while</span>(n&lt;=<span class="number">7</span>)&#123;</span><br><span class="line">            <span class="keyword">do</span>&#123;</span><br><span class="line">                System.out.print(<span class="string">"请输入一个1--50 之间的整数："</span>);</span><br><span class="line">                num= s.nextInt();</span><br><span class="line">            &#125;<span class="keyword">while</span>(num&lt;<span class="number">1</span>||num&gt;<span class="number">50</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=num;i++)</span><br><span class="line">            &#123;System.out.print(<span class="string">"*"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">            n ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo47</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">"*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = in.nextInt();</span><br><span class="line">            print(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5，然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。"><a href="#某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5，然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。" class="headerlink" title="某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5，然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。"></a>某个公司采用公用电话传递数据，数据是四位的整数，在传递过程中是加密的，加密规则如下：每位数字都加上5，然后用和除以10的余数代替该数字，再将第一位和第四位交换，第二位和第三位交换。</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo48</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入一个4位数字："</span>);</span><br><span class="line">        String str = in.next();</span><br><span class="line">        <span class="keyword">if</span> (!((str).matches(<span class="string">"\\d&#123;4&#125;"</span>))) &#123;</span><br><span class="line">            System.out.println(<span class="string">"输入的不是4位数字！"</span>);</span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] c = str.toCharArray();</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            a[i] = ((<span class="keyword">int</span>) (c[i] - <span class="string">'0'</span>) + <span class="number">5</span>) % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        t = a[<span class="number">0</span>];</span><br><span class="line">        a[<span class="number">0</span>] = a[<span class="number">3</span>];</span><br><span class="line">        a[<span class="number">3</span>] = t;</span><br><span class="line">        t = a[<span class="number">1</span>];</span><br><span class="line">        a[<span class="number">1</span>] = a[<span class="number">2</span>];</span><br><span class="line">        a[<span class="number">2</span>] = t;</span><br><span class="line">        System.out.println(<span class="string">"结果是："</span> + a[<span class="number">0</span>] + a[<span class="number">1</span>] + a[<span class="number">2</span>] + a[<span class="number">3</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo48</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>,temp;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            System.out.print(<span class="string">"请输入一个4位正整数："</span>);</span><br><span class="line">            num = s.nextInt();</span><br><span class="line">        &#125;<span class="keyword">while</span> (num&lt;<span class="number">1000</span>||num&gt;<span class="number">9999</span>);</span><br><span class="line">        <span class="keyword">int</span> a[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        a[<span class="number">0</span>] = num/<span class="number">1000</span>; <span class="comment">//取千位的数字</span></span><br><span class="line">        a[<span class="number">1</span>] = (num/<span class="number">100</span>)%<span class="number">10</span>; <span class="comment">//取百位的数字</span></span><br><span class="line">        a[<span class="number">2</span>] = (num/<span class="number">10</span>)%<span class="number">10</span>; <span class="comment">//取十位的数字</span></span><br><span class="line">        a[<span class="number">3</span>] = num%<span class="number">10</span>; <span class="comment">//取个位的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++) &#123;</span><br><span class="line">            a[j]+=<span class="number">5</span>; a[j]%=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">1</span>;j++) &#123;</span><br><span class="line">            temp = a[j]; a[j] = a[<span class="number">3</span>-j]; a[<span class="number">3</span>-j] =temp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(<span class="string">"加密后的数字为："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;j++) System.out.print(a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计算字符串中子串出现的次数"><a href="#计算字符串中子串出现的次数" class="headerlink" title="计算字符串中子串出现的次数"></a>计算字符串中子串出现的次数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo49</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入主串："</span>);</span><br><span class="line">        String str1 = in.nextLine();</span><br><span class="line">        System.out.println(<span class="string">"请输入子串："</span>);</span><br><span class="line">        String str2 = in.nextLine();</span><br><span class="line">        <span class="comment">// 生成子串长度的N个字符串数组</span></span><br><span class="line">        String[] sa = <span class="keyword">new</span> String[str1.length() - str2.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sa.length; i++) &#123;</span><br><span class="line">            sa[i] = str1.substring(i, i + str2.length());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 子串与N个拆开的子串比对</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sa.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sa[i].equals(str2)) &#123;</span><br><span class="line">                <span class="comment">// 成功配对，计数器+1；</span></span><br><span class="line">                sum++;</span><br><span class="line">                <span class="comment">// 因为不计算重叠的子串，所以跳过配对之后的部分拆分子串</span></span><br><span class="line">                i = i + str2.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"主串中共包含"</span> + sum + <span class="string">"个字串"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，把原有的数据和计算出的平均分数存放在磁盘文"><a href="#有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，把原有的数据和计算出的平均分数存放在磁盘文" class="headerlink" title="有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，把原有的数据和计算出的平均分数存放在磁盘文"></a>有五个学生，每个学生有3门课的成绩，从键盘输入以上数据（包括学生号，姓名，三门课成绩），计算出平均成绩，把原有的数据和计算出的平均分数存放在磁盘文</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span>[] a = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getAve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a[<span class="number">0</span>] + a[<span class="number">1</span>] + a[<span class="number">2</span>]) / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(<span class="keyword">int</span> number, String name, <span class="keyword">double</span>[] a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"学号："</span> + <span class="keyword">this</span>.number + <span class="string">"\t姓名："</span> + <span class="keyword">this</span>.name + <span class="string">"\r\n各科成绩：\r\n"</span> + a[<span class="number">0</span>] + <span class="string">"\\t"</span> + a[<span class="number">1</span>] + <span class="string">"\\t"</span> + a[<span class="number">2</span>] + <span class="string">"\r\n平均成绩：\r\n"</span>+ <span class="keyword">this</span>.getAve();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo50</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">input</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Scanner s = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入学号："</span>);</span><br><span class="line">        <span class="keyword">int</span> num = s.nextInt();</span><br><span class="line">        System.out.println(<span class="string">"请输入姓名："</span>);</span><br><span class="line">        String name = s.next();</span><br><span class="line">        System.out.println(<span class="string">"请分别输入3门成绩："</span>);</span><br><span class="line">        <span class="keyword">double</span>[] a = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            a[i] = s.nextDouble();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Student(num, name, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Student[] st = <span class="keyword">new</span> Student[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; st.length; i++) &#123;</span><br><span class="line">            st[i] = input();</span><br><span class="line">        &#125;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">"d:"</span> + File.separator + <span class="string">"123.txt"</span>);</span><br><span class="line">        FileWriter output = <span class="keyword">new</span> FileWriter(f);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; st.length; i++) &#123;</span><br><span class="line">            output.write(st[i].toString() + <span class="string">"\r\n"</span>);</span><br><span class="line">            output.write(<span class="string">"\r\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        output.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;斐波那契数列&quot;&gt;&lt;a href=&quot;#斐波那契数列&quot; class=&quot;headerlink&quot; title=&quot;斐波那契数列&quot;&gt;&lt;/a&gt;斐波那契数列&lt;/h2&gt;&lt;p&gt;有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？&lt;/p&gt;
&lt;p&gt;1.程序分析：这个是典型的&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;斐波那契数列&lt;/a&gt;，兔子的规律为数列1,1,2,3,5,8,13,21….&lt;/p&gt;
&lt;p&gt;具体分析如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;f(1) = 1(第1个月有一对兔子）&lt;br&gt;f(2) = 1(第2个月还是一对兔子）&lt;br&gt;f(3) = 2(原来有一对兔子，第3个开始，每个月生一对兔子）&lt;br&gt;f(4) = 3(原来有两对兔子，有一对可以生育）&lt;br&gt;f(5) = 5(原来有3对兔子，第3个月出生的那对兔子也可以生育了，那么现在有两对兔子可以生育）&lt;br&gt;f(6) = 8(原来有5对兔子，第4个月出生的那对兔子也可以生育了，那么现在有3对兔子可以生育）&lt;br&gt;…………..&lt;br&gt;由以上可以看出，第n个月兔子的对数为&lt;br&gt;f(n) = f(n - 1) + f(n - 2);&lt;br&gt;f(n-1)是上个月的兔子数量，是原来有的。&lt;br&gt;f(n-2)是可以生育的兔子数，即多出来的数量。第n-2个月开始后的第3个月是第n个月，此时第n-2个月时的兔子都可以生育了&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Algorithms" scheme="http://blog.atecher.com/categories/Algorithms/"/>
    
    
      <category term="Algorithms" scheme="http://blog.atecher.com/tags/Algorithms/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java垃圾回收机制</title>
    <link href="http://blog.atecher.com/2018/04/03/Java-GC/"/>
    <id>http://blog.atecher.com/2018/04/03/Java-GC/</id>
    <published>2018-04-03T00:00:00.000Z</published>
    <updated>2022-01-28T10:28:39.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收机制的意义"><a href="#垃圾回收机制的意义" class="headerlink" title="垃圾回收机制的意义"></a>垃圾回收机制的意义</h1><p>Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。<strong>垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。</strong></p><blockquote><p>ps:内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为“对象游离”。</p></blockquote><a id="more"></a><h1 id="垃圾回收机制中的算法"><a href="#垃圾回收机制中的算法" class="headerlink" title="垃圾回收机制中的算法"></a>垃圾回收机制中的算法</h1><p>Java语言规范没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：（1）发现无用信息对象；（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。</p><h2 id="引用计数法-Reference-Counting-Collector"><a href="#引用计数法-Reference-Counting-Collector" class="headerlink" title="引用计数法(Reference Counting Collector)"></a>引用计数法(Reference Counting Collector)</h2><h3 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h3><p>引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p><strong>无法检测出循环引用</strong>。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0.</p><h3 id="引用计数算法无法解决循环引用问题，例如："><a href="#引用计数算法无法解决循环引用问题，例如：" class="headerlink" title="引用计数算法无法解决循环引用问题，例如："></a>引用计数算法无法解决循环引用问题，例如：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java学习交流QQ群：589809992 我们一起学Java！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyObject object1 = <span class="keyword">new</span> MyObject();</span><br><span class="line">        MyObject object2 = <span class="keyword">new</span> MyObject();</span><br><span class="line"></span><br><span class="line">        object1.object = object2;</span><br><span class="line">        object2.object = object1;</span><br><span class="line"></span><br><span class="line">        object1 = <span class="keyword">null</span>;</span><br><span class="line">        object2 = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后面两句将object1和object2赋值为null，也就是说object1和object2指向的对象已经不可能再被访问，但是由于它们互相引用对方，导致它们的引用计数器都不为0，那么垃圾收集器就永远不会回收它们。</p><h2 id="tracing算法-Tracing-Collector-或-标记-清除算法-mark-and-sweep"><a href="#tracing算法-Tracing-Collector-或-标记-清除算法-mark-and-sweep" class="headerlink" title="tracing算法(Tracing Collector) 或 标记-清除算法(mark and sweep)"></a>tracing算法(Tracing Collector) 或 标记-清除算法(mark and sweep)</h2><h3 id="根搜索算法"><a href="#根搜索算法" class="headerlink" title="根搜索算法"></a>根搜索算法</h3><p><img src="//qn.atecher.com/mts/20180403/3832083954451456" alt="Image-1"></p><p>根搜索算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点。</p><p>java中可作为GC Root的对象有:</p><ol><li>虚拟机栈中引用的对象（本地变量表）</li><li>方法区中静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中引用的对象（Native对象）</li></ol><h3 id="tracing算法的示意图"><a href="#tracing算法的示意图" class="headerlink" title="tracing算法的示意图"></a>tracing算法的示意图</h3><p>　　<img src="//qn.atecher.com/mts/20180403/3832084002276352" alt="Image-2"></p><h3 id="标记-清除算法分析"><a href="#标记-清除算法分析" class="headerlink" title="标记-清除算法分析"></a>标记-清除算法分析</h3><p>标记-清除算法采用从根集合进行扫描，对存活的对象对象标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如上图所示。标记-清除算法不需要进行对象的移动，并且仅对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p><h2 id="compacting算法-或-标记-整理算法"><a href="#compacting算法-或-标记-整理算法" class="headerlink" title="compacting算法 或 标记-整理算法"></a>compacting算法 或 标记-整理算法</h2><p><img src="//qn.atecher.com/mts/20180403/3832084008698880" alt="Image-3"></p><p>标记-整理算法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。在基于Compacting算法的收集器的实现中，一般增加句柄和句柄表。</p><h2 id="copying算法-Compacting-Collector"><a href="#copying算法-Compacting-Collector" class="headerlink" title="copying算法(Compacting Collector)"></a>copying算法(Compacting Collector)</h2><p>　　<img src="//qn.atecher.com/mts/20180403/3832084014646272" alt="Image-4"></p><p>该算法的提出是为了克服句柄的开销和解决堆碎片的垃圾回收。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。一种典型的基于coping算法的垃圾回收是stop-and-copy算法，它将堆分成对象面和空闲区域面，在对象面与空闲区域面的切换过程中，程序暂停执行。</p><h2 id="generation算法-Generational-Collector"><a href="#generation算法-Generational-Collector" class="headerlink" title="generation算法(Generational Collector)"></a>generation算法(Generational Collector)</h2><p><img src="//qn.atecher.com/mts/20180403/3832084020200448" alt="Image-5"></p><p>分代的垃圾回收策略，是基于这样一个事实：<strong>不同的对象的生命周期是不一样的</strong>。因此，不同生命周期的对象可以采取不同的回收算法，以便提高回收效率。</p><p><strong>年轻代（Young Generation）</strong></p><ol><li><p>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</p></li><li><p>新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</p></li><li><p>当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收</p></li><li><p>新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)</p></li></ol><p><strong>年老代（Old Generation）</strong></p><ol><li><p>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p></li><li><p>内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高。</p></li></ol><p><strong>持久代（Permanent Generation）</strong></p><p>用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。</p><h1 id="GC（垃圾收集器）"><a href="#GC（垃圾收集器）" class="headerlink" title="GC（垃圾收集器）"></a>GC（垃圾收集器）</h1><p>新生代收集器使用的收集器：Serial、PraNew、Parallel Scavenge<br>老年代收集器使用的收集器：Serial Old、Parallel Old、CMS</p><p><img src="//qn.atecher.com/mts/20180403/3832084025279488" alt="Image-6"></p><h2 id="Serial收集器（复制算法"><a href="#Serial收集器（复制算法" class="headerlink" title="Serial收集器（复制算法)"></a>Serial收集器（复制算法)</h2><p>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。</p><h2 id="Serial-Old收集器-标记-整理算法"><a href="#Serial-Old收集器-标记-整理算法" class="headerlink" title="Serial Old收集器(标记-整理算法)"></a>Serial Old收集器(标记-整理算法)</h2><p>老年代单线程收集器，Serial收集器的老年代版本。</p><h2 id="ParNew收集器-停止-复制算法"><a href="#ParNew收集器-停止-复制算法" class="headerlink" title="ParNew收集器(停止-复制算法)"></a>ParNew收集器(停止-复制算法)</h2><p>新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p><h2 id="Parallel-Scavenge收集器-停止-复制算法"><a href="#Parallel-Scavenge收集器-停止-复制算法" class="headerlink" title="Parallel Scavenge收集器(停止-复制算法)"></a>Parallel Scavenge收集器(停止-复制算法)</h2><p>并行收集器，追求高吞吐量，高效利用CPU。吞吐量一般为99%， 吞吐量= 用户线程时间/(用户线程时间+GC线程时间)。适合后台应用等对交互相应要求不高的场景。</p><h2 id="Parallel-Old收集器-停止-复制算法"><a href="#Parallel-Old收集器-停止-复制算法" class="headerlink" title="Parallel Old收集器(停止-复制算法)"></a>Parallel Old收集器(停止-复制算法)</h2><p>Parallel Scavenge收集器的老年代版本，并行收集器，吞吐量优先</p><h2 id="CMS-Concurrent-Mark-Sweep-收集器（标记-清理算法）"><a href="#CMS-Concurrent-Mark-Sweep-收集器（标记-清理算法）" class="headerlink" title="CMS(Concurrent Mark Sweep)收集器（标记-清理算法）"></a>CMS(Concurrent Mark Sweep)收集器（标记-清理算法）</h2><p>高并发、低停顿，追求最短GC回收停顿时间，cpu占用比较高，响应时间快，停顿时间短，多核cpu 追求高响应时间的选择</p><h1 id="GC的执行机制"><a href="#GC的执行机制" class="headerlink" title="GC的执行机制"></a>GC的执行机制</h1><p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。</p><h2 id="Scavenge-GC"><a href="#Scavenge-GC" class="headerlink" title="Scavenge GC"></a>Scavenge GC</h2><p>一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p><h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2><p>对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于FullGC的调节。有如下原因可能导致Full GC：</p><ol><li>年老代（Tenured）被写满</li><li>持久代（Perm）被写满</li><li>System.gc()被显示调用</li><li>上一次GC之后Heap的各域分配策略动态变化</li></ol><h1 id="Java有了GC同样会出现内存泄露问题"><a href="#Java有了GC同样会出现内存泄露问题" class="headerlink" title="Java有了GC同样会出现内存泄露问题"></a>Java有了GC同样会出现内存泄露问题</h1><ol><li>静态集合类像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放，因为他们也将一直被Vector等应用着。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Static Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i&lt;<span class="number">100</span>; i++)&#123;</span><br><span class="line">    Object o = <span class="keyword">new</span> Object();</span><br><span class="line">    v.add(o);</span><br><span class="line">    o = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，代码栈中存在Vector 对象的引用 v 和 Object 对象的引用 o 。在 For 循环中，我们不断的生成新的对象，然后将其添加到 Vector 对象中，之后将 o 引用置空。问题是当 o 引用被置空后，如果发生 GC，我们创建的 Object 对象是否能够被 GC 回收呢？答案是否定的。因为， GC 在跟踪代码栈中的引用时，会发现 v 引用，而继续往下跟踪，就会发现 v 引用指向的内存空间中又存在指向 Object 对象的引用。也就是说尽管o 引用已经被置空，但是 Object 对象仍然存在其他的引用，是可以被访问到的，所以 GC 无法将其释放掉。如果在此循环之后， Object 对象对程序已经没有任何作用，那么我们就认为此 Java 程序发生了内存泄漏。</p><ol><li><p>各种连接，数据库连接，网络连接，IO连接等没有显示调用close关闭，不被GC回收导致内存泄露。</p></li><li><p>监听器的使用，在释放对象的同时没有相应删除监听器的时候也可能导致内存泄露。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;垃圾回收机制的意义&quot;&gt;&lt;a href=&quot;#垃圾回收机制的意义&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收机制的意义&quot;&gt;&lt;/a&gt;垃圾回收机制的意义&lt;/h1&gt;&lt;p&gt;Java语言中一个显著的特点就是引入了垃圾回收机制，使c++程序员最头疼的内存管理的问题迎刃而解，它使得Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有“作用域”的概念，只有对象的引用才有“作用域”。&lt;strong&gt;垃圾回收可以有效的防止内存泄露，有效的使用空闲的内存。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ps:内存泄露是指该内存空间使用完毕之后未回收，在不涉及复杂数据结构的一般情况下，Java 的内存泄露表现为一个内存对象的生命周期超出了程序需要它的时间长度，我们有时也将其称为“对象游离”。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.atecher.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.atecher.com/tags/Java/"/>
    
      <category term="JMM" scheme="http://blog.atecher.com/tags/JMM/"/>
    
      <category term="GC" scheme="http://blog.atecher.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>聚集索引和非聚集索引</title>
    <link href="http://blog.atecher.com/2018/03/23/clustered-index-and-noncustered-index/"/>
    <id>http://blog.atecher.com/2018/03/23/clustered-index-and-noncustered-index/</id>
    <published>2018-03-23T11:33:10.000Z</published>
    <updated>2022-01-28T10:28:39.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="官方说法"><a href="#官方说法" class="headerlink" title="官方说法"></a>官方说法</h2><h3 id="聚集索引"><a href="#聚集索引" class="headerlink" title="聚集索引"></a>聚集索引</h3><p>一种索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。</p><p>聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。</p><p>聚集索引对于那些经常要搜索范围值的列特别有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。例如，如果应用程序执行 的一个查询经常检索某一日期范围内的记录，则使用聚集索引可以迅速找到包含开始日期的行，然后检索表中所有相邻的行，直到到达结束日期。这样有助于提高此 类查询的性能。同样，如果对从表中检索的数据进行排序时经常要用到某一列，则可以将该表在该列上聚集（物理排序），避免每次查询该列时都进行排序，从而节 省成本。</p><p>当索引值唯一时，使用聚集索引查找特定的行也很有效率。例如，使用唯一雇员 ID 列 emp_id 查找特定雇员的最快速的方法，是在 emp_id 列上创建聚集索引或 PRIMARY KEY 约束。</p><a id="more"></a><p><img src="//qn.atecher.com/mts/20180402/3831019975492608" alt="Image-2"></p><p>（聚集索引）</p><h3 id="非聚集索引"><a href="#非聚集索引" class="headerlink" title="非聚集索引"></a>非聚集索引</h3><p>一种索引，该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同。</p><p>索引是通过二叉树的数据结构来描述的，我们可以这么理解聚簇索引：索引的叶节点就是数据节点。而非聚簇索引的叶节点仍然是索引节点，只不过有一个指针指向对应的数据块。如下图：</p><p><img src="//qn.atecher.com/mts/20180404/3833492718322688" alt="Image-1"></p><p>（非聚集索引）</p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><h3 id="深入浅出理解索引结构"><a href="#深入浅出理解索引结构" class="headerlink" title="深入浅出理解索引结构"></a>深入浅出理解索引结构</h3><p>实际上，您可以把索引理解为一种特殊的目录。微软的SQL SERVER提供了两种索引：聚集索引（clustered index，也称聚类索引、簇集索引）和非聚集索引（nonclustered index，也称非聚类索引、非簇集索引）。下面，我们举例来说明一下聚集索引和非聚集索引的区别：</p><p>其实，我们的汉语字典的正文本身就是一个聚集索引。比如，我们要查“安”字，就会很自然地翻开字典的前几页，因为“安”的拼音是“an”，而按照拼音排序汉字的字典是以英文字母“a”开头并以“z”结尾的，那么“安”字就自然地排在字典的前部。如果您翻完了所有以“a”开头的部分仍然找不到这个字，那么就说明您的字典中没有这个字；同样的，如果查“张”字，那您也会将您的字典翻到最后部分，因为“张”的拼音是“zhang”。也就是说，字典的正文部分本身就是一个目录，您不需要再去查其他目录来找到您需要找的内容。我们把这种正文内容本身就是一种按照一定规则排列的目录称为“聚集索引”。</p><p>如果您认识某个字，您可以快速地从自动中查到这个字。但您也可能会遇到您不认识的字，不知道它的发音，这时候，您就不能按照刚才的方法找到您要查的字，而需要去根据“偏旁部首”查到您要找的字，然后根据这个字后的页码直接翻到某页来找到您要找的字。但您结合“部首目录”和“检字表”而查到的字的排序并不是真正的正文的排序方法，比如您查“张”字，我们可以看到在查部首之后的检字表中“张”的页码是672页，检字表中“张”的上面是“驰”字，但页码却是63页，“张”的下面是“弩”字，页面是390页。很显然，这些字并不是真正的分别位于“张”字的上下方，现在您看到的连续的“驰、张、弩”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。我们可以通过这种方式来找到您所需要的字，但它需要两个过程，先找到目录中的结果，然后再翻到您所需要的页码。我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为“非聚集索引”。</p><p>通过以上例子，我们可以理解到什么是“聚集索引”和“非聚集索引”。进一步引申一下，我们可以很容易的理解：每个表只能有一个聚集索引，因为目录只能按照一种方法进行排序。</p><h3 id="何时使用聚集索引或非聚集索引"><a href="#何时使用聚集索引或非聚集索引" class="headerlink" title="何时使用聚集索引或非聚集索引"></a>何时使用聚集索引或非聚集索引</h3><p>下面的表总结了何时使用聚集索引或非聚集索引（很重要）：</p><table><thead><tr><th style="text-align:center">动作描述</th><th style="text-align:center">使用聚集索引</th><th style="text-align:center">使用非聚集索引</th></tr></thead><tbody><tr><td style="text-align:center">列经常被分组排序</td><td style="text-align:center">应</td><td style="text-align:center">应</td></tr><tr><td style="text-align:center">返回某范围内的数据</td><td style="text-align:center">应</td><td style="text-align:center">不应</td></tr><tr><td style="text-align:center">一个或极少不同值</td><td style="text-align:center">不应</td><td style="text-align:center">不应</td></tr><tr><td style="text-align:center">小数目的不同值</td><td style="text-align:center">应</td><td style="text-align:center">不应</td></tr><tr><td style="text-align:center">大数目的不同值</td><td style="text-align:center">不应</td><td style="text-align:center">应</td></tr><tr><td style="text-align:center">频繁更新的列</td><td style="text-align:center">不应</td><td style="text-align:center">应</td></tr><tr><td style="text-align:center">外键列</td><td style="text-align:center">应</td><td style="text-align:center">应</td></tr><tr><td style="text-align:center">主键列</td><td style="text-align:center">应</td><td style="text-align:center">应</td></tr><tr><td style="text-align:center">频繁修改索引列</td><td style="text-align:center">不应</td><td style="text-align:center">应</td></tr></tbody></table><p>事实上，我们可以通过前面聚集索引和非聚集索引的定义的例子来理解上表。如：返回某范围内的数据一项。比如您的某个表有一个时间列，恰好您把聚合索引建立在了该列，这时您查询2004年1月1日至2004年10月1日之间的全部数据时，这个速度就将是很快的，因为您的这本字典正文是按日期进行排序的，聚类索引只需要找到要检索的所有数据中的开头和结尾数据即可；而不像非聚集索引，必须先查到目录中查到每一项数据对应的页码，然后再根据页码查到具体内容。</p><h3 id="结合实际，谈索引使用的误区"><a href="#结合实际，谈索引使用的误区" class="headerlink" title="结合实际，谈索引使用的误区"></a>结合实际，谈索引使用的误区</h3><p>理论的目的是应用。虽然我们刚才列出了何时应使用聚集索引或非聚集索引，但在实践中以上规则却很容易被忽视或不能根据实际情况进行综合分析。下面我们将根据在实践中遇到的实际问题来谈一下索引使用的误区，以便于大家掌握索引建立的方法。</p><h4 id="主键就是聚集索引"><a href="#主键就是聚集索引" class="headerlink" title="主键就是聚集索引"></a>主键就是聚集索引</h4><p>这种想法笔者认为是极端错误的，是对聚集索引的一种浪费。虽然SQL SERVER默认是在主键上建立聚集索引的。</p><p>通常，我们会在每个表中都建立一个ID列，以区分每条数据，并且这个ID列是自动增大的，步长一般为1。我们的这个办公自动化的实例中的列Gid就是如此。此时，如果我们将这个列设为主键，SQL SERVER会将此列默认为聚集索引。这样做有好处，就是可以让您的数据在数据库中按照ID进行物理排序，但笔者认为这样做意义不大。</p><p>显而易见，聚集索引的优势是很明显的，而每个表中只能有一个聚集索引的规则，这使得聚集索引变得更加珍贵。</p><p>从我们前面谈到的聚集索引的定义我们可以看出，使用聚集索引的最大好处就是能够根据查询要求，迅速缩小查询范围，避免全表扫描。在实际应用中，因为 ID号是自动生成的，我们并不知道每条记录的ID号，所以我们很难在实践中用ID号来进行查询。这就使让ID号这个主键作为聚集索引成为一种资源浪费。其次，让每个ID号都不同的字段作为聚集索引也不符合“大数目的不同值情况下不应建立聚合索引”规则；当然，这种情况只是针对用户经常修改记录内容，特别是索引项的时候会负作用，但对于查询速度并没有影响。</p><p>在办公自动化系统中，无论是系统首页显示的需要用户签收的文件、会议还是用户进行文件查询等任何情况下进行数据查询都离不开字段的是“日期”还有用户本身的“用户名”。</p><p>通常，办公自动化的首页会显示每个用户尚未签收的文件或会议。虽然我们的where语句可以仅仅限制当前用户尚未签收的情况，但如果您的系统已建立了很长时间，并且数据量很大，那么，每次每个用户打开首页的时候都进行一次全表扫描，这样做意义是不大的，绝大多数的用户1个月前的文件都已经浏览过了，这样做只能徒增数据库的开销而已。事实上，我们完全可以让用户打开系统首页时，数据库仅仅查询这个用户近3个月来未阅览的文件，通过“日期”这个字段来限制表扫描，提高查询速度。如果您的办公自动化系统已经建立的2年，那么您的首页显示速度理论上将是原来速度8倍，甚至更快。</p><p>在这里之所以提到“理论上”三字，是因为如果您的聚集索引还是盲目地建在ID这个主键上时，您的查询速度是没有这么高的，即使您在“日期”这个字段上建立的索引（非聚合索引）。下面我们就来看一下在1000万条数据量的情况下各种查询的速度表现（3个月内的数据为25万条）：</p><p>（1）仅在主键上建立聚集索引，并且不划分时间段：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">Select</span> gid,fariqi,neibuyonghu,title <span class="keyword">from</span> tgongwen</span><br></pre></td></tr></table></figure><p>用时：128470毫秒（即：128秒）</p><p>（2）在主键上建立聚集索引，在fariq上建立非聚集索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">select</span> gid,fariqi,neibuyonghu,title <span class="keyword">from</span> Tgongwen</span><br><span class="line">    <span class="keyword">where</span> fariqi&gt; <span class="keyword">dateadd</span>(<span class="keyword">day</span>,<span class="number">-90</span>,<span class="keyword">getdate</span>())</span><br></pre></td></tr></table></figure><p>用时：53763毫秒（54秒）</p><p>（3）将聚合索引建立在日期列（fariqi）上：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">select</span> gid,fariqi,neibuyonghu,title <span class="keyword">from</span> Tgongwen</span><br><span class="line">    <span class="keyword">where</span> fariqi&gt; <span class="keyword">dateadd</span>(<span class="keyword">day</span>,<span class="number">-90</span>,<span class="keyword">getdate</span>())</span><br></pre></td></tr></table></figure></p><p>用时：2423毫秒（2秒）</p><p>虽然每条语句提取出来的都是25万条数据，各种情况的差异却是巨大的，特别是将聚集索引建立在日期列时的差异。事实上，如果您的数据库真的有1000 万容量的话，把主键建立在ID列上，就像以上的第1、2种情况，在网页上的表现就是超时，根本就无法显示。这也是我摒弃ID列作为聚集索引的一个最重要的因素。得出以上速度的方法是：在各个select语句前加：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">declare</span> @d datetime</span><br><span class="line">    <span class="keyword">set</span> @d=<span class="keyword">getdate</span>()</span><br></pre></td></tr></table></figure><p>并在select语句后加：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">select</span> \[语句执行花费时间(毫秒)\]=<span class="keyword">datediff</span>(ms,@d,<span class="keyword">getdate</span>())</span><br></pre></td></tr></table></figure><h4 id="只要建立索引就能显著提高查询速度"><a href="#只要建立索引就能显著提高查询速度" class="headerlink" title="只要建立索引就能显著提高查询速度"></a>只要建立索引就能显著提高查询速度</h4><p>事实上，我们可以发现上面的例子中，第2、3条语句完全相同，且建立索引的字段也相同；不同的仅是前者在fariqi字段上建立的是非聚合索引，后者在此字段上建立的是聚合索引，但查询速度却有着天壤之别。所以，并非是在任何字段上简单地建立索引就能提高查询速度。</p><p>从建表的语句中，我们可以看到这个有着1000万数据的表中fariqi字段有5003个不同记录。在此字段上建立聚合索引是再合适不过了。在现实中，我们每天都会发几个文件，这几个文件的发文日期就相同，这完全符合建立聚集索引要求的：“既不能绝大多数都相同，又不能只有极少数相同”的规则。由此看来，我们建立“适当”的聚合索引对于我们提高查询速度是非常重要的。</p><h4 id="把所有需要提高查询速度的字段都加进聚集索引，以提高查询速度"><a href="#把所有需要提高查询速度的字段都加进聚集索引，以提高查询速度" class="headerlink" title="把所有需要提高查询速度的字段都加进聚集索引，以提高查询速度"></a>把所有需要提高查询速度的字段都加进聚集索引，以提高查询速度</h4><p>上面已经谈到：在进行数据查询时都离不开字段的是“日期”还有用户本身的“用户名”。既然这两个字段都是如此的重要，我们可以把他们合并起来，建立一个复合索引（compound index）。</p><p>很多人认为只要把任何字段加进聚集索引，就能提高查询速度，也有人感到迷惑：如果把复合的聚集索引字段分开查询，那么查询速度会减慢吗？带着这个问题，我们来看一下以下的查询速度（结果集都是25万条数据）：（日期列fariqi首先排在复合聚集索引的起始列，用户名neibuyonghu排在后列）：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">select</span> gid,fariqi,neibuyonghu,title <span class="keyword">from</span> Tgongwen <span class="keyword">where</span> fariqi&gt;<span class="string">'2004-5-5'</span></span><br></pre></td></tr></table></figure></p><p>查询速度：2513毫秒<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">select</span> gid,fariqi,neibuyonghu,title <span class="keyword">from</span> Tgongwen <span class="keyword">where</span> fariqi&gt;<span class="string">'2004-5-5'</span> <span class="keyword">and</span> neibuyonghu=<span class="string">'办公室'</span></span><br></pre></td></tr></table></figure></p><p>查询速度：2516毫秒</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> gid,fariqi,neibuyonghu,title <span class="keyword">from</span> Tgongwen <span class="keyword">where</span> neibuyonghu=<span class="string">'办公室'</span></span><br></pre></td></tr></table></figure><p>查询速度：60280毫秒</p><p>从以上试验中，我们可以看到如果仅用聚集索引的起始列作为查询条件和同时用到复合聚集索引的全部列的查询速度是几乎一样的，甚至比用上全部的复合索引列还要略快（在查询结果集数目一样的情况下）；而如果仅用复合聚集索引的非起始列作为查询条件的话，这个索引是不起任何作用的。当然，语句1、2的查询速度一样是因为查询的条目数一样，如果复合索引的所有列都用上，而且查询结果少的话，这样就会形成“索引覆盖”，因而性能可以达到最优。同时，请记住：无论您是否经常使用聚合索引的其他列，但其前导列一定要是使用最频繁的列。</p><h3 id="其他书上没有的索引使用经验总结"><a href="#其他书上没有的索引使用经验总结" class="headerlink" title="其他书上没有的索引使用经验总结"></a>其他书上没有的索引使用经验总结</h3><h4 id="用聚合索引比用不是聚合索引的主键速度快"><a href="#用聚合索引比用不是聚合索引的主键速度快" class="headerlink" title="用聚合索引比用不是聚合索引的主键速度快"></a>用聚合索引比用不是聚合索引的主键速度快</h4><p>下面是实例语句：（都是提取25万条数据）<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">select</span> gid,fariqi,neibuyonghu,reader,title <span class="keyword">from</span> Tgongwen <span class="keyword">where</span> fariqi=<span class="string">'2004-9-16'</span></span><br></pre></td></tr></table></figure></p><p>使用时间：3326毫秒</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">select</span> gid,fariqi,neibuyonghu,reader,title <span class="keyword">from</span> Tgongwen <span class="keyword">where</span> gid&lt;=<span class="number">250000</span></span><br></pre></td></tr></table></figure><p>使用时间：4470毫秒</p><p>这里，用聚合索引比用不是聚合索引的主键速度快了近1/4。</p><h4 id="用聚合索引比用一般的主键作order-by时速度快，特别是在小数据量情况下"><a href="#用聚合索引比用一般的主键作order-by时速度快，特别是在小数据量情况下" class="headerlink" title="用聚合索引比用一般的主键作order by时速度快，特别是在小数据量情况下"></a>用聚合索引比用一般的主键作order by时速度快，特别是在小数据量情况下</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">select</span> gid,fariqi,neibuyonghu,reader,title <span class="keyword">from</span> Tgongwen <span class="keyword">order</span> <span class="keyword">by</span> fariqi</span><br></pre></td></tr></table></figure><p>用时：12936</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">select</span> gid,fariqi,neibuyonghu,reader,title <span class="keyword">from</span> Tgongwen <span class="keyword">order</span> <span class="keyword">by</span> gid</span><br></pre></td></tr></table></figure><p>用时：18843</p><p>这里，用聚合索引比用一般的主键作order by时，速度快了3/10。事实上，如果数据量很小的话，用聚集索引作为排序列要比使用非聚集索引速度快得明显的多；而数据量如果很大的话，如10万以上，则二者的速度差别不明显。</p><h4 id="使用聚合索引内的时间段，搜索时间会按数据占整个数据表的百分比成比例减少，而无论聚合索引使用了多少个："><a href="#使用聚合索引内的时间段，搜索时间会按数据占整个数据表的百分比成比例减少，而无论聚合索引使用了多少个：" class="headerlink" title="使用聚合索引内的时间段，搜索时间会按数据占整个数据表的百分比成比例减少，而无论聚合索引使用了多少个："></a>使用聚合索引内的时间段，搜索时间会按数据占整个数据表的百分比成比例减少，而无论聚合索引使用了多少个：</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">select</span> gid,fariqi,neibuyonghu,reader,title <span class="keyword">from</span> Tgongwen <span class="keyword">where</span> fariqi&gt;<span class="string">''</span><span class="number">2004</span><span class="number">-1</span><span class="number">-1</span><span class="string">''</span></span><br></pre></td></tr></table></figure><p>用时：6343毫秒（提取100万条）<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">select</span> gid,fariqi,neibuyonghu,reader,title <span class="keyword">from</span> Tgongwen <span class="keyword">where</span> fariqi&gt;<span class="string">'2004-6-6'</span></span><br></pre></td></tr></table></figure></p><p>用时：3170毫秒（提取50万条）<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">select</span> gid,fariqi,neibuyonghu,reader,title <span class="keyword">from</span> Tgongwen <span class="keyword">where</span> fariqi=<span class="string">'2004-9-16'</span></span><br></pre></td></tr></table></figure></p><p>用时：3326毫秒（和上句的结果一模一样。如果采集的数量一样，那么用大于号和等于号是一样的）<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">select</span> gid,fariqi,neibuyonghu,reader,title <span class="keyword">from</span> Tgongwen <span class="keyword">where</span> fariqi&gt;<span class="string">'2004-1-1'</span> <span class="keyword">and</span> fariqi&lt;<span class="string">'2004-6-6'</span></span><br></pre></td></tr></table></figure></p><p>用时：3280毫秒</p><h4 id="日期列不会因为有分秒的输入而减慢查询速度"><a href="#日期列不会因为有分秒的输入而减慢查询速度" class="headerlink" title="日期列不会因为有分秒的输入而减慢查询速度"></a>日期列不会因为有分秒的输入而减慢查询速度</h4><p>下面的例子中，共有100万条数据，2004年1月1日以后的数据有50万条，但只有两个不同的日期，日期精确到日；之前有数据50万条，有5000个不同的日期，日期精确到秒。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">select</span> gid,fariqi,neibuyonghu,reader,title <span class="keyword">from</span> Tgongwen <span class="keyword">where</span> fariqi&gt;<span class="string">'2004-1-1'</span> <span class="keyword">order</span> <span class="keyword">by</span> fariqi</span><br></pre></td></tr></table></figure></p><p>用时：6390毫秒<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">select</span> gid,fariqi,neibuyonghu,reader,title <span class="keyword">from</span> Tgongwen <span class="keyword">where</span> fariqi&lt;<span class="string">'2004-1-1'</span> <span class="keyword">order</span> <span class="keyword">by</span> fariqi</span><br></pre></td></tr></table></figure></p><p>用时：6453毫秒</p><h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><p>“水可载舟，亦可覆舟”，索引也一样。索引有助于提高检索性能，但过多或不当的索引也会导致系统低效。因为用户在表中每加进一个索引，数据库就要做更多的工作。过多的索引甚至会导致索引碎片。</p><p>所以说，我们要建立一个“适当”的索引体系，特别是对聚合索引的创建，更应精益求精，以使您的数据库能得到高性能的发挥。</p><p>当然，在实践中，作为一个尽职的数据库管理员，您还要多测试一些方案，找出哪种方案效率最高、最为有效。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;官方说法&quot;&gt;&lt;a href=&quot;#官方说法&quot; class=&quot;headerlink&quot; title=&quot;官方说法&quot;&gt;&lt;/a&gt;官方说法&lt;/h2&gt;&lt;h3 id=&quot;聚集索引&quot;&gt;&lt;a href=&quot;#聚集索引&quot; class=&quot;headerlink&quot; title=&quot;聚集索引&quot;&gt;&lt;/a&gt;聚集索引&lt;/h3&gt;&lt;p&gt;一种索引，该索引中键值的逻辑顺序决定了表中相应行的物理顺序。&lt;/p&gt;
&lt;p&gt;聚集索引确定表中数据的物理顺序。聚集索引类似于电话簿，后者按姓氏排列数据。由于聚集索引规定数据在表中的物理存储顺序，因此一个表只能包含一个聚集索引。但该索引可以包含多个列（组合索引），就像电话簿按姓氏和名字进行组织一样。&lt;/p&gt;
&lt;p&gt;聚集索引对于那些经常要搜索范围值的列特别有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻。例如，如果应用程序执行 的一个查询经常检索某一日期范围内的记录，则使用聚集索引可以迅速找到包含开始日期的行，然后检索表中所有相邻的行，直到到达结束日期。这样有助于提高此 类查询的性能。同样，如果对从表中检索的数据进行排序时经常要用到某一列，则可以将该表在该列上聚集（物理排序），避免每次查询该列时都进行排序，从而节 省成本。&lt;/p&gt;
&lt;p&gt;当索引值唯一时，使用聚集索引查找特定的行也很有效率。例如，使用唯一雇员 ID 列 emp_id 查找特定雇员的最快速的方法，是在 emp_id 列上创建聚集索引或 PRIMARY KEY 约束。&lt;/p&gt;
    
    </summary>
    
      <category term="DB" scheme="http://blog.atecher.com/categories/DB/"/>
    
    
      <category term="SQL" scheme="http://blog.atecher.com/tags/SQL/"/>
    
      <category term="MYSQL" scheme="http://blog.atecher.com/tags/MYSQL/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机详解：JVM常见问题总结</title>
    <link href="http://blog.atecher.com/2017/11/06/Java-VM-Explanation-1/"/>
    <id>http://blog.atecher.com/2017/11/06/Java-VM-Explanation-1/</id>
    <published>2017-11-06T14:00:10.000Z</published>
    <updated>2022-01-28T10:28:39.119Z</updated>
    
    <content type="html"><![CDATA[<p>先把本文的目录画一个思维导图：</p><p><img src="//qn.atecher.com/mts/20180418/3853291052336128" alt="Java-VM-Explanation-1-1"></p><a id="more"></a><h2 id="Java引用的四种状态"><a href="#Java引用的四种状态" class="headerlink" title="Java引用的四种状态"></a>Java引用的四种状态</h2><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>用的最广。我们平时写代码时，new一个Object存放在堆内存，然后用一个引用指向它，这就是强引用。</p><p><strong>如果一个对象具有强引用，那垃圾回收器绝不会回收它</strong>。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>如果一个对象只具有软引用，则内存空间足够时，垃圾回收器就不会回收它；如果<strong>内存空间不足了，就会回收这些对象的内存</strong>。（备注：如果内存不足，随时有可能被回收。）</p><p>只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用与软引用的区别在于：<strong>只具有弱引用的对象拥有更短暂的生命周期</strong>。</p><p><strong>每次执行GC的时候</strong>，一旦发现了只具有弱引用的对象，<strong>不管当前内存空间足够与否，都会回收它的内存</strong>。不过，由于垃圾回收器是一个优先级很低的线程，因此<strong>不一定会很快发现那些只具有弱引用的对象</strong>。</p><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，<strong>虚引用并不会决定对象的生命周期</strong>。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，<strong>在任何时候都可能被垃圾回收器回收</strong>。</p><p>虚引用主要用来跟踪对象被垃圾回收器回收的活动。</p><p>注：关于各种引用的详解，可以参考这篇博客：<a href="http://zhangjunhd.blog.51cto.com/113473/53092" target="_blank" rel="noopener">http://zhangjunhd.blog.51cto.com/113473/53092</a></p><h2 id="Java中的内存划分"><a href="#Java中的内存划分" class="headerlink" title="Java中的内存划分"></a>Java中的内存划分</h2><p>Java程序在运行时，需要在内存中的分配空间。<strong>为了提高运算效率，就对数据进行了不同空间的划分</strong>，因为每一片区域都有特定的处理数据方式和内存管理方式。</p><p><img src="//qn.atecher.com/mts/20180418/3853291055121408" alt="Java-VM-Explanation-1-2"></p><p>上面这张图就是jvm运行时的状态。具体划分为如下5个内存空间：（非常重要）</p><ul><li>程序计数器：保证线程切换后能恢复到原来的执行位置</li><li>虚拟机栈：（栈内存）为虚拟机执行java方法服务：方法被调用时创建栈帧–&gt;局部变量表-&gt;局部变量、对象引用</li><li>本地方法栈：为虚拟机执使用到的Native方法服务</li><li><strong>堆内存：</strong>存放<strong>所有new出来的东西</strong></li><li><strong>方法区：</strong>存储被虚拟机加载的<strong>类信息、常量、静态常量、静态方法</strong>等。</li><li>运行时常量池（方法区的一部分）</li></ul><h2 id="GC对它们的回收"><a href="#GC对它们的回收" class="headerlink" title="GC对它们的回收"></a>GC对它们的回收</h2><p>内存区域中的<strong>程序计数器、虚拟机栈、本地方法栈</strong>这3个区域<strong>随着线程而生，线程而灭</strong>；<strong>栈中的栈帧</strong>随着方法的进入和退出而有条不紊地执行着出栈和入栈的操作，每个栈帧中分配多少内存基本是在类结构确定下来时就已知的。在这几个区域不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。</p><p><strong>GC回收的主要对象</strong>：而<strong>Java堆和方法区</strong>则不同，一个接口中的多个实现类需要的内存可能不同，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，GC关注的也是这部分内存，后面的文章中如果涉及到“内存”分配与回收也仅指着一部分内存。</p><h3 id="程序计数器（线程私有）"><a href="#程序计数器（线程私有）" class="headerlink" title="程序计数器（线程私有）"></a>程序计数器（线程私有）</h3><blockquote><p>每个线程拥有一个程序计数器，在线程创建时创建。<br>指向下一条指令的地址。<br>执行本地方法时，其值为undefined。</p></blockquote><p>说的通俗一点，我们知道，Java是支持多线程的，程序先去执行A线程，执行到一半，然后就去执行B线程，然后又跑回来接着执行A线程，那程序是怎么记住A线程已经执行到哪里了呢？这就需要程序计数器了。因此<strong>，为了线程切换后能够恢复到正确的执行位置，每条线程都有一个独立的程序计数器</strong>，这块儿属于“线程私有”的内存。</p><h3 id="Java虚拟机栈（线程私有）"><a href="#Java虚拟机栈（线程私有）" class="headerlink" title="Java虚拟机栈（线程私有）"></a>Java虚拟机栈（线程私有）</h3><p>每个<strong>方法被调用</strong>的时候都会创建一个<strong>栈帧</strong>，用于存储局部变量表、操作栈、动态链接、方法出口等信息。局部变量表存放的是：编译期可知的基本数据类型、对象引用类型。</p><p>每个方法被调用直到执行完成的过程，就对应着一个栈帧在虚拟机中从入栈到出栈的过程。</p><p>在Java虚拟机规范中，对这个区域规定了两种异常情况：</p><p>（1）如果线程请求的栈深度太深，超出了虚拟机所允许的深度，就会出现StackOverFlowError（比如无限递归。因为每一层栈帧都占用一定空间，而 Xss 规定了栈的最大空间，超出这个值就会报错）</p><p>（2）虚拟机栈可以动态扩展，如果扩展到无法申请足够的内存空间，会出现OOM</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>（1）本地方法栈与java虚拟机栈作用非常类似，其区别是：java虚拟机栈是为虚拟机执行java方法服务的，而本地方法栈则为虚拟机执使用到的<strong>Native方法服务</strong>。</p><p>（2）Java虚拟机没有对本地方法栈的使用和数据结构做强制规定，Sun HotSpot虚拟机就把java虚拟机栈和本地方法栈合二为一。</p><p>（3）本地方法栈也会抛出StackOverFlowError和OutOfMemoryError。</p><h3 id="Java堆：即堆内存（线程共享）"><a href="#Java堆：即堆内存（线程共享）" class="headerlink" title="Java堆：即堆内存（线程共享）"></a>Java堆：即堆内存（线程共享）</h3><ol><li>堆是java虚拟机所管理的内存区域中最大的一块，java堆是被所有线程共享的内存区域，在java虚拟机启动时创建，堆内存的唯一目的就是存放对象实例几乎所有的对象实例都在堆内存分配。</li><li><strong>堆是GC管理的主要区域</strong>，从垃圾回收的角度看，由于现在的垃圾收集器都是采用的<strong>分代收集</strong>算法，因此java堆还可以初步细分为<strong>新生代和老年代</strong>。</li><li>Java虚拟机规定，堆可以处于物理上不连续的内存空间中，只要逻辑上连续的即可。在实现上既可以是固定的，也可以是可动态扩展的。如果在堆内存没有完成实例分配，并且堆大小也无法扩展，就会抛出OutOfMemoryError异常。</li></ol><h3 id="方法区（线程共享）"><a href="#方法区（线程共享）" class="headerlink" title="方法区（线程共享）"></a>方法区（线程共享）</h3><p>（1）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br>（2）Sun HotSpot虚拟机把方法区叫做永久代（Permanent Generation），方法区中最终要的部分是运行时常量池。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>（1）运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时就会抛出OutOfMemoryError异常。</p><h2 id="Java对象在内存中的状态"><a href="#Java对象在内存中的状态" class="headerlink" title="Java对象在内存中的状态"></a>Java对象在内存中的状态</h2><h3 id="可达的-可触及的"><a href="#可达的-可触及的" class="headerlink" title="可达的/可触及的"></a>可达的/可触及的</h3><p>Java对象被创建后，如果被一个或多个变量引用，那就是可达的。即从根节点可以触及到这个对象。</p><p>其实就是从根节点扫描，只要这个对象在引用链中，那就是可触及的。</p><h3 id="可恢复的"><a href="#可恢复的" class="headerlink" title="可恢复的"></a>可恢复的</h3><p>Java对象不再被任何变量引用就进入了可恢复状态。</p><p>在回收该对象之前，该对象的finalize()方法进行资源清理。如果<strong>在finalize()方法中重新让变量引用该对象，则该对象再次变为可达状态</strong>，否则该对象进入不可达状态</p><h3 id="不可达的"><a href="#不可达的" class="headerlink" title="不可达的"></a>不可达的</h3><p>Java对象不被任何变量引用，且系统在调用对象的finalize()方法后依然没有使该对象变成可达状态（该对象依然没有被变量引用），那么该对象将变成不可达状态。</p><p>当Java对象处于不可达状态时，系统才会真正回收该对象所占有的资源。</p><h2 id="判断对象死亡的两种常用算法"><a href="#判断对象死亡的两种常用算法" class="headerlink" title="判断对象死亡的两种常用算法"></a>判断对象死亡的两种常用算法</h2><p>当对象不被引用的时候，这个对象就是死亡的，等待GC进行回收。</p><h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p><strong>概念：</strong></p><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p><strong>但是：</strong></p><p>主流的java虚拟机并没有选用引用计数算法来管理内存，其中最主要的原因是：<strong>它很难解决对象之间相互循环引用的问题</strong>。</p><p><strong>优点：</strong></p><p>算法的实现简单，判定效率也高，大部分情况下是一个不错的算法。很多地方应用到它</p><p><strong>缺点：</strong></p><blockquote><p>引用和去引用伴随加法和减法，影响性能</p><p>致命的缺陷：对于<strong>循环引用的对象</strong>无法进行回收</p></blockquote><h3 id="根搜索算法（jvm采用的算法）"><a href="#根搜索算法（jvm采用的算法）" class="headerlink" title="根搜索算法（jvm采用的算法）"></a>根搜索算法（jvm采用的算法）</h3><p><strong>概念：</strong></p><p>设立若干种根对象，当任何一个根对象（GC Root）到某一个对象均不可达时，则认为这个对象是可以被回收的。</p><p><strong>注：</strong>这里提到，设立若干种根对象，当任何一个根对象到某一个对象均不可达时，则认为这个对象是可以被回收的。我们在后面介绍标记-清理算法/标记整理算法时，也会一直强调从根节点开始，对所有可达对象做一次标记，那什么叫做可达呢？</p><p><strong>可达性分析：</strong></p><p>从根（GC Roots）的对象作为起始点，开始向下搜索，搜索所走过的路径称为“<strong>引用链</strong>”，当一个对象到GC Roots没有任何引用链相连（用图论的概念来讲，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p><p><img src="//qn.atecher.com/mts/20180418/3853291055662080" alt="Java-VM-Explanation-1-3"></p><p>如上图所示，ObjectD和ObjectE是互相关联的，但是由于GC roots到这两个对象不可达，所以最终D和E还是会被当做GC的对象，上图若是采用引用计数法，则A-E五个对象都不会被回收。</p><p><strong>根（GC Roots）：</strong></p><p>说到GC roots（GC根），在JAVA语言中，可以当做GC roots的对象有以下几种：</p><blockquote><p>1、<strong>栈</strong>（栈帧中的本地变量表）<strong>中引用的对象</strong>。<br>2、方法区中的静态成员。<br>3、方法区中的常量引用的对象（全局变量）<br>4、本地方法栈中JNI（一般说的Native方法）引用的对象。</p></blockquote><p>注：第一和第四种都是指的方法的本地变量表，第二种表达的意思比较清晰，第三种主要指的是声明为final的常量值。<br>在根搜索算法的基础上，现代虚拟机的实现当中，<strong>垃圾搜集的算法</strong>主要有三种，分别是<strong>标记-清除算法</strong>、<strong>复制算法</strong>、<strong>标记-整理算法</strong>。这三种算法都扩充了根搜索算法，不过它们理解起来还是非常好理解的。</p><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p><strong>概念：</strong></p><p>标记阶段：<strong>先通过根节点，标记所有从根节点开始的可达对象</strong>。因此，未被标记的对象就是未被引用的垃圾对象；<br>清除阶段：清除所有未被标记的对象。</p><p><strong>缺点：</strong></p><p>标记和清除的过程<strong>效率不高</strong>（标记和清除都需要从头遍历到尾）<br>标记清除后<strong>会产生大量不连续的碎片</strong>。</p><h3 id="复制算法（新生代的GC）"><a href="#复制算法（新生代的GC）" class="headerlink" title="复制算法（新生代的GC）"></a>复制算法（新生代的GC）</h3><p><strong>概念：</strong></p><p>将原有的<strong>内存空间分为两块</strong>，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的<strong>存活对象</strong>复制到未使用的内存块中，然后清除正在使用的内存块中的所有对象。</p><p><strong>优点：</strong></p><blockquote><p>这样使得每次都是对整个半区进行回收，内存分配时也就<strong>不用考虑内存碎片</strong>等情况<br>只要移动堆顶指针，按顺序分配内存即可，实现简单，<strong>运行效率高</strong></p></blockquote><p><strong>缺点：空间的浪费</strong></p><p>从以上描述不难看出，复制算法要想使用，最起码对象的存活率要非常低才行。</p><p>现在的商业虚拟机都采用这种收集算法来回收新生代，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将<strong>内存分为一块比较大的Eden空间和两块较小的Survivor空间</strong>，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。</p><p>当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，<strong>当Survivor空间不够用时，需要依赖于老年代进行分配担保，所以大对象直接进入老年代</strong>。整个过程如下图所示：</p><p><img src="//qn.atecher.com/mts/20180418/3853291040113664" alt="Java-VM-Explanation-1-4"></p><h3 id="标记-整理算法（老年代的GC）"><a href="#标记-整理算法（老年代的GC）" class="headerlink" title="标记-整理算法（老年代的GC）"></a>标记-整理算法（老年代的GC）</h3><p>复制算法在对象<strong>存活率高</strong>的时候要进行较多的复制操作，效率将会降低，所以在老年代中一般不能直接选用这种算法。</p><p><strong>概念：</strong></p><p>标记阶段：先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象</p><p>整理阶段：<strong>将所有的存活对象压缩到内存的一端</strong>；之后，清理边界外所有的空间</p><p><strong>优点：</strong></p><p>不会产生内存碎片。</p><p><strong>缺点：</strong></p><p>在标记的基础之上还需要进行对象的移动，成本相对较高，效率也不高。</p><p>它们的区别如下：（&gt;表示前者要优于后者，=表示两者效果一样）<br>（1）效率：复制算法 &gt; 标记/整理算法 &gt; 标记/清除算法（此处的效率只是简单的对比时间复杂度，实际情况不一定如此）。<br>（2）内存整齐度：复制算法=标记/整理算法&gt;标记/清除算法。<br>（3）内存利用率：标记/整理算法=标记/清除算法&gt;复制算法。</p><p>注1：标记-整理算法不仅可以弥补标记-清除算法当中，内存区域分散的缺点，也消除了复制算法当中，内存减半的高额代价。<br>注2：可以看到标记/清除算法是比较落后的算法了，但是后两种算法却是在此基础上建立的。<br>注3：时间与空间不可兼得。</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前商业虚拟机的GC都是采用的“分代收集算法”，这并不是什么新的思想，<strong>只是根据对象的存活周期的不同将内存划分为几块儿</strong>。一般是把Java堆分为新生代和老年代：<strong>短命对象归为新生代，长命对象归为老年代</strong>。</p><p><strong>存活率低：少量对象存活，适合复制算法</strong>：在新生代中，每次GC时都发现有大批对象死去，只有少量存活（新生代中98%的对象都是“朝生夕死”），那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成GC。</p><p><strong>存活率高：大量对象存活，适合用标记-清理/标记-整理</strong>：在老年代中，因为对象存活率高、没有额外空间对他进行分配担保，就必须使用“标记-清理”/“标记-整理”算法进行GC。</p><p>注：<strong>老年代的对象中，有一小部分是因为在新生代回收时，老年代做担保，进来的对象；绝大部分对象是因为很多次GC都没有被回收掉而进入老年代</strong>。</p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p>如果说收集算法时内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。<br>虽然我们在对各种收集器进行比较，但并非为了挑出一个最好的收集器。因为直到现在位置还没有最好的收集器出现，更加没有万能的收集器，所以我们<strong>选择的只是对具体应用最合适的收集器</strong>。</p><h3 id="Serial收集器（串行收集器）"><a href="#Serial收集器（串行收集器）" class="headerlink" title="Serial收集器（串行收集器）"></a>Serial收集器（串行收集器）</h3><p>这个收集器是一个单线程的收集器，但它的单线程的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程（<strong>Stop-The-World：将用户正常工作的线程全部暂停掉</strong>），直到它收集结束。收集器的运行过程如下图所示：</p><p><img src="//qn.atecher.com/mts/20180418/3853291042571264" alt="Java-VM-Explanation-1-5"></p><p>上图中：</p><ul><li>新生代采用复制算法，Stop-The-World</li><li>老年代采用标记-整理算法，Stop-The-World</li></ul><p>当它进行GC工作的时候，虽然会造成Stop-The-World，但它存在有存在的原因：正是因为它的简单而高效（与其他收集器的单线程比），对于限定单个CPU的环境来说，没有线程交互的开销，专心做GC，自然可以获得最高的单线程手机效率。所以<strong>Serial收集器对于运行在client模式下是一个很好的选择</strong>（它依然是虚拟机运行在<strong>client模式下</strong>的默认<strong>新生代</strong>收集器）。</p><h3 id="ParNew收集器（使用多条线程进行GC）"><a href="#ParNew收集器（使用多条线程进行GC）" class="headerlink" title="ParNew收集器（使用多条线程进行GC）"></a>ParNew收集器（使用多条线程进行GC）</h3><p>ParNew收集器是Serial收集器的多线程版本。</p><p><strong>它是运行在server模式下的首选新生代收集器</strong>，除了Serial收集器外，目前只有它能与CMS收集器配合工作。CMS收集器是一个被认为具有划时代意义的并发收集器，因此如果有一个垃圾收集器能和它一起搭配使用让其更加完美，那这个收集器必然也是一个不可或缺的部分了。收集器的运行过程如下图所示：</p><p><img src="//qn.atecher.com/mts/20180418/3853291042374656" alt="Java-VM-Explanation-1-6"></p><p>上图中：</p><ul><li>新生代采用复制算法，Stop-The-World</li><li>老年代采用标记-整理算法，Stop-The-World</li></ul><h3 id="ParNew-Scanvenge-收集器"><a href="#ParNew-Scanvenge-收集器" class="headerlink" title="ParNew Scanvenge 收集器"></a>ParNew Scanvenge 收集器</h3><p>类似ParNew，但更加<strong>关注吞吐量</strong>。目标是：达到一个<strong>可控制吞吐量</strong>的收集器。</p><p><strong>停顿时间和吞吐量不可能同时调优</strong>。我们一方买希望停顿时间少，另外一方面希望吞吐量高，其实这是矛盾的。因为：在GC的时候，垃圾回收的工作总量是不变的，如果将停顿时间减少，那频率就会提高；既然频率提高了，说明就会频繁的进行GC，那吞吐量就会减少，性能就会降低。<br><strong>吞吐量</strong>：CPU用于用户代码的时间/CPU总消耗时间的比值，即=运行用户代码的时间/(运行用户代码时间+垃圾收集时间)。比如，虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>是当今收集器发展的最前言成果之一，知道jdk1.7，sun公司才认为它达到了足够成熟的商用程度。</p><p><strong>优点：</strong></p><p>它最大的优点是结合了空间整合，不会产生大量的碎片，也降低了进行gc的频率。</p><p>二是可以让使用者<strong>明确指定指定停顿时间</strong>。（可以指定一个最小时间，超过这个时间，就不会进行回收了）</p><p>它有了这么高效率的原因之一就是：对垃圾回收<strong>进行了划分优先级的操作</strong>，这种有优先级的区域回收方式保证了它的高效率。</p><p>如果你的应用追求停顿，那G1现在已经可以作为一个可尝试的选择；如果你的应用追求吞吐量，那G1并不会为你带来什么特别的好处。</p><p>注：以上所有的收集器当中，当执行GC时，都会stop the world，但是下面的CMS收集器却不会这样。</p><h3 id="CMS收集器（老年代收集器）"><a href="#CMS收集器（老年代收集器）" class="headerlink" title="CMS收集器（老年代收集器）"></a>CMS收集器（老年代收集器）</h3><p>CMS收集器（Concurrent Mark Sweep：<strong>并发标记清除</strong>）是一种<strong>以获取最短回收停顿时间为目标</strong>的收集器。适合应用在互联网站或者B/S系统的服务器上，这类应用尤其重视服务器的响应速度，希望系统停顿时间最短。</p><p><strong>CMS收集器运行过程：</strong>（着重实现了<strong>标记</strong>的过程）</p><ol><li>初始标记</li></ol><ul><li>根可以直接关联到的对象</li><li>速度快</li></ul><ol><li>并发标记（和用户线程一起）</li></ol><ul><li>主要标记过程，标记全部对象</li></ul><ol><li>重新标记</li></ol><ul><li>由于并发标记时，用户线程依然运行，因此在正式清理前，再做修正</li></ul><ol><li>并发清除（和用户线程一起）</li></ol><ul><li>基于标记结果，直接清理对象</li></ul><p>整个过程如下图所示：</p><p><img src="//qn.atecher.com/mts/20180418/3853291045504000" alt="Java-VM-Explanation-1-7"></p><p>上图中，初始标记和重新标记时，需要stop the world。整个过程中耗时最长的是并发标记和并发清除，这两个过程都可以和用户线程一起工作。</p><hr><p><strong>优点：</strong><br>　　并发收集，低停顿<br><strong>缺点：</strong><br>（1）导致用户的执行速度降低。<br>（2）无法处理浮动垃圾。因为它采用的是标记-清除算法。有可能有些垃圾在标记之后，需要等到下一次GC才会被回收。如果CMS运行期间无法满足程序需要，那么就会临时启用Serial Old收集器来重新进行老年代的手机。<br>（3）由于采用的是标记-清除算法，那么就会产生大量的碎片。往往会出现老年代还有很大的空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次full GC</p><p><strong>疑问：</strong></p><p><strong>既然标记-清除算法会造成内存空间的碎片化，CMS收集器为什么使用标记清除算法而不是使用标记整理算法：</strong></p><p><strong>答案：</strong></p><p>CMS收集器更加关注停顿，它在<strong>做GC的时候是和用户线程一起工作的</strong>（并发执行），如果使用标记整理算法的话，那么在清理的时候就会去移动可用对象的内存空间，那么<strong>应用程序的线程就很有可能找不到应用对象在哪里</strong>。</p><h2 id="Java堆内存划分"><a href="#Java堆内存划分" class="headerlink" title="Java堆内存划分"></a>Java堆内存划分</h2><p>根据对象的存活率（年龄），Java对内存划分为3种：新生代、老年代、永久代：</p><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><p>比如我们在方法中去new一个对象，那这方法调用完毕后，对象就会被回收，这就是一个典型的新生代对象。<br>现在的商业虚拟机都采用这种收集算法来回收新生代，新生代中的对象98%都是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将<strong>内存分为一块比较大的Eden空间和两块较小的Survivor空间</strong>，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是说，每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的空间会被浪费。<br>当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，<strong>当Survivor空间不够用时，需要依赖于老年代进行分配担保，所以大对象直接进入老年代</strong>。同时，<strong>长期存活的对象将进入老年代</strong>（虚拟机给每个对象定义一个年龄计数器）。</p><p>来看下面这张图：</p><p><img src="//qn.atecher.com/mts/20180418/3853291046257664" alt="Java-VM-Explanation-1-8"></p><h4 id="Minor-GC和Full-GC"><a href="#Minor-GC和Full-GC" class="headerlink" title="Minor GC和Full GC"></a>Minor GC和Full GC</h4><p>GC分为两种：Minor GC和Full GC</p><p><strong>Minor GC</strong></p><p>Minor GC是发生在新生代中的垃圾收集动作，采用的是复制算法。</p><p>对象在Eden和From区出生后，在经过一次Minor GC后，如果对象还存活，并且能够被to区所容纳，那么在使用复制算法时这些存活对象就会被复制到to区域，然后清理掉Eden区和from区，并将这些对象的年龄设置为1，以后对象在Survivor区每熬过一次Minor GC，就将对象的年龄+1，当对象的年龄达到某个值时（默认是15岁，可以通过参数 –XX:MaxTenuringThreshold设置），这些对象就会成为老年代。</p><p>但这也是不一定的，对于一些较大的对象（即需要分配一块较大的连续内存空间）则是直接进入老年代</p><p><strong>Full GC</strong></p><p>Full GC是发生在老年代的垃圾收集动作，采用的是标记-清除/整理算法。</p><p>老年代里的对象几乎都是在Survivor区熬过来的，不会那么容易死掉。因此Full GC发生的次数不会有Minor GC那么频繁，并且做一次Full GC要比做一次Minor GC的时间要长。</p><p>另外，如果采用的是标记-清除算法的话会产生许多碎片，此后如果需要为较大的对象分配内存空间时，若无法找到足够的连续的内存空间，就会提前触发一次GC。</p><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><p>在新生代中经历了N次垃圾回收后仍然存活的对象就会被放到老年代中。而且大对象直接进入老年代。</p><h3 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h3><p>即方法区。</p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p><h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><p>包括加载、链接（含验证、准备、解析）、初始化。如下图所示：</p><p><img src="//qn.atecher.com/mts/20180418/3853291046355968" alt="Java-VM-Explanation-1-9"></p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>类加载指的是将类的class文件读入内存，并为之创建一个java.lang.<strong>Class对象</strong>，作为方法区<strong>这个类的数据访问的入口</strong>。</p><p>也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。具体包括以下三个部分：</p><p>（1）通过<strong>类的全名</strong>产生对应类的二进制数据流。（根据early load原理，如果没找到对应的类文件，只有在类实际使用时才会抛出错误）<br>（2）分析并将这些二进制数据流转换为方法区方法区特定的数据结构<br>（3）创建对应类的java.lang.Class对象，作为方法区的入口（有了对应的Class对象，并不意味着这个类已经完成了加载链接）</p><p>通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源：</p><p>（1）从本地文件系统加载class文件，这是绝大部分程序的加载方式<br>（2）从jar包中加载class文件，这种方式也很常见，例如jdbc编程时用到的数据库驱动类就是放在jar包中，jvm可以从jar文件中直接加载该class文件<br>（3）通过网络加载class文件<br>（4）把一个Java源文件动态编译、并执行加载</p><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>链接指的是将Java类的二进制文件合并到jvm的运行状态之中的过程。在链接之前，这个类必须被成功加载。<br>类的链接包括<strong>验证、准备、解析</strong>这三步。具体描述如下：</p><h5 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h5><p>验证是用来确保Java类的二进制表示在结构上是否完全正确（如文件格式、语法语义等）。如果验证过程出错的话，会抛出java.lang.VertifyError错误。</p><p>主要验证以下内容：</p><ul><li>文件格式验证</li><li>元数据验证：语义验证</li><li>字节码验证</li></ul><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>准备过程则是创建Java类中的<strong>静态</strong>域（static修饰的内容），并将这些域的值设置为<strong>默认值</strong>，同时在<strong>方法区中分配内存空间</strong>。准备过程并不会执行代码。</p><p>注意这里是做默认初始化，不是做显式初始化。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">12</span>;</span><br></pre></td></tr></table></figure><p>上面的代码中，在<strong>准备阶段</strong>，会给value的值设置为0（<strong>默认初始化</strong>）。在后面的<strong>初始化阶段</strong>才会给value的值设置为12（<strong>显式初始化</strong>）。</p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>解析的过程就是确保这些被引用的类能被正确的找到（将符号引用替换为直接引用）。解析的过程可能会导致其它的Java类被加载。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化阶段是类加载过程的最后一步。到了初始化阶段，才真正执行类中定义的Java程序代码（或者说是字节码）。<br>在以下几种情况中，会执行初始化过程：</p><ol><li>创建类的实例</li><li>访问类或接口的静态变量（<strong>特例：如果是用static final修饰的常量，那就不会对类进行显式初始化。static final 修改的变量则会做显式初始化</strong>）</li><li>调用类的静态方法</li><li>反射（Class.forName(packagename.className)）</li><li>初始化类的子类。注：子类初始化问题：满足主动调用，即<strong>父类访问子类中的静态变量、方法，子类才会初始化</strong>；否则仅父类初始化。</li><li>java虚拟机启动时被标明为启动类的类</li></ol><p><strong>代码举例1</strong></p><p>我们对上面的第（5）种情况做一个代码举例。</p><p>(1)Father.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"*******father init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)Son.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">"*******son init"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>(3)JavaTest.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         System.out.println(Son.a);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上面的测试类中，虽然用上了Son这个类，但是并没有调用子类里的成员，所以并不会对子类进行初始化。于是运行效果是：</p><p><img src="//qn.atecher.com/mts/20180418/3853291047191552" alt="Java-VM-Explanation-1-10"></p><p>如果把JavaTest.java改成下面这个样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         System.out.println(Son.a);</span><br><span class="line">         System.out.println(Son.b);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="//qn.atecher.com/mts/20180418/3853291048797184" alt="Java-VM-Explanation-1-11"></p><p><strong>代码举例2</strong></p><p>我们对上面的第（2）种情况做一个代码举例。即：如果是用static final修饰的常量，则不会进行显式初始化。代码举例如下：</p><p>(1)Father.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">     <span class="keyword">static</span> &#123;</span><br><span class="line">         System.out.println(<span class="string">"*******father init"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>(2)Son.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java学习交流QQ群：589809992 我们一起学Java！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"*******son init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面的变量c是一个静态常量。</p><p>(3)JavaTest.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         System.out.println(Son.c);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="//qn.atecher.com/mts/20180418/3853291048715264" alt="Java-VM-Explanation-1-12"></p><p>上面的运行效果显示，<strong>由于c是final static修饰的静态常量，所以根本就没有调用静态代码块里面的内容，也就是说，没有对这个类进行显式初始化</strong>。<br>现在，保持Father.java的代码不变。将Son.java代码做如下修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java学习交流QQ群：589809992 我们一起学Java！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"*******son init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> c = <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JavaTest.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaTest</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         System.out.println(Son.c);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>运行效果如下：</p><p><img src="//qn.atecher.com/mts/20180418/3853291049092096" alt="Java-VM-Explanation-1-13"></p><p><strong>代码举例3：（很容易出错）</strong><br>我们来下面这段代码的运行结果是什么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java学习交流QQ群：589809992 我们一起学Java！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TestInstance instance = <span class="keyword">new</span> TestInstance();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(TestInstance.a);</span><br><span class="line">        System.out.println(TestInstance.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="//qn.atecher.com/mts/20180418/3853291050943488" alt="Java-VM-Explanation-1-14"></p><p>之所以有这样的运行结果，这里涉及到类加载的顺序：</p><p>（1）在加载阶段，加载类的信息<br>（2）在链接的准备阶段给instance、a、b做默认初始化并分配空间，此时a和b的值都为0<br>（3）在初始化阶段，执行构造方法，此时a和b的值都为1<br>（4）在初始化阶段，给静态变量做显式初始化，此时b的值为0</p><p>我们改一下代码的执行顺序，改成下面这个样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInstance</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TestInstance instance = <span class="keyword">new</span> TestInstance();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a++;</span><br><span class="line">        b++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(TestInstance.a);</span><br><span class="line">        System.out.println(TestInstance.b);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果是：</p><p><img src="//qn.atecher.com/mts/20180418/3853291050828800" alt="Java-VM-Explanation-1-15"></p><p>之所以有这样的运行结果，这里涉及到类加载的顺序：</p><p>（1）在加载阶段，加载类的信息<br>（2）在链接的准备阶段给instance、a、b做默认初始化并分配空间，此时a和b的值都为0<br>（3）在初始化阶段，给静态变量做显式初始化，此时b的值仍为0<br>（4）在初始化阶段，执行构造方法，此时a和b的值都为1</p><p>注意，这里涉及到另外一个类似的知识点不要搞混了。知识点如下。</p><p><strong>知识点：类的初始化过程（重要）</strong></p><p>Student s = new Student();在内存中做了哪些事情?</p><ul><li>加载Student.class文件进内存</li><li>在<strong>栈内存</strong>为s开辟空间</li><li>在<strong>堆内存</strong>为学生对象开辟空间</li><li>对学生对象的成员变量进行<strong>默认初始化</strong></li><li>对学生对象的成员变量进行<strong>显示初始化</strong></li><li>通过<strong>构造方法</strong>对学生对象的<strong>成员变量赋值</strong></li><li>学生对象初始化完毕，把<strong>对象地址赋值给s变量</strong></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先把本文的目录画一个思维导图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;//qn.atecher.com/mts/20180418/3853291052336128&quot; alt=&quot;Java-VM-Explanation-1-1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.atecher.com/categories/Java/"/>
    
    
      <category term="JMM" scheme="http://blog.atecher.com/tags/JMM/"/>
    
      <category term="JVM" scheme="http://blog.atecher.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>浅谈算法和数据结构之快速排序</title>
    <link href="http://blog.atecher.com/2017/10/22/Introduce-Quick-Sort/"/>
    <id>http://blog.atecher.com/2017/10/22/Introduce-Quick-Sort/</id>
    <published>2017-10-22T14:00:10.000Z</published>
    <updated>2022-01-28T10:28:39.115Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章介绍了时间复杂度为O(nlgn)的合并排序，本篇文章介绍时间复杂度同样为O(nlgn)但是排序速度比合并排序更快的快速排序(Quick Sort)。</p><p>快速排序是<a href="http://www.siam.org/pdf/news/637.pdf" target="_blank" rel="noopener">20世纪科技领域的十大算法之一</a> ，他由<a href="http://en.wikipedia.org/wiki/Tony_Hoare" target="_blank" rel="noopener">C. A. R. Hoare</a>于1960年提出的一种划分交换排序。</p><p><a href="//qn.atecher.com/mts/20180418/3853286368494592"><img src="//qn.atecher.com/mts/20180418/3853286368494592" alt="Quick Sort founder"></a></p><a id="more"></a><p>快速排序也是一种采用分治法解决问题的一个典型应用。在很多编程语言中，对数组，列表进行的非稳定排序在内部实现中都使用的是快速排序。而且快速排序在面试中经常会遇到。</p><p>本文首先介绍快速排序的思路，算法的实现、分析、优化及改进，最后分析了.NET 中列表排序的内部实现。</p><h1 id="一-原理"><a href="#一-原理" class="headerlink" title="一 原理"></a>一 原理</h1><p><a href="//qn.atecher.com/mts/20180418/3853286371001344"><img src="//qn.atecher.com/mts/20180418/3853286371001344" alt="Sorting\_quicksort\_anim"></a></p><p>快速排序的基本思想如下：</p><ol><li>对数组进行随机化。</li><li>从数列中取出一个数作为中轴数(pivot)。</li><li>将比这个数大的数放到它的右边，小于或等于它的数放到它的左边。</li><li>再对左右区间重复第三步，直到各区间只有一个数。</li></ol><p><a href="//qn.atecher.com/mts/20180418/3853286371394560"><img src="//qn.atecher.com/mts/20180418/3853286371394560" alt="Basic Step of Quick Sort"></a></p><p>如上图所示快速排序的一个重要步骤是对序列进行以中轴数进行划分，左边都小于这个中轴数，右边都大于该中轴数，然后对左右的子序列继续这一步骤直到子序列长度为1。</p><p>下面来看某一次划分的步骤，如下图：</p><p><a href="//qn.atecher.com/mts/20180418/3853286374802432"><img src="//qn.atecher.com/mts/20180418/3853286374802432" alt="Partition trace in Quick Sort"></a></p><p>上图中的划分操作可以分为以下5个步骤：</p><ol><li>获取中轴元素</li><li>i从左至右扫描，如果小于基准元素，则i自增，否则记下a[i]</li><li>j从右至左扫描，如果大于基准元素，则i自减，否则记下a[j]</li><li>交换a[i]和a[j]</li><li>重复这一步骤直至i和j交错，然后和基准元素比较，然后交换。</li></ol><p>划分过程的代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// &lt;summary&gt;</span></span><br><span class="line"><span class="comment">/// 快速排序中的划分过程</span></span><br><span class="line"><span class="comment">/// &lt;/summary&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name="array"&gt;待划分的数组&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name="lo"&gt;最左侧位置&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;param name="hi"&gt;最右侧位置&lt;/param&gt;</span></span><br><span class="line"><span class="comment">/// &lt;returns&gt;中间元素位置&lt;/returns&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Partition</span><span class="params">(T[] array, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从左至右扫描，如果碰到比基准元素array[lo]小，则该元素已经位于正确的分区，i自增，继续比较i+1；</span></span><br><span class="line">        <span class="comment">//否则，退出循环，准备交换</span></span><br><span class="line">        <span class="keyword">while</span> (array[++i].CompareTo(array[lo]) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果扫描到了最右端，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从右自左扫描，如果碰到比基准元素array[lo]大，则该元素已经位于正确的分区，j自减，继续比较j-1</span></span><br><span class="line">        <span class="comment">//否则，退出循环，准备交换</span></span><br><span class="line">        <span class="keyword">while</span> (array[--j].CompareTo(array[lo]) &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果扫描到了最左端，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果相遇，退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//交换左a[i],a[j]右两个元素，交换完后他们都位于正确的分区</span></span><br><span class="line">        Swap(array, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//经过相遇后，最后一次a[i]和a[j]的交换</span></span><br><span class="line">    <span class="comment">//a[j]比a[lo]小，a[i]比a[lo]大，所以将基准元素与a[j]交换</span></span><br><span class="line">    Swap(array, lo, j);</span><br><span class="line">    <span class="comment">//返回扫描相遇的位置点</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>划分前后，元素在序列中的分布如下图：</p><p><a href="//qn.atecher.com/mts/20180418/3853286379619328"><img src="//qn.atecher.com/mts/20180418/3853286379619328" alt="before and after partition"></a></p><h1 id="二-实现"><a href="#二-实现" class="headerlink" title="二 实现"></a>二 实现</h1><p>与合并算法基于合并这一过程一样，快速排序基于分割(Partition)这一过程。只需要递归调用Partition这一操作，每一次以Partition返回的元素位置来划分为左右两个子序列，然后继续这一过程直到子序列长度为1，代码的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    sort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果子序列为1，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//划分，划分完成之后，分为左右序列，左边所有元素小于array[index]，右边所有元素大于array[index]</span></span><br><span class="line">    <span class="keyword">int</span> index = partition(array, lo, hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对左右子序列进行排序完成之后，整个序列就有序了</span></span><br><span class="line">    <span class="comment">//对左边序列进行递归排序</span></span><br><span class="line">    sort(array, lo, index - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//对右边序列进行递归排序</span></span><br><span class="line">    sort(array, index + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图说明了快速排序中，每一次划分之后的结果：</p><p><a href="//qn.atecher.com/mts/20180418/3853286384108544"><img src="//qn.atecher.com/mts/20180418/3853286384108544" alt="the two part sorted"></a></p><p>一般快速排序的动画如下：</p><p><a href="//qn.atecher.com/mts/20180418/3853286384681984"><img src="//qn.atecher.com/mts/20180418/3853286384681984" alt="quicksort"></a></p><h1 id="三-分析"><a href="#三-分析" class="headerlink" title="三 分析"></a>三 分析</h1><ol><li><p>在最好的情况下，快速排序只需要大约nlgn次比较操作，在最坏的情况下需要大约1/2 n<sup>2</sup> 次比较操作。</p><p>在最好的情况下，每次的划分都会恰好从中间将序列划分开来，那么只需要lgn次划分即可划分完成，是一个标准的分治算法Cn=2Cn/2+N，每一次划分都需要比较N次，大家可以回想下我们是如何证明合并排序的时间复杂度的。</p><p><a href="//qn.atecher.com/mts/20180418/3853286386304000"><img src="//qn.atecher.com/mts/20180418/3853286386304000" alt="the compare complexity in  quick sort at the bese case"></a></p><p>在最坏的情况下，即序列已经排好序的情况下，每次划分都恰好把数组划分成了0，n两部分，那么需要n次划分，但是比较的次数则变成了n, n-1, n-2,….1, 所以整个比较次数约为n(n-1)/2~n<sup>2</sup>/2.</p><p><a href="//qn.atecher.com/mts/20180418/3853286387532800"><img src="//qn.atecher.com/mts/20180418/3853286387532800" alt="the compare complexity in  quick sort at the worst case"></a></p></li><li><p>快速排序平均需要大约2NlnN次比较，来对长度为n的排序关键字唯一的序列进行排序。 证明也比较简单：假设CN为快速排序平均花在比较上的时间，初始C<sub>0</sub>=C<sub>1</sub>=0，对于N&gt;1的情况，有：</p><p><a href="//qn.atecher.com/mts/20180418/3853286332040192"><img src="//qn.atecher.com/mts/20180418/3853286332040192" alt="image"></a></p><p>其中N+1是分割时的比较次数，<a href="//qn.atecher.com/mts/20180418/3853286332974080"><img src="//qn.atecher.com/mts/20180418/3853286332974080" alt="image"></a> 表示将序列分割为0，和N-1左右两部分的概率为1/N, 划分为1，N-2左右两部分的概率也为1/N，都是等概率的。</p><p>然后对上式左右两边同时乘以N，整理得到：</p><p><a href="//qn.atecher.com/mts/20180418/3853286332990464"><img src="//qn.atecher.com/mts/20180418/3853286332990464" alt="image"></a></p><p>然后，对于N为N-1的情况：</p><p><a href="//qn.atecher.com/mts/20180418/3853286340428800"><img src="//qn.atecher.com/mts/20180418/3853286340428800" alt="image"></a></p><p>两式相减，然后整理得到：</p><p><a href="//qn.atecher.com/mts/20180418/3853286340461568"><img src="//qn.atecher.com/mts/20180418/3853286340461568" alt="image"></a></p><p>然后左右两边同时除以N(N+1)，得到:</p><p><a href="//qn.atecher.com/mts/20180418/3853286340609024"><img src="//qn.atecher.com/mts/20180418/3853286340609024" alt="image"></a></p><p>可以看到，这是一个递归式，我们将<a href="//qn.atecher.com/mts/20180418/3853286342181888"><img src="//qn.atecher.com/mts/20180418/3853286342181888" alt="image"></a> 递归展开得到：</p><p><a href="//qn.atecher.com/mts/20180418/3853286342673408"><img src="//qn.atecher.com/mts/20180418/3853286342673408" alt="image"></a></p><p>然后处理一下得到：</p><p><a href="//qn.atecher.com/mts/20180418/3853286344508416"><img src="//qn.atecher.com/mts/20180418/3853286344508416" alt="image"></a></p></li><li>平均情况下，快速排序需要大约1.39NlgN次比较，这比合并排序多了39%的比较，但是由于涉及了较少的数据交换和移动操作，他要比合并排序更快。</li><li>为了避免出现最坏的情况，导致序列划分不均，我们可以首先对序列进行随机化排列然后再进行排序就可以避免这一情况的出现。</li><li>快速排序是一种就地(in-place)排序算法。在分割操作中只需要常数个额外的空间。在递归中，也只需要对数个额外空间。</li><li>另外，快速排序是非稳定性排序。</li></ol><p><a href="//qn.atecher.com/mts/20180418/3853286344705024"><img src="//qn.atecher.com/mts/20180418/3853286344705024" alt="Quick Sort is not Stable"></a></p><h1 id="四-改进"><a href="#四-改进" class="headerlink" title="四 改进"></a>四 改进</h1><p>对一般快速排序进行一些改进可以提高其效率。</p><ol><li>当划分到较小的子序列时，通常可以使用插入排序替代快速排序</li></ol><p>对于较小的子序列（通常序列元素个数为10个左右），我们就可以采用插入排序直接进行排序而不用继续递归，算法改造如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> CUTTOFF = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当划分到较小的子序列时，通常可以使用插入排序替代快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果子序列为1，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//对于小序列，直接采用插入排序替代</span></span><br><span class="line">    <span class="keyword">if</span> (hi - lo &lt;= CUTTOFF - <span class="number">1</span>) &#123;</span><br><span class="line">        InsertionSort.insertionSort(array, lo, hi);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//划分，划分完成之后，分为左右序列，左边所有元素小于array[index]，右边所有元素大于array[index]</span></span><br><span class="line">    <span class="keyword">int</span> index = partition(array, lo, hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对左右子序列进行排序完成之后，整个序列就有序了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对左边序列进行递归排序</span></span><br><span class="line">    sort(array, lo, index - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//对右边序列进行递归排序</span></span><br><span class="line">    sort(array, index + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>三平均分区法(Median of three partitioning)</li></ol><p>在一般的的快速排序中，选择的是第一个元素作为中轴(pivot),这会出现某些分区严重不均的极端情况，比如划分为了1和n-1两个序列，从而导致出现最坏的情况。三平均分区法与一般的快速排序方法不同，它并不是选择待排数组的第一个数作为中轴，而是选用待排数组最左边、最右边和最中间的三个元素的中间值作为中轴。这一改进对于原来的快速排序算法来说，主要有两点优势：</p><p>（1） 首先，它使得最坏情况发生的几率减小了。</p><p>（2） 其次，未改进的快速排序算法为了防止比较时数组越界，在最后要设置一个哨点。如果在分区排序时，中间的这个元素（也即中轴）是与最右边数过来第二个元素进行交换的话，那么就可以省略与这一哨点值的比较。</p><p>对于三平均分区法还可以进一步扩展，在选取中轴值时，可以从由左中右三个中选取扩大到五个元素中或者更多元素中选取，一般的，会有（2t＋1）平均分区法（median-of-(2t+1)。常用的一个改进是，当序列元素小于某个阈值N时，采用三平均分区，当大于时采用5平均分区。</p><p>采用三平均分区法对快速排序的改进如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//采用三平均分区法对快速排序的改进如下</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对于小序列，直接采用插入排序替代</span></span><br><span class="line">    <span class="keyword">if</span> (hi - lo &lt;= CUTTOFF - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//Sort&lt;int&gt;.InsertionSort(array, lo, hi);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//采用三平均分区法查找中轴</span></span><br><span class="line">    <span class="keyword">int</span> m = medianOf3(array, lo, lo + (hi - lo) / <span class="number">2</span>, hi);</span><br><span class="line">    swap(array, lo, m);</span><br><span class="line">    <span class="comment">//划分，划分完成之后，分为左右序列，左边所有元素小于array[index]，右边所有元素大于array[index]</span></span><br><span class="line">    <span class="keyword">int</span> index = partition(array, lo, hi);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对左右子序列进行排序完成之后，整个序列就有序了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对左边序列进行递归排序</span></span><br><span class="line">    sort(array, lo, index - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//对右边序列进行递归排序</span></span><br><span class="line">    sort(array, index + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 查找三个元素中位于中间的那个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">medianOf3</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> lo, <span class="keyword">int</span> center, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (less(array[lo], array[center]) ?</span><br><span class="line">            (less(array[center], array[hi]) ? center : less(array[lo], array[hi]) ? hi : lo) :</span><br><span class="line">            (less(array[hi], array[center]) ? center : less(array[hi], array[lo]) ? hi : lo));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">less</span><span class="params">(<span class="keyword">int</span> t1, <span class="keyword">int</span> t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t1 &lt; t2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用插入排序对小序列进行排序以及使用三平均分区法对一般快速排序进行改进后运行结果示意图如下：</p><p><a href="//qn.atecher.com/mts/20180418/3853286345360384"><img src="//qn.atecher.com/mts/20180418/3853286345360384" alt="Improvement using Insertsort and 3 mediation partition"></a></p><ol><li>三分区(3-way partitioning) 快速排序</li></ol><p>通常，我们的待排序的序列关键字中会有很多重复的值，比如我们想对所有的学生按照年龄进行排序，按照性别进行排序等，这样每一类别中会有很多的重复的值。理论上，这些重复的值只需要处理一次就行了。但是一般的快速排序会递归进行划分，因为一般的快速排序只是将序列划分为了两部分，小于或者大于等于这两部分。</p><p>既然要利用连续、相等的元素不需要再参与排序这个事实，一个直接的想法就是通过划分让相等的元素连续地摆放：</p><p> <a href="//qn.atecher.com/mts/20180418/3853286346785792"><img src="//qn.atecher.com/mts/20180418/3853286346785792" alt="3-way partition quick sort"></a></p><p>然后只对左侧小于V的序列和右侧大于V对的序列进行排序。这种三路划分与计算机科学中无处不在，它与Dijkstra提出的“荷兰国旗问题”(<a href="http://www.iis.sinica.edu.tw/~scm/ncs/2010/10/dutch-national-flag-problem/" target="_blank" rel="noopener">The Dutch National Flag Problem</a>)非常相似。</p><p>Dijkstra的方法如上图：</p><p>从左至右扫描数组，维护一个指针lt使得[lo…lt-1]中的元素都比v小，一个指针gt使得所有[gt+1….hi]的元素都大于v，以及一个指针i，使得所有[lt…i-1]的元素都和v相等。元素[i…gt]之间是还没有处理到的元素，i从lo开始，从左至右开始扫描：</p><p>· 如果a[i]&lt;v: 交换a[lt]和a[i],lt和i自增</p><p>· 如果a[i]&gt;v:交换a[i]和a[gt], gt自减</p><p>· 如果a[i]=v: i自增</p><p>下面是使用Dijkstra的三分区快速排序代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//使用Dijkstra的三分区快速排序代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对于小序列，直接采用插入排序替代</span></span><br><span class="line">    <span class="keyword">if</span> (hi - lo &lt;= CUTTOFF - <span class="number">1</span>) &#123;</span><br><span class="line">        InsertionSort.insertionSort(array, lo, hi);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//三分区</span></span><br><span class="line">    <span class="keyword">int</span> lt = lo, i = lo + <span class="number">1</span>, gt = hi;</span><br><span class="line">    <span class="keyword">int</span> v = array[lo];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= gt) &#123;</span><br><span class="line">        <span class="keyword">int</span> cmp = array[i] - v;</span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) swap(array, lt++, i++);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) swap(array, i, gt--);</span><br><span class="line">        <span class="keyword">else</span> i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对左边序列进行递归排序</span></span><br><span class="line">    sort(array, lo, lt - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//对右边序列进行递归排序</span></span><br><span class="line">    sort(array, gt + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三分区快速排序的每一步如下图所示：</p><p><a href="//qn.atecher.com/mts/20180418/3853286346966016"><img src="//qn.atecher.com/mts/20180418/3853286346966016" alt="3-way partitioning trace"></a></p><p>三分区快速排序的示意图如下：</p><p><a href="//qn.atecher.com/mts/20180418/3853286348096512"><img src="//qn.atecher.com/mts/20180418/3853286348096512" alt="3 way quick sort visual trace"></a></p><p>Dijkstra的三分区快速排序虽然在快速排序发现不久后就提出来了，但是对于序列中重复值不多的情况下，它比传统的2分区快速排序需要更多的交换次数。</p><p>Bentley 和D. McIlroy在普通的三分区快速排序的基础上，对一般的快速排序进行了改进。在划分过程中，i遇到的与v相等的元素交换到最左边，j遇到的与v相等的元素交换到最右边，i与j相遇后再把数组两端与v相等的元素交换到中间</p><p><a href="//qn.atecher.com/mts/20180418/3853286349685760"><img src="//qn.atecher.com/mts/20180418/3853286349685760" alt="Bentley  McIlroy 3 way partition"></a> </p><p>这个方法不能完全满足只扫描一次的要求，但它有两个好处：首先，如果数据中没有重复的值，那么该方法几乎没有额外的开销；其次，如果有重复值，那么这些重复的值不会参与下一趟排序，减少了无用的划分。</p><p>下面是采用 Bentley&amp;D. McIlroy 三分区快速排序的算法改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//采用 Bentley&amp;D. McIlroy 三分区快速排序的算法改进</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对于小序列，直接采用插入排序替代</span></span><br><span class="line">    <span class="keyword">if</span> (hi - lo &lt;= CUTTOFF - <span class="number">1</span>) &#123;</span><br><span class="line">        InsertionSort.insertionSort(array, lo, hi);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Bentley-McIlroy 3-way partitioning</span></span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p = lo, q = hi + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> v = array[lo];</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (less(array[++i], v))</span><br><span class="line">            <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (less(v, array[--j]))</span><br><span class="line">            <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// pointers cross</span></span><br><span class="line">        <span class="keyword">if</span> (i == j &amp;&amp; array[i] == v)</span><br><span class="line">            swap(array, ++p, i);</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        swap(array, i, j);</span><br><span class="line">        <span class="keyword">if</span> (array[i] == v) swap(array, ++p, i);</span><br><span class="line">        <span class="keyword">if</span> (array[j] == v) swap(array, --q, j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将相等的元素交换到中间</span></span><br><span class="line">    i = j + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= p; k++) swap(array, k, j--);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = hi; k &gt;= q; k--) swap(array, k, i++);</span><br><span class="line"></span><br><span class="line">    sort(array, lo, j);</span><br><span class="line">    sort(array, i, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三分区快速排序的动画如下：</p><p><a href="//qn.atecher.com/mts/20180418/3853286350013440"><img src="//qn.atecher.com/mts/20180418/3853286350013440" alt="3wayquick sort"></a></p><p>4.并行化</p><p>和前面讨论对合并排序的改进一样，对所有使用分治法解决问题的算法其实都可以进行并行化，快速排序的并行化改进我在之前的<a href="http://www.cnblogs.com/yangecnu/p/Something-about-Concurrent-and-Parallel-Programming.html" target="_blank" rel="noopener">浅谈并发与并行</a>这篇文章中已经有过介绍，这里不再赘述。</p><h1 id="五-NET-中元素排序的内部实现"><a href="#五-NET-中元素排序的内部实现" class="headerlink" title="五 .NET 中元素排序的内部实现"></a>五 .NET 中元素排序的内部实现</h1><p>快速排序作为一种优秀的排序算法，在很多编程语言的元素内部排序中均有实现，比如Java中对基本数据类型(primitive type)的排序,C++，Matlab，Python，FireFox Javascript等语言中均将快速排序作为其内部元素排序的算法。同样.NET中亦是如此。</p><p>.NET这种对List<t>数组元素进行排序是通过调用Sort方法实现的，其内部则又是通过Array.Sort实现，MSDN上说在<a href="http://msdn.microsoft.com/en-us/library/b0zbh7b6%28v=vs.100%29.aspx" target="_blank" rel="noopener">.NET 4.0及之前的版本</a>，Array.Sort采用的是快速排序，然而在<a href="http://msdn.microsoft.com/en-us/library/b0zbh7b6%28v=vs.110%29.aspx" target="_blank" rel="noopener">.NET 4.5</a>中，则对这一算法进行了改进，采用了名为<a href="http://en.wikipedia.org/wiki/Introsort" target="_blank" rel="noopener">Introspective sort</a> 的算法，即保证在一般情况下达到最快排序速度，又能保证能够在出现最差情况是进行优化。他其实是一种混合算法：</t></p><ul><li>当待分区的元素个数小于16个时，采用插入排序</li><li>当分区次数超过2*logN，N是输入数组的区间大小，则使用堆排序(Heapsort)</li><li>否则，使用快速排序。</li></ul><p>有了Reflector这一神器，我们可以查看.NET中的ArraySort的具体实现:</p><p>Array.Sort这一方法在mscorlib这一程序集中，具体的实现方法有分别针对泛型和普通类型的SortedGenericArray和SortedObjectArray，里面的实现大同小异，我们以SortedGenericArray这个类来作为例子看:</p><p><a href="//qn.atecher.com/mts/20180418/3853286356550656"><img src="//qn.atecher.com/mts/20180418/3853286356550656" alt="ArraySort implementation in .NET\_1"></a></p><p>首先要看的是Sort方法，其实现如下：</p><p><a href="//qn.atecher.com/mts/20180418/3853286358451200"><img src="//qn.atecher.com/mts/20180418/3853286358451200" alt="ArraySort implementation in .NET\_2"></a></p><p>该方法中，首先判断运行的.NET对的版本，如果是4.5及以上版本，则用IntrospectiveSort算法，否则采用限定深度的快速排序算法DepthLimitedQuickSort。先看IntrospectiveSort：</p><p><a href="//qn.atecher.com/mts/20180418/3853286362121216"><img src="//qn.atecher.com/mts/20180418/3853286362121216" alt="ArraySort implementation in .NET\_3"></a></p><p>该方法第一个元素为数组的最左边元素位置，第二个参数为最右边元素位置，第三个参数为2*log2N，继续看方法内部：</p><p><a href="//qn.atecher.com/mts/20180418/3853286364546048"><img src="//qn.atecher.com/mts/20180418/3853286364546048" alt="ArraySort implementation in .NET\_4"></a></p><p>可以看到，当num&lt;=16时，如果元素个数为1,2,3，则直接调用SwapIfGreaterWithItem进行排序了。否则直接调用InsertSort进行插入排序。</p><p>这里面也是一个循环，每循环一下depthLimit就减小1个，如果为0表示划分的次数超过了2logN，则直接调用基排序(HeapSort)，这里面的划分方法PickPivortAndPartitin的实现如下：</p><p><a href="//qn.atecher.com/mts/20180418/3853286368314368"><img src="//qn.atecher.com/mts/20180418/3853286368314368" alt="ArraySort implementation in .NET\_5"></a></p><p>它其实是一个标准的三平均快速排序。可以看到在.NET 4.5中对Quick进行优化的部分主要是在元素个数比较少的时候采用选择插入，并且在递归深度超过2logN的时候，采用基排序。</p><p>下面再来看下在.NET 4.0及以下平台下排序DepthLimitedQuickSort方法的实现：</p><p>从名称中可以看出这是限定深度的快速排序，在第三个参数传进去的是0x20，也就是32。</p><p><a href="//qn.atecher.com/mts/20180418/3853286368658432"><img src="//qn.atecher.com/mts/20180418/3853286368658432" alt="DepthLimitedQuickSort"></a></p><p>可以看到，当划分的次数大于固定的32次的时候，采用了基排序，其他的部分是普通的快速排序。</p><h1 id="六-总结"><a href="#六-总结" class="headerlink" title="六 总结"></a>六 总结</h1><p>由于快速排序在排序算法中具有排序速度快，而且是就地排序等优点，使得在许多编程语言的内部元素排序实现中采用的就是快速排序，本问首先介绍了一般的快速排序，分析了快速排序的时间复杂度，然后就分析了对快速排序的几点改进，包括对小序列采用插入排序替代，三平均划分，三分区划分等改进方法。最后介绍了.NET不同版本下的对元素内部排序的实现。</p><p>快速排序很重要，希望本文对您了解快速排序有所帮助。</p><blockquote><p>本文系转载文章，原作者为yangecnu，原文链接:<a href="http://www.cnblogs.com/yangecnu/p/Introduce-Quick-Sort.html" target="_blank" rel="noopener">请点此处</a>。<br>PS：我将算法的语言实现改为Java，望原作者勿怪。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章介绍了时间复杂度为O(nlgn)的合并排序，本篇文章介绍时间复杂度同样为O(nlgn)但是排序速度比合并排序更快的快速排序(Quick Sort)。&lt;/p&gt;
&lt;p&gt;快速排序是&lt;a href=&quot;http://www.siam.org/pdf/news/637.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;20世纪科技领域的十大算法之一&lt;/a&gt; ，他由&lt;a href=&quot;http://en.wikipedia.org/wiki/Tony_Hoare&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;C. A. R. Hoare&lt;/a&gt;于1960年提出的一种划分交换排序。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;//qn.atecher.com/mts/20180418/3853286368494592&quot;&gt;&lt;img src=&quot;//qn.atecher.com/mts/20180418/3853286368494592&quot; alt=&quot;Quick Sort founder&quot;&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Data Structures" scheme="http://blog.atecher.com/categories/Data-Structures/"/>
    
    
      <category term="Data Structures" scheme="http://blog.atecher.com/tags/Data-Structures/"/>
    
      <category term="Sort" scheme="http://blog.atecher.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>浅谈算法和数据结构之合并排序</title>
    <link href="http://blog.atecher.com/2017/10/21/Introduce-Merge-Sort/"/>
    <id>http://blog.atecher.com/2017/10/21/Introduce-Merge-Sort/</id>
    <published>2017-10-21T14:00:10.000Z</published>
    <updated>2022-01-28T10:28:39.115Z</updated>
    
    <content type="html"><![CDATA[<p>合并排序，顾名思义，就是通过将两个有序的序列合并为一个大的有序的序列的方式来实现排序。合并排序是一种典型的分治算法：首先将序列分为两部分，然后对每一部分进行循环递归的排序，然后逐个将结果进行合并。</p><p><a href="//qn.atecher.com/mts/20180417/3852398591837184"><img src="//qn.atecher.com/mts/20180417/3852398591837184" alt="Definition of Merge Sort"></a> </p><p>合并排序最大的优点是它的时间复杂度为O(nlgn)，这个是我们之前的选择排序和插入排序所达不到的。他还是一种稳定性排序，也就是相等的元素在序列中的相对位置在排序前后不会发生变化。他的唯一缺点是，需要利用额外的N的空间来进行排序。</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><a href="//qn.atecher.com/mts/20180417/3852398592246784"><img src="//qn.atecher.com/mts/20180417/3852398592246784" alt="Merge\_sort\_animation2"></a></p><p>合并排序依赖于合并操作，即将两个已经排序的序列合并成一个序列，具体的过程如下：</p><ol><li>申请空间，使其大小为两个已经排序序列之和，然后将待排序数组复制到该数组中。</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置</li><li>比较复制数组中两个指针所指向的元素，选择相对小的元素放入到原始待排序数组中，并移动指针到下一位置</li><li>重复步骤3直到某一指针达到序列尾</li><li>将另一序列剩下的所有元素直接复制到原始数组末尾</li></ol><p>该过程实现如下，注释比较清楚：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] aux; <span class="comment">// 用于排序的辅助数组</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//把元素拷贝到辅助数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        aux[k] = array[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后按照规则将数据从辅助数组中拷贝回原始的array中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        <span class="comment">//如果左边元素没了， 直接将右边的剩余元素都合并到到原数组中</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid) &#123;</span><br><span class="line">            array[k] = aux[j++];</span><br><span class="line">        &#125;<span class="comment">//如果右边元素没有了，直接将所有左边剩余元素都合并到原数组中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; hi) &#123;</span><br><span class="line">            array[k] = aux[i++];</span><br><span class="line">        &#125;<span class="comment">//如果左边右边小，则将左边的元素拷贝到原数组中</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (aux[i] &lt; aux[j]) &#123;</span><br><span class="line">            array[k] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            array[k] = aux[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图是使用以上方法将ＥＥＧＭＲ和ＡＣＥＲＴ这两个有序序列合并为一个大的序列的过程演示：</p><p><a href="//qn.atecher.com/mts/20180417/3852398592230400"><img src="//qn.atecher.com/mts/20180417/3852398592230400" alt="Merge Step in Merge Sort"></a></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>合并排序有两种实现，一种是至上而下(Top-Down)合并，一种是至下而上 (Bottom-Up)合并，两者算法思想差不多，这里仅介绍至上而下的合并排序。</p><p>至上而下的合并是一种典型的分治算法(Divide-and-Conquer)，如果两个序列已经排好序了，那么采用合并算法，将这两个序列合并为一个大的序列也就是对大的序列进行了排序。</p><p>首先我们将待排序的元素均分为左右两个序列，然后分别对其进去排序，然后对这个排好序的序列进行合并，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    aux = <span class="keyword">new</span> <span class="keyword">int</span>[array.length]; <span class="comment">// 仅分配一次</span></span><br><span class="line">    sort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>; <span class="comment">//如果下标大于上标，则返回</span></span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;<span class="comment">//平分数组</span></span><br><span class="line">    sort(array, lo, mid);<span class="comment">//循环对左侧元素排序</span></span><br><span class="line">    sort(array, mid + <span class="number">1</span>, hi);<span class="comment">//循环对右侧元素排序</span></span><br><span class="line">    merge(array, lo, mid, hi);<span class="comment">//对左右排好的序列进行合并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以排序一个具有15个元素的数组为例，其调用堆栈为：</p><p><a href="//qn.atecher.com/mts/20180417/3852398595326976"><img src="//qn.atecher.com/mts/20180417/3852398595326976" alt="Top-Down merge的调用堆栈"></a></p><p>我们单独将Merge步骤拿出来，可以看到合并的过程如下：</p><p><a href="//qn.atecher.com/mts/20180417/3852398596801536"><img src="//qn.atecher.com/mts/20180417/3852398596801536" alt="Trace of merge reuslt for top-down merge sort"></a></p><h2 id="图示及动画"><a href="#图示及动画" class="headerlink" title="图示及动画"></a>图示及动画</h2><p>如果以排序38,27,43,3,9,82,10为例，将合并排序画出来的话，可以看到如下图：</p><p><a href="//qn.atecher.com/mts/20180417/3852398597260288"><img src="//qn.atecher.com/mts/20180417/3852398597260288" alt="Merge\_sort\_algorithm\_diagram"></a></p><p>下图是合并排序的可视化效果图：</p><p><a href="//qn.atecher.com/mts/20180417/3852398602765312"><img src="//qn.atecher.com/mts/20180417/3852398602765312" alt="Merge Sort Visualization"></a></p><p>对6 5 3 1 8 7 24 进行合并排序的动画效果如下：</p><p><a href="//qn.atecher.com/mts/20180417/3852398603420672"><img src="//qn.atecher.com/mts/20180417/3852398603420672" alt="Merge-sort-example"></a></p><p>下图演示了合并排序在不同的情况下的效率：</p><p><a href="//qn.atecher.com/mts/20180417/3852398604289024"><img src="//qn.atecher.com/mts/20180417/3852398604289024" alt="merge sort"></a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>1.</strong> <strong>合并排序的平均时间复杂度为O(nlgn)</strong></p><p>证明：合并排序是目前我们遇到的第一个时间复杂度不为n<sup>2</sup>的时间复杂度为nlgn(这里lgn代表log2n)的排序算法，下面给出对合并排序的时间复杂度分析的证明：</p><p>假设D(N)为对整个序列进行合并排序所用的时间，那么一个合并排序又可以二分为两个D(N/2)进行排序，再加上与N相关的比较和计算中间数所用的时间。整个合并排序可以用如下递归式表示：</p><p>D(N)=2D(N/2)+N,N&gt;1;</p><p>D(N)=0,N=1; (当N=1时，数组只有1个元素，已排好序，时间为0)</p><p>因为在分治算法中经常会用到递归式，所以在<a href="http://www.amazon.com/Introduction-Algorithms-Thomas-H-Cormen/dp/0262033844" target="_blank" rel="noopener">CLRS</a>中有一章专门讲解递归式的求解和证明，使用<a href="http://en.wikipedia.org/wiki/Master_theorem" target="_blank" rel="noopener">主定理(master theorem)</a>可以直接求解出该递归式的值，后面我会简单介绍。这里简单的列举两种证明该递归式时间复杂度为O(nlgn)的方法：</p><p><strong>Prof1</strong>：处于方便性考虑，我们假设数组N为2的整数幂，这样根据递归式我们可以画出一棵树：</p><p><a href="//qn.atecher.com/mts/20180417/3852398610023424"><img src="//qn.atecher.com/mts/20180417/3852398610023424" alt="merge sort analysis"></a></p><p>可以看到我们对数组N进行MergeSort的时候，是逐级划分的，这样就形成了一个<a href="http://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">满二叉树</a>，树的每一及子节点都为N，树的深度即为层数lgN+1，满二叉树的深度的计算可以查阅相关资料，上图中最后一层子节点没有画出来。这样，这棵树有lgN+1层，每一层有N个节点，所以</p><blockquote><p>D(N)=(lgN+1)N=NlgN+N=NlgN</p></blockquote><p><strong>Prof2</strong>：我们在为递归表达式求解的时候，还有一种常用的方法就是数学归纳法，</p><p>首先根据我们的递归表达式的初始值以及观察，我们猜想D(N)=NlgN.</p><ol><li>当N=1 时，D(1)=0,满足初始条件。</li><li>为便于推导，假设N是2的整数次幂N=2k, 即D(2k)=2klg2k = k*2k</li><li>在N+1 的情况下D(N+1)=D(2k+1)=2k+1lg2k+1=(k+1) * 2k+1,所以假设成立，D(N)=NlgN.</li></ol><p><strong>2.</strong> <strong>合并排序需要额外的长度为N的辅助空间来完成排序</strong></p><p>如果对长度为N的序列进行排序需要&lt;=clogN 的额外空间，认为就是<a href="http://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">就地排序</a>(in place排序)也就是完成该排序操作需要较小的，固定数量的额外辅助内存空间。之前学习过的选择排序，插入排序，希尔排序都是原地排序。</p><p>但是在合并排序中，我们要创建一个大小为N的辅助排序数组来存放初始的数组或者存放合并好的数组，所以需要长度为N的额外辅助空间。当然也有前人已经将合并排序改造为了<a href="http://www.diku.dk/hjemmesider/ansatte/jyrki/Paper/mergesort_NJC.ps" target="_blank" rel="noopener">就地合并排序</a>，但是算法的实现变得比较复杂。</p><p>需要额外N的空间来辅助排序是合并排序的最大缺点，如果在内存比较关心的环境中可能需要采用其他算法。</p><h2 id="几点改进"><a href="#几点改进" class="headerlink" title="几点改进"></a>几点改进</h2><p>对合并排序进行一些改进可以提高合并排序的效率。</p><h3 id="当划分到较小的子序列时，通常可以使用插入排序替代合并排序"><a href="#当划分到较小的子序列时，通常可以使用插入排序替代合并排序" class="headerlink" title="当划分到较小的子序列时，通常可以使用插入排序替代合并排序"></a>当划分到较小的子序列时，通常可以使用插入排序替代合并排序</h3><p>对于较小的子序列（通常序列元素个数为7个左右），我们就可以采用插入排序直接进行排序而不用继续递归了），算法改造如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> CUTOFF = <span class="number">7</span>;<span class="comment">//采用插入排序的阈值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort2</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>; <span class="comment">//如果下标大于上标，则返回</span></span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo + CUTOFF - <span class="number">1</span>) SelectionSort.selectionSort(array, lo, hi);</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;<span class="comment">//平分数组</span></span><br><span class="line">    sort2(array, lo, mid);<span class="comment">//循环对左侧元素排序</span></span><br><span class="line">    sort2(array, mid + <span class="number">1</span>, hi);<span class="comment">//循环对右侧元素排序</span></span><br><span class="line">    merge(array, lo, mid, hi);<span class="comment">//对左右排好的序列进行合并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如果已经排好序了就不用合并了"><a href="#如果已经排好序了就不用合并了" class="headerlink" title="如果已经排好序了就不用合并了"></a>如果已经排好序了就不用合并了</h3><p>当已排好序的左侧的序列的最大值&lt;=右侧序列的最小值的时候，表示整个序列已经排好序了。</p><p><a href="//qn.atecher.com/mts/20180417/3852398611137536"><img src="//qn.atecher.com/mts/20180417/3852398611137536" alt="Stop if already sorted"></a></p><p>算法改动如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort3</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>; <span class="comment">//如果下标大于上标，则返回</span></span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo + CUTOFF - <span class="number">1</span>)SelectionSort.selectionSort(array, lo, hi);</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;<span class="comment">//平分数组</span></span><br><span class="line">    sort3(array, lo, mid);<span class="comment">//循环对左侧元素排序</span></span><br><span class="line">    sort3(array, mid + <span class="number">1</span>, hi);<span class="comment">//循环对右侧元素排序</span></span><br><span class="line">    <span class="keyword">if</span> (array[mid]&lt;=array[mid + <span class="number">1</span>]) <span class="keyword">return</span>;</span><br><span class="line">    merge(array, lo, mid, hi);<span class="comment">//对左右排好的序列进行合并</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并行化"><a href="#并行化" class="headerlink" title="并行化"></a>并行化</h3><p>分治算法通常比较容易进行并行化，在<a href="http://www.cnblogs.com/yangecnu/p/Something-about-Concurrent-and-Parallel-Programming.html" target="_blank" rel="noopener">浅谈并发与并行</a>这篇文章中已经展示了如何对快速排序进行并行化（快速排序在下一篇文章中讲解），合并排序一样，因为我们均分的左右两侧的序列是独立的，所以可以进行并行，值得注意的是，并行化也有一个阈值，当序列长度小于某个阈值的时候，停止并行化能够提高效率，这些详细的讨论在<a href="http://www.cnblogs.com/yangecnu/p/Something-about-Concurrent-and-Parallel-Programming.html" target="_blank" rel="noopener">浅谈并发与并行</a>这篇文章中有详细的介绍了，这里不再赘述。</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>合并排序和快速排序一样都是时间复杂度为nlgn的算法，但是和快速排序相比，合并排序是一种稳定性排序，也就是说排序关键字相等的两个元素在整个序列排序的前后，相对位置不会发生变化，这一特性使得合并排序是稳定性排序中效率最高的一个。在Java中对引用对象进行排序，Perl、C++、Python的稳定性排序的内部实现中，都是使用的合并排序。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文介绍了分治算法中比较典型的一个合并排序算法，这也是我们遇到的第一个时间复杂度为nlgn的排序算法，并简要对算法的复杂度进行的分析，希望本文对您理解合并排序有所帮助，下文将介绍快速排序算法。</p><blockquote><p>本文系转载文章，原作者为yangecnu，原文链接:<a href="http://www.cnblogs.com/yangecnu/p/Introduce-Merge-Sort.html" target="_blank" rel="noopener">请点此处</a>。<br>PS：我将算法的语言实现改为Java，望原作者勿怪。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;合并排序，顾名思义，就是通过将两个有序的序列合并为一个大的有序的序列的方式来实现排序。合并排序是一种典型的分治算法：首先将序列分为两部分，然后对每一部分进行循环递归的排序，然后逐个将结果进行合并。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;//qn.atecher.com/mts/20180417/3852398591837184&quot;&gt;&lt;img src=&quot;//qn.atecher.com/mts/20180417/3852398591837184&quot; alt=&quot;Definition of Merge Sort&quot;&gt;&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;合并排序最大的优点是它的时间复杂度为O(nlgn)，这个是我们之前的选择排序和插入排序所达不到的。他还是一种稳定性排序，也就是相等的元素在序列中的相对位置在排序前后不会发生变化。他的唯一缺点是，需要利用额外的N的空间来进行排序。&lt;/p&gt;
    
    </summary>
    
      <category term="Data Structures" scheme="http://blog.atecher.com/categories/Data-Structures/"/>
    
    
      <category term="Data Structures" scheme="http://blog.atecher.com/tags/Data-Structures/"/>
    
      <category term="Sort" scheme="http://blog.atecher.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>浅谈算法和数据结构之基本排序算法</title>
    <link href="http://blog.atecher.com/2017/10/20/Introduction-Insertion-and-Selection-and-Shell-Sort/"/>
    <id>http://blog.atecher.com/2017/10/20/Introduction-Insertion-and-Selection-and-Shell-Sort/</id>
    <published>2017-10-20T19:00:10.000Z</published>
    <updated>2022-01-28T10:28:39.115Z</updated>
    
    <content type="html"><![CDATA[<p>本篇开始学习排序算法。排序与我们日常生活中息息相关，比如，我们要从电话簿中找到某个联系人首先会按照姓氏排序、买火车票会按照出发时间或者时长排序、买东西会按照销量或者好评度排序、查找文件会按照修改时间排序等等。在计算机程序设计中，排序和查找也是最基本的算法，很多其他的算法都是以排序算法为基础，在一般的数据处理或分析中，通常第一步就是进行排序，比如说二分查找，首先要对数据进行排序。在<a href="https://en.wikipedia.org/wiki/Donald_Knuth" target="_blank" rel="noopener">Donald Knuth</a>。 的计算机程序设计的艺术这四卷书中，有一卷是专门介绍排序和查找的。</p><a id="more"></a><p><a href="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-1.png"><img src="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-1.png" alt=""></a></p><p>排序的算法有很多，在维基百科上有这么一个分类，另外大家有兴趣也可以直接上维基百科上看相关算法，本文也参考了上面的内容。</p><p><a href="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-2.png"><img src="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-2.png" alt=""></a></p><p>首先来看比较简单的选择排序(Selection sort)，插入排序(Insertion sort)，然后在分析插入排序的特征和缺点的基础上，介绍在插入排序基础上改进的希尔排序(Shell sort)。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>选择排序很简单，他的步骤如下：</p><p>从左至右遍历，找到最小(大)的元素，然后与第一个元素交换。<br>从剩余未排序元素中继续寻找最小（大）元素，然后与第二个元素进行交换。<br>以此类推，直到所有元素均排序完毕。<br>之所以称之为选择排序，是因为每一次遍历未排序的序列我们总是从中选择出最小的元素。下面是选择排序的动画演示：</p><p><a href="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-3.gif"><img src="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-3.gif" alt=""></a></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>算法实现起来也很简单，我们新建一个Sort泛型类，让该类型必须实现IComparable接口，然后我们定义SelectionSort方法，方法传入T数组，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 选择排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = array.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="comment">//从第i+1个元素开始，找最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[min] &gt; array[j])</span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到之后和第i个元素交换</span></span><br><span class="line">        swap(array, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> lo,<span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo; i &lt;= hi; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="comment">//从第i+1个元素开始，找最小值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= hi; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[min] &gt; array[j])</span><br><span class="line">                min = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到之后和第i个元素交换</span></span><br><span class="line">        swap(array, i, min);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 元素交换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> min</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> min)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[min];</span><br><span class="line">    array[min] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图分析了选择排序中每一次排序的过程，您可以对照图中右边的柱状图来看。</p><p><a href="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-4.png"><img src="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-4.png" alt=""></a></p><p>测试如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">"Before SelectionSort:"</span>);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">    selectionSort(array);</span><br><span class="line">    System.out.println(<span class="string">"After SelectionSort:"</span>);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p><a href="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-5.png"><img src="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-5.png" alt=""></a></p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>选择排序的在各种初始条件下的排序效果如下：</p><p><a href="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-6.gif"><img src="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-6.gif" alt=""></a></p><ol><li>选择排序需要花费 (N – 1) + (N – 2) + … + 1 + 0 = N(N- 1) / 2 ~ N<sup>2</sup>/2次比较 和 N-1次交换操作。</li><li>对初始数据不敏感，不管初始的数据有没有排好序，都需要经历N<sup>2</sup>/2次比较，这对于一些原本排好序，或者近似排好序的序列来说并不具有优势。在最好的情况下，即所有的排好序，需要0次交换，最差的情况，倒序，需要N-1次交换。</li><li>数据交换的次数较少，如果某个元素位于正确的最终位置上，则它不会被移动。在最差情况下也只需要进行N-1次数据交换，在所有的完全依靠交换去移动元素的排序方法中，选择排序属于比较好的一种。</li></ol><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>插入排序也是一种比较直观的排序方式。可以以我们平常打扑克牌为例来说明，假设我们那在手上的牌都是排好序的，那么插入排序可以理解为我们每一次将摸到的牌，和手中的牌从左到右依次进行对比，如果找到合适的位置则直接插入。具体的步骤为：</p><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素小于前面的元素（已排序），则依次与前面元素进行比较如果小于则交换，直到找到大于该元素的就则停止；</li><li>如果该元素大于前面的元素（已排序），则重复步骤2</li><li>重复步骤2~4 直到所有元素都排好序 。</li></ol><p>下面是插入排序的动画演示：</p><p><a href="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-7.gif"><img src="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-7.gif" alt=""></a></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>在Sort泛型方法中，我们添加如下方法，下面的方法和上面的定义一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = array.length;</span><br><span class="line">    <span class="comment">//从第二个元素开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//从第i个元素开始，一次和前面已经排好序的i-1个元素比较，如果小于，则交换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j]&lt; array[j - <span class="number">1</span>])&#123;</span><br><span class="line">                swap(array, j, j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span><span class="comment">//如果大于，则不用继续往前比较了，因为前面的元素已经排好序，比较大的大就是教大的了。</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-8.gif"><img src="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-8.gif" alt=""></a></p><p>测试如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    System.out.println(<span class="string">"Before SelectionSort:"</span>);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">    insertionSort(array);</span><br><span class="line">    System.out.println(<span class="string">"After SelectionSort:"</span>);</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果:</p><p><a href="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-9.png"><img src="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-9.png" alt=""></a></p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>插入排序的在各种初始条件下的排序效果如下：</p><p><a href="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-10.gif"><img src="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-10.gif" alt=""></a></p><ol><li>插入排序平均需要N<sup>2</sup>/4次比较和N<sup>2</sup>/4 次交换。在最坏的情况下需要N<sup>2</sup>/2次比较和交换；在最好的情况下只需要N-1次比较和0次交换。</li></ol><p><a href="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-11.png"><img src="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-11.png" alt=""></a></p><p>  先考虑最坏情况，那就是所有的元素逆序排列，那么第i个元素需要与前面的i-1个元素进行i-1次比较和交换，所有的加起来大概等于N(N- 1) / 2 ~ N<sup>2</sup> / 2，在数组随机排列的情况下，只需要和前面一半的元素进行比较和交换，所以平均需要N<sup>2</sup>/4次比较和N<sup>2</sup>/4 次交换。</p><p><a href="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-12.png"><img src="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-12.png" alt=""></a></p><p>  在最好的情况下，所有元素都排好序，只需要从第二个元素开始都和前面的元素比较一次即可，不需要交换，所以为N-1次比较和0次交换。</p><ol><li><p>插入排序中，元素交换的次数等于序列中逆序元素的对数。元素比较的次数最少为元素逆序元素的对数，最多为元素逆序的对数 加上数组的个数减1。</p></li><li><p><strong>总体来说，插入排序对于部分有序序列以及元素个数比较小的序列是一种比较有效的方式</strong>。</p></li></ol><p><a href="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-13.png"><img src="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-13.png" alt=""></a></p><p>如上图中，序列AEELMOTRXPS，中逆序的对数为T-R，T-P，T-S，R-P，X-S 6对。典型的部分有序队列的特征有：</p><ul><li>数组中每个元素离最终排好序后的位置不太远</li><li>小的未排序的数组添加到大的已排好序的数组后面</li><li>数组中只有个别元素未排好序</li></ul><p>对于<font color="DarkRed">部分有序数组，插入排序是比较有效的</font>。当数组中逆元素的对数越低，插入排序要比其他排序方法要高效的多。</p><h3 id="选择排序和插入排序的比较"><a href="#选择排序和插入排序的比较" class="headerlink" title="选择排序和插入排序的比较"></a>选择排序和插入排序的比较</h3><p><a href="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-14.png"><img src="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-14.png" alt=""></a></p><p>上图展示了插入排序和选择排序的动画效果。图中灰色的柱子是不用动的，黑色的是需要参与到比较中的，红色的是参与交换的。图中可以看出：</p><p>插入排序不会动右边的元素，选择排序不会动左边的元素；由于插入排序涉及到的未触及的元素要比插入的元素要少，涉及到的<red>比较操作平均要比选择排序少一半</red>。</p><h2 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序(Shell Sort)"></a>希尔排序(Shell Sort)</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>希尔排序也称之为递减增量排序，他是对插入排序的改进。在第二部插入排序中，我们知道，插入排序对于近似已排好序的序列来说，效率很高，可以达到线性排序的效率。但是插入排序效率也是比较低的，他一次只能将数据向前移一位。比如如果一个长度为N的序列，最小的元素如果恰巧在末尾，那么使用插入排序仍需一步一步的向前移动和比较，要N-1次比较和交换。</p><p>希尔排序通过将待比较的元素划分为几个区域来提升插入排序的效率。这样可以让元素可以一次性的朝最终位置迈进一大步，然后算法再取越来越小的步长进行排序，最后一步就是步长为1的普通的插入排序的，但是这个时候，整个序列已经是近似排好序的，所以效率高。</p><p>如下图，我们对下面数组进行排序的时候，首先以4为步长，这是元素分为了LMPT，EHSS，ELOX，AELR几个序列，我们对这几个独立的序列进行插入排序，排序完成之后，我们减小步长继续排序，最后直到步长为1，步长为1即为一般的插入排序，他保证了元素一定会被排序。</p><p><a href="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-15.png"><img src="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-15.png" alt=""></a></p><p>希尔排序的增量递减算法可以随意指定，可以以N/2递减，只要保证最后的步长为1即可。</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = array.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//初始最大步长</span></span><br><span class="line">    <span class="keyword">while</span> (h &lt; n / <span class="number">3</span>) h = h * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//从第二个元素开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//从第i个元素开始，依次次和前面已经排好序的i-h个元素比较，如果小于，则交换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h; j = j - h) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt; (array[j - h])) &#123;</span><br><span class="line">                    swap(array, j, j - h);</span><br><span class="line">                &#125; <span class="keyword">else</span><span class="comment">//如果大于，则不用继续往前比较了，因为前面的元素已经排好序，比较大的大就是教大的了。</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//步长除3递减</span></span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> min)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[min];</span><br><span class="line">    array[min] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，希尔排序的实现是在插入排序的基础上改进的，插入排序的步长为1，每一次递减1，希尔排序的步长为我们定义的h，然后每一次和前面的-h位置上的元素进行比较。算法中，我们首先获取小于N/3 的最大的步长，然后逐步长递减至步长为1的一般的插入排序。</p><p>下面是希尔排序在各种情况下的排序动画：</p><p><a href="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-16.gif"><img src="//qn.atecher.com/Introduction-Insertion-and-Selection-and-Shell-Sort-16.gif" alt=""></a></p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><ol><li><p>希尔排序的关键在于步长递减序列的确定，任何递减至1步长的序列都可以，目前已知的<a href="http://faculty.simpson.edu/lydia.sinapova/www/cmsc250/LN250_Weiss/L12-ShellSort.htm#increments" target="_blank" rel="noopener">比较好的序列有</a>：</p><ul><li>Shell’s 序列: N/2 , N/4 , …, 1 (重复除以2);</li><li>Hibbard’s 序列: 1, 3, 7, …, 2k - 1 ;</li><li>Knuth’s 序列: 1, 4, 13, …, (3k - 1) / 2 ;该序列是本文代码中使用的序列。</li><li>已知最好的序列是 Sedgewick’s (Knuth的学生，Algorithems的作者)的序列: 1, 5, 19, 41, 109, ….</li></ul></li></ol><p>该序列由下面两个表达式交互获得:</p><ul><li>1, 19, 109, 505, 2161,….., 9(4k – 2k) + 1, k = 0, 1, 2, 3,…</li><li>5, 41, 209, 929, 3905,…..2k+2 (2k+2 – 3 ) + 1, k = 0, 1, 2, 3, …</li></ul><p>“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长的希尔排序比插入排序和堆排序都要快，甚至在小数组中比快速排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。</p><ol><li><p>希尔排序的分析比较复杂，使用Hibbard’s 递减步长序列的时间复杂度为O(N<sup>3/2</sup>)，平均时间复杂度大约为O(N<sup>5/4</sup>) ,具体的复杂度目前仍存在争议。</p></li><li><p>实验表明，对于中型的序列(万)，希尔排序的时间复杂度接近最快的排序算法的时间复杂度nlogn。</p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后总结一下本文介绍的三种排序算法的最好最坏和平均时间复杂度。</p><table><thead><tr><th>名称</th><th>最好</th><th>平均</th><th>最坏</th><th>内存占用</th><th>稳定排序 </th></tr></thead><tbody><tr><td>插入排序</td><td>n</td><td>n<sup>2</sup></td><td>n<sup>2</sup></td><td>1</td><td>是</td></tr><tr><td>选择排序</td><td>n<sup>2</sup></td><td>n<sup>2</sup></td><td>n<sup>2</sup></td><td>1</td><td>否</td></tr><tr><td>希尔排序</td><td>n</td><td>nlog<sup>2</sup>n 或 n<sup>3/2</sup></td><td>依赖于增量递减序列目前最好的是 nlog<sup>2</sup>n</td><td>1</td><td>否</td></tr></tbody></table><p>希望本文对您了解以上三个基本的排序算法有所帮助，后面将会介绍合并排序和快速排序。</p><blockquote><p>本文系转载文章，原作者为yangecnu，原文链接:<a href="http://www.cnblogs.com/yangecnu/p/Introduction-Insertion-and-Selection-and-Shell-Sort.html" target="_blank" rel="noopener">请点此处</a><br>PS：我将算法的语言实现改为Java，望原作者勿怪。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇开始学习排序算法。排序与我们日常生活中息息相关，比如，我们要从电话簿中找到某个联系人首先会按照姓氏排序、买火车票会按照出发时间或者时长排序、买东西会按照销量或者好评度排序、查找文件会按照修改时间排序等等。在计算机程序设计中，排序和查找也是最基本的算法，很多其他的算法都是以排序算法为基础，在一般的数据处理或分析中，通常第一步就是进行排序，比如说二分查找，首先要对数据进行排序。在&lt;a href=&quot;https://en.wikipedia.org/wiki/Donald_Knuth&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Donald Knuth&lt;/a&gt;。 的计算机程序设计的艺术这四卷书中，有一卷是专门介绍排序和查找的。&lt;/p&gt;
    
    </summary>
    
      <category term="Data Structures" scheme="http://blog.atecher.com/categories/Data-Structures/"/>
    
    
      <category term="Data Structures" scheme="http://blog.atecher.com/tags/Data-Structures/"/>
    
      <category term="Sort" scheme="http://blog.atecher.com/tags/Sort/"/>
    
  </entry>
  
  <entry>
    <title>浅谈算法和数据结构之平衡查找树之B树</title>
    <link href="http://blog.atecher.com/2017/10/18/Introduce-B-Tree-and-B-Plus-Tree/"/>
    <id>http://blog.atecher.com/2017/10/18/Introduce-B-Tree-and-B-Plus-Tree/</id>
    <published>2017-10-18T19:40:10.000Z</published>
    <updated>2022-01-28T10:28:39.115Z</updated>
    
    <content type="html"><![CDATA[<p>前面讲解了平衡查找树中的2-3树以及其实现红黑树。2-3树种，一个节点最多有2个key，而红黑树则使用染色的方式来标识这两个key。</p><p>维基百科对B树的定义为“在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B-树为系统<strong>最优化大块数据的读和写操作</strong>。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。”</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>B树</strong>可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。</p><ul><li>根节点至少有两个子节点</li><li>每个节点有M-1个key，并且以升序排列</li><li>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间</li><li>其它节点至少有M/2个子节点</li></ul><p>下图是一个M=4 阶的B树:</p><p><a href="//qn.atecher.com/Introduce-B-Tree-and-B-Plus-Tree-1.png"><img src="//qn.atecher.com/Introduce-B-Tree-and-B-Plus-Tree-1.png" alt="image"></a></p><p>可以看到B树是2-3树的一种扩展，他允许一个节点有多于2个的元素。</p><p>B树的插入及平衡化操作和2-3树很相似，这里就不介绍了。下面是往B树中依次插入</p><p><strong>6 10 4 14 5 11 15 3 2 12 1 7 8 8 6 3 6 21 5 15 15 6 32 23 45 65 7 8 6 5 4</strong></p><p>的演示动画：</p><p><a href="//qn.atecher.com/Introduce-B-Tree-and-B-Plus-Tree-2.gif"><img src="//qn.atecher.com/Introduce-B-Tree-and-B-Plus-Tree-2.gif" alt="image"></a></p><p>B+树是对B树的一种变形树，它与B树的差异在于：</p><ul><li>有k个子结点的结点必然有k个关键码；</li><li>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。</li><li>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。<br>如下图，是一个B+树:</li></ul><p><a href="//qn.atecher.com/Introduce-B-Tree-and-B-Plus-Tree-3.png"><img src="//qn.atecher.com/Introduce-B-Tree-and-B-Plus-Tree-3.png" alt="image"></a></p><p>下图是B+树的插入动画：</p><p><a href="//qn.atecher.com/Introduce-B-Tree-and-B-Plus-Tree-4.gif"><img src="//qn.atecher.com/Introduce-B-Tree-and-B-Plus-Tree-4.gif" alt="image"></a></p><p>B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。</p><p>B+ 树的优点在于：</p><ul><li>由于B+树在内部节点上不好含数据信息，因此在内存页中能够存放更多的key。数据存放的更加紧密，具有更好的空间局部性。因此访问叶子几点上关联的数据也具有更好的缓存命中率。</li><li>B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</li></ul><p>但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。下面是B 树和B+树的区别图：</p><p><a href="//qn.atecher.com/Introduce-B-Tree-and-B-Plus-Tree-5.png"><img src="//qn.atecher.com/Introduce-B-Tree-and-B-Plus-Tree-5.png" alt="image"></a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对B树和B+树的分析和对前面讲解的2-3树的分析类似，</p><p>对于一颗节点为N度为M的子树，查找和插入需要log<sub>M-1</sub><sup>N</sup> ~ log<sub>M/2</sub><sup>N</sup>次比较。这个很好证明，对于度为M的B树，每一个节点的子节点个数为M/2到M-1之间，所以树的高度在log<sub>M-1</sub><sup>N</sup>至log<sub>M/2</sub><sup>N</sup>之间。</p><p>这种效率是很高的，对于N=62*1000000000个节点，如果度为1024，则log<sub>M/2</sub><sup>N</sup> &lt;=4，即在620亿个元素中，如果这棵树的度为1024，则只需要小于4次即可定位到该节点，然后再采用二分查找即可找到要找的值。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>B树和B+广泛应用于文件存储系统以及数据库系统中，在讲解应用之前，我们看一下常见的存储结构：</p><p><a href="//qn.atecher.com/Introduce-B-Tree-and-B-Plus-Tree-6.png"><img src="//qn.atecher.com/Introduce-B-Tree-and-B-Plus-Tree-6.png" alt="image"></a></p><p>我们计算机的主存基本都是随机访问存储器(Random-Access Memory，RAM)，他分为两类：静态随机访问存储器（SRAM）和动态随机访问存储器（DRAM）。SRAM比DRAM快，但是也贵的多，一般作为CPU的高速缓存，DRAM通常作为内存。这类存储器他们的结构和存储原理比较复杂，基本是使用电信号来保存信息的，不存在机器操作，所以访问速度非常快，具体的访问原理可以查看CSAPP，另外，他们是易失的，即如果断电，保存DRAM和SRAM保存的信息就会丢失。</p><p>我们使用的更多的是使用磁盘，磁盘能够保存大量的数据，从GB一直到TB级，但是 他的读取速度比较慢，因为涉及到机器操作，读取速度为毫秒级，从DRAM读速度比从磁盘度快10万倍，从SRAM读速度比从磁盘读快100万倍。下面来看下磁盘的结构：</p><p><a href="//qn.atecher.com/Introduce-B-Tree-and-B-Plus-Tree-7.png"><img src="//qn.atecher.com/Introduce-B-Tree-and-B-Plus-Tree-7.png" alt="image"></a></p><p>如上图，磁盘由盘片构成,每个盘片有两面，又称为盘面(Surface)，这些盘面覆盖有磁性材料。盘片中央有一个可以旋转的主轴(spindle)，他使得盘片以固定的旋转速率旋转，通常是5400转每分钟(Revolution Per Minute,RPM)或者是7200RPM。磁盘包含一个多多个这样的盘片并封装在一个密封的容器内。上图左，展示了一个典型的磁盘表面结构。每个表面是由一组成为磁道(track)的同心圆组成的，每个磁道被划分为了一组扇区(sector).每个扇区包含相等数量的数据位，通常是（512）子节。扇区之间由一些间隔(gap)隔开,不存储数据。</p><p>以上是磁盘的物理结构，现在来看下磁盘的读写操作：</p><p><a href="//qn.atecher.com/Introduce-B-Tree-and-B-Plus-Tree-8.png"><img src="//qn.atecher.com/Introduce-B-Tree-and-B-Plus-Tree-8.png" alt="image"></a></p><p>如上图，磁盘用读/写头来读写存储在磁性表面的位，而读写头连接到一个传动臂的一端。通过沿着半径轴前后移动传动臂，驱动器可以将读写头定位到任何磁道上，这称之为寻道操作。一旦定位到磁道后，盘片转动，磁道上的每个位经过磁头时，读写磁头就可以感知到位的值，也可以修改值。对磁盘的访问时间分为 寻道时间，旋转时间，以及传送时间。</p><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，因此为了提高效率，要尽量减少磁盘I/O，减少读写操作。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p><p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p><p><strong>程序运行期间所需要的数据通常比较集中。</strong></p><p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p><p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p><p>文件系统及数据库系统的设计者利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p><p>每次新建一个节点的同时,直接申请一个页的空间(512或者1024)，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。如，将B树的度M设置为1024，这样在前面的例子中，600亿个元素中只需要小于4次查找即可定位到某一存储位置。</p><p>同时在B+树中，内节点只存储导航用到的key，并不存储具体值，这样内节点个数较少，能够全部读取到主存中，外接点存储key及值，并且顺序排列，具有良好的空间局部性。所以B及B+树比较适合与文件系统的数据结构。下面是一颗B树，用来进行内容存储。</p><p><a href="//qn.atecher.com/Introduce-B-Tree-and-B-Plus-Tree-9.png"><img src="//qn.atecher.com/Introduce-B-Tree-and-B-Plus-Tree-9.png" alt="image"></a></p><p>另外B/B+树也经常用做数据库的索引，这方面推荐您直接看张洋的<a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a> 这篇文章，这篇文章对MySQL中的如何使用B+树进行索引有比较详细的介绍，推荐阅读。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在前面两篇文章介绍了平衡查找树中的2-3树，红黑树之后，本文介绍了文件系统和数据库系统中常用的B/B+ 树，他通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。他广泛用于文件系统及数据库中，如：</p><ul><li>Windows：HPFS文件系统</li><li>Mac：HFS，HFS+文件系统</li><li>Linux：ResiserFS，XFS，Ext3FS，JFS文件系统</li><li>数据库：ORACLE，MYSQL，SQLSERVER等中</li></ul><p>希望本文对您了解B/B+ 树有所帮助。</p><blockquote><p>本文系转载文章，原作者为yangecnu，原文链接:<a href="http://www.cnblogs.com/yangecnu/p/Introduce-B-Tree-and-B-Plus-Tree.html" target="_blank" rel="noopener">请点此处</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面讲解了平衡查找树中的2-3树以及其实现红黑树。2-3树种，一个节点最多有2个key，而红黑树则使用染色的方式来标识这两个key。&lt;/p&gt;
&lt;p&gt;维基百科对B树的定义为“在计算机科学中，B树（B-tree）是一种树状数据结构，它能够存储数据、对其进行排序并允许以O(log n)的时间复杂度运行进行查找、顺序读取、插入和删除的数据结构。B树，概括来说是一个节点可以拥有多于2个子节点的二叉查找树。与自平衡二叉查找树不同，B-树为系统&lt;strong&gt;最优化大块数据的读和写操作&lt;/strong&gt;。B-tree算法减少定位记录时所经历的中间过程，从而加快存取速度。普遍运用在数据库和文件系统。”&lt;/p&gt;
    
    </summary>
    
      <category term="Data Structures" scheme="http://blog.atecher.com/categories/Data-Structures/"/>
    
    
      <category term="Data Structures" scheme="http://blog.atecher.com/tags/Data-Structures/"/>
    
      <category term="Tree" scheme="http://blog.atecher.com/tags/Tree/"/>
    
      <category term="B-Tree" scheme="http://blog.atecher.com/tags/B-Tree/"/>
    
  </entry>
  
  <entry>
    <title>浅谈算法和数据结构之平衡查找树之红黑树</title>
    <link href="http://blog.atecher.com/2017/10/18/Introduce-Red-Black-Tree/"/>
    <id>http://blog.atecher.com/2017/10/18/Introduce-Red-Black-Tree/</id>
    <published>2017-10-18T19:00:10.000Z</published>
    <updated>2022-01-28T10:28:39.115Z</updated>
    
    <content type="html"><![CDATA[<p>前面一篇文章介绍了2-3查找树，可以看到，2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgN，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，本文介绍一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）。</p><a id="more"></a><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>红黑树的主要是想对2-3查找树进行编码，尤其是对2-3查找树中的3-nodes节点添加额外的信息。红黑树中将节点之间的链接分为两种不同类型，红色链接，他用来链接两个2-nodes节点来表示一个3-nodes节点。黑色链接用来链接普通的2-3节点。特别的，使用红色链接的两个2-nodes来表示一个3-nodes节点，并且向左倾斜，即一个2-node是另一个2-node的左子节点。这种做法的好处是查找的时候不用做任何修改，和普通的二叉查找树相同。</p><p><a href="//qn.atecher.com/red-black-tree.png"><img src="//qn.atecher.com/red-black-tree.png" alt="image"></a></p><p>根据以上描述，红黑树定义如下：</p><p>红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：</p><ul><li>红色节点向左倾斜</li><li>一个节点不可能有两个红色链接</li><li>整个书完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。</li></ul><p>下图可以看到红黑树其实是2-3树的另外一种表现形式：如果我们将红色的连线水平绘制，那么他链接的两个2-node节点就是2-3树中的一个3-node节点了。</p><p><a href="//qn.atecher.com/red-black-tree-2.png"><img src="//qn.atecher.com/red-black-tree-2.png" alt="image"></a></p><h2 id="表示"><a href="#表示" class="headerlink" title="表示"></a>表示</h2><p>我们可以在二叉查找树的每一个节点上增加一个新的表示颜色的标记。该标记指示该节点指向其父节点的颜色。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">bool</span> RED = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">bool</span> BLACK = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Node root;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Node Left &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Node Right &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> TKey Key &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> TValue Value &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Number &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">bool</span> Color &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Node</span>(<span class="params">TKey key, TValue <span class="keyword">value</span>,<span class="keyword">int</span> number, <span class="keyword">bool</span> color</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.Key = key;</span><br><span class="line">        <span class="keyword">this</span>.Value = <span class="keyword">value</span>;</span><br><span class="line">        <span class="keyword">this</span>.Number = number;</span><br><span class="line">        <span class="keyword">this</span>.Color = color;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">bool</span> <span class="title">IsRed</span>(<span class="params">Node node</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (node == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> node.Color == RED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="//qn.atecher.com/red-black-tree-3.png"><img src="//qn.atecher.com/red-black-tree-3.png" alt="image"></a></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>红黑树是一种特殊的二叉查找树，他的查找方法也和二叉查找树一样，不需要做太多更改。</p><p>但是由于红黑树比一般的二叉查找树具有更好的平衡，所以查找起来更快。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找获取指定的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> override TValue <span class="title">Get</span><span class="params">(TKey key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> GetValue(root, key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> TValue <span class="title">GetValue</span><span class="params">(Node node, TKey key)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">default</span>(TValue);</span><br><span class="line">    <span class="keyword">int</span> cmp = key.CompareTo(node.Key);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>) <span class="keyword">return</span> node.Value;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) <span class="keyword">return</span> GetValue(node.Right, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> GetValue(node.Left, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="平衡化"><a href="#平衡化" class="headerlink" title="平衡化"></a>平衡化</h3><p>在介绍插入之前，我们先介绍如何让红黑树保持平衡，因为一般的，我们插入完成之后，需要对树进行平衡化操作以使其满足平衡化。</p><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>旋转又分为左旋和右旋。通常左旋操作用于将一个向右倾斜的红色链接旋转为向左链接。对比操作前后，可以看出，该操作实际上是将红线链接的两个节点中的一个较大的节点移动到根节点上。</p><p><strong>左旋</strong>操作如下图：</p><p><a href="//qn.atecher.com/red-black-tree-4.png"><img src="//qn.atecher.com/red-black-tree-4.png" alt="image"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//左旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">RotateLeft</span><span class="params">(Node h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node x = h.Right;</span><br><span class="line">    <span class="comment">//将x的左节点复制给h右节点</span></span><br><span class="line">    h.Right = x.Left;</span><br><span class="line">    <span class="comment">//将h复制给x右节点</span></span><br><span class="line">    x.Left = h;</span><br><span class="line">    x.Color = h.Color;</span><br><span class="line">    h.Color = RED;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>左旋</strong>的动画效果如下：<br><a href="//qn.atecher.com/red-black-tree-5.gif"><img src="//qn.atecher.com/red-black-tree-5.gif" alt="image"></a></p><p><strong>右旋</strong>是左旋的逆操作，过程如下：</p><p><a href="//qn.atecher.com/red-black-tree-6.png"><img src="//qn.atecher.com/red-black-tree-6.png" alt="image"></a></p><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//右旋转</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">RotateRight</span><span class="params">(Node h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node x = h.Left;</span><br><span class="line">    h.Left = x.Right;</span><br><span class="line">    x.Right = h;</span><br><span class="line"></span><br><span class="line">    x.Color = h.Color;</span><br><span class="line">    h.Color = RED;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>右旋的动画效果如下：</p><p><a href="//qn.atecher.com/red-black-tree-7.gif"><img src="//qn.atecher.com/red-black-tree-7.gif" alt="image"></a></p><h4 id="颜色反转"><a href="#颜色反转" class="headerlink" title="颜色反转"></a>颜色反转</h4><p>当出现一个临时的4-node的时候，即一个节点的两个子节点均为红色，如下图：</p><p><a href="//qn.atecher.com/red-black-tree-8.png"><img src="//qn.atecher.com/red-black-tree-8.png" alt="image"></a></p><p>这其实是个A，E，S 4-node连接，我们需要将E提升至父节点，操作方法很简单，就是把E对子节点的连线设置为黑色，自己的颜色设置为红色。</p><p>有了以上基本操作方法之后，我们现在对应之前对<strong>2-3树的平衡操作来对红黑树进行平衡操作</strong>，这两者是可以一一对应的，如下图：</p><p><a href="//qn.atecher.com/red-black-tree-9.png"><img src="//qn.atecher.com/red-black-tree-9.png" alt="image"></a></p><p>现在来讨论各种情况：</p><p><strong>Case 1 往一个2-node节点底部插入新的节点</strong></p><p>先热身一下，首先我们看对于只有一个节点的红黑树，插入一个新的节点的操作：</p><p><a href="//qn.atecher.com/red-black-tree-10.png"><img src="//qn.atecher.com/red-black-tree-10.png" alt="image"></a></p><p>这种情况很简单，只需要：</p><ul><li>标准的二叉查找树遍历即可。新插入的节点标记为红色</li><li>如果新插入的节点在父节点的右子节点，则需要进行左旋操作</li></ul><p><strong>Case 2往一个3-node节点底部插入新的节点</strong></p><p>先热身一下，假设我们往一个只有两个节点的树中插入元素，如下图，根据待插入元素与已有元素的大小，又可以分为如下三种情况：</p><p><a href="//qn.atecher.com/red-black-tree-11.png"><img src="//qn.atecher.com/red-black-tree-11.png" alt="image"></a></p><ul><li>如果带插入的节点比现有的两个节点都大，这种情况最简单。我们只需要将新插入的节点连接到右边子树上即可，然后将中间的元素提升至根节点。这样根节点的左右子树都是红色的节点了，我们只需要调研FlipColor方法即可。其他情况经过反转操作后都会和这一样。</li><li>如果插入的节点比最小的元素要小，那么将新节点添加到最左侧，这样就有两个连接红色的节点了，这是对中间节点进行右旋操作，使中间结点成为根节点。这是就转换到了第一种情况，这时候只需要再进行一次FlipColor操作即可。</li><li>如果插入的节点的值位于两个节点之间，那么将新节点插入到左侧节点的右子节点。因为该节点的右子节点是红色的，所以需要进行左旋操作。操作完之后就变成第二种情况了，再进行一次右旋，然后再调用FlipColor操作即可完成平衡操作。</li></ul><p>有了以上基础，我们现在来总结一下往一个3-node节点底部插入新的节点的操作步骤，下面是一个典型的操作过程图：</p><p><a href="//qn.atecher.com/red-black-tree-12.png"><img src="//qn.atecher.com/red-black-tree-12.png" alt="image"></a></p><p>可以看出，操作步骤如下：</p><ol><li>执行标准的二叉查找树插入操作，新插入的节点元素用红色标识。</li><li>如果需要对4-node节点进行旋转操作</li><li>如果需要，调用FlipColor方法将红色节点提升</li><li>如果需要，左旋操作使红色节点左倾。</li><li>在有些情况下，需要递归调用Case1 Case2，来进行递归操作。如下：</li></ol><p><a href="//qn.atecher.com/red-black-tree-13.png"><img src="//qn.atecher.com/red-black-tree-13.png" alt="image"></a></p><p>##代码实现</p><p>经过上面的平衡化讨论，现在就来实现插入操作，一般地插入操作就是先执行标准的二叉查找树插入，然后再进行平衡化。对照2-3树，我们可以通过前面讨论的，左旋，右旋，FlipColor这三种操作来完成平衡化。</p><p><a href="//qn.atecher.com/red-black-tree-14.png"><img src="//qn.atecher.com/red-black-tree-14.png" alt="image"></a></p><p>具体操作方式如下：</p><ul><li>如果节点的右子节点为红色，且左子节点位黑色，则进行左旋操作</li><li>如果节点的左子节点为红色，并且左子节点的左子节点也为红色，则进行右旋操作</li><li>如果节点的左右子节点均为红色，则执行FlipColor操作，提升中间结点。</li></ul><p>根据这一逻辑，我们就可以实现插入的Put方法了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> override <span class="keyword">void</span> <span class="title">Put</span><span class="params">(TKey key, TValue value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    root = Put(root, key, value);</span><br><span class="line">    root.Color = BLACK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">Put</span><span class="params">(Node h, TKey key, TValue value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> Node(key, value, <span class="number">1</span>, RED);</span><br><span class="line">    <span class="keyword">int</span> cmp = key.CompareTo(h.Key);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) h.Left = Put(h.Left, key, value);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>) h.Right = Put(h.Right, key, value);</span><br><span class="line">    <span class="keyword">else</span> h.Value = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//平衡化操作</span></span><br><span class="line">    <span class="keyword">if</span> (IsRed(h.Right) &amp;&amp; !IsRed(h.Left)) h = RotateLeft(h);</span><br><span class="line">    <span class="keyword">if</span> (IsRed(h.Right) &amp;&amp; IsRed(h.Left.Left)) h = RotateRight(h);</span><br><span class="line">    <span class="keyword">if</span> (IsRed(h.Left) &amp;&amp; IsRed(h.Right)) h = FlipColor(h);</span><br><span class="line"></span><br><span class="line">    h.Number = Size(h.Left) + Size(h.Right) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">Size</span><span class="params">(Node node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> node.Number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>对红黑树的分析其实就是对2-3查找树的分析，红黑树能够保证符号表的所有操作即使在最坏的情况下都能保证对数的时间复杂度，也就是树的高度。</p><p>在分析之前，为了更加直观，下面是以升序，降序和随机构建一颗红黑树的动画：</p><p>以升序插入构建红黑树：</p><p><a href="//qn.atecher.com/red-black-tree-15.gif"><img src="//qn.atecher.com/red-black-tree-15.gif" alt="image"></a></p><p>以降序插入构建红黑树：</p><p><a href="//qn.atecher.com/red-black-tree-16.gif"><img src="//qn.atecher.com/red-black-tree-16.gif" alt="image"></a></p><p>随机插入构建红黑树</p><p><a href="//qn.atecher.com/red-black-tree-17.gif"><img src="//qn.atecher.com/red-black-tree-17.gif" alt="image"></a></p><p>从上面三张动画效果中，可以很直观的看出，红黑树在各种情况下都能维护良好的平衡性，从而能够保证最差情况下的查找，插入效率。</p><p>下面来详细分析下红黑树的效率：</p><p>1.在最坏的情况下，红黑树的高度不超过2lgN<br>最坏的情况就是，红黑树中除了最左侧路径全部是由3-node节点组成，即红黑相间的路径长度是全黑路径长度的2倍。</p><p>下图是一个典型的红黑树，从中可以看到最长的路径(红黑相间的路径)是最短路径的2倍：</p><p><a href="//qn.atecher.com/red-black-tree-18.png"><img src="//qn.atecher.com/red-black-tree-18.png" alt="image"></a></p><ol><li>红黑树的平均高度大约为lgN<br>下图是红黑树在各种情况下的时间复杂度，可以看出红黑树是2-3查找树的一种实现，他能保证最坏情况下仍然具有对数的时间复杂度。</li></ol><p>下图是红黑树各种操作的时间复杂度。</p><p><a href="//qn.atecher.com/red-black-tree-19.png"><img src="//qn.atecher.com/red-black-tree-19.png" alt="image"></a></p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>红黑树这种数据结构应用十分广泛，在多种编程语言中被用作符号表的实现，如：</p><p>Java中的java.util.TreeMap,java.util.TreeSet<br>C++ STL中的：map,multimap,multiset<br>.NET中的：SortedDictionary,SortedSet 等<br>下面以.NET中为例，通过Reflector工具，我们可以看到SortedDictionary的Add方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(T item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.root == <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.root = <span class="keyword">new</span> Node&lt;T&gt;(item, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Node&lt;T&gt; root = <span class="keyword">this</span>.root;</span><br><span class="line">        Node&lt;T&gt; node = <span class="keyword">null</span>;</span><br><span class="line">        Node&lt;T&gt; grandParent = <span class="keyword">null</span>;</span><br><span class="line">        Node&lt;T&gt; greatGrandParent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            num = <span class="keyword">this</span>.comparer.Compare(item, root.Item);</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.root.IsRed = <span class="keyword">false</span>;</span><br><span class="line">                ThrowHelper.ThrowArgumentException(ExceptionResource.Argument_AddingDuplicate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (TreeSet&lt;T&gt;.Is4Node(root))</span><br><span class="line">            &#123;</span><br><span class="line">                TreeSet&lt;T&gt;.Split4Node(root);</span><br><span class="line">                <span class="keyword">if</span> (TreeSet&lt;T&gt;.IsRed(node))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">this</span>.InsertionBalance(root, ref node, grandParent, greatGrandParent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            greatGrandParent = grandParent;</span><br><span class="line">            grandParent = node;</span><br><span class="line">            node = root;</span><br><span class="line">            root = (num &lt; <span class="number">0</span>) ? root.Left : root.Right;</span><br><span class="line">        &#125;</span><br><span class="line">        Node&lt;T&gt; current = <span class="keyword">new</span> Node&lt;T&gt;(item);</span><br><span class="line">        <span class="keyword">if</span> (num &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node.Right = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            node.Left = current;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node.IsRed)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.InsertionBalance(current, ref node, grandParent, greatGrandParent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.root.IsRed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">this</span>.count++;</span><br><span class="line">        <span class="keyword">this</span>.version++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，内部实现也是一个红黑树，其操作方法和本文将的大同小异，感兴趣的话，您可以使用Reflector工具跟进去查看源代码。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前文讲解了自平衡查找树中的2-3查找树，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。</p><p>希望本文对您了解红黑树有所帮助，下文将介绍在文件系统以及数据库系统中应用非常广泛的另外一种平衡树结构：<strong>B树</strong>。</p><blockquote><p>本文系转载文章，原作者为yangecnu，原文链接:<a href="http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html" target="_blank" rel="noopener">请点此处</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面一篇文章介绍了2-3查找树，可以看到，2-3查找树能保证在插入元素之后能保持树的平衡状态，最坏情况下即所有的子节点都是2-node，树的高度为lgN，从而保证了最坏情况下的时间复杂度。但是2-3树实现起来比较复杂，本文介绍一种简单实现2-3树的数据结构，即红黑树（Red-Black Tree）。&lt;/p&gt;
    
    </summary>
    
      <category term="Data Structures" scheme="http://blog.atecher.com/categories/Data-Structures/"/>
    
    
      <category term="Data Structures" scheme="http://blog.atecher.com/tags/Data-Structures/"/>
    
      <category term="Tree" scheme="http://blog.atecher.com/tags/Tree/"/>
    
  </entry>
  
  <entry>
    <title>Java-接口和抽象类</title>
    <link href="http://blog.atecher.com/2017/10/13/Java-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>http://blog.atecher.com/2017/10/13/Java-接口和抽象类/</id>
    <published>2017-10-13T00:00:00.000Z</published>
    <updated>2022-01-28T10:28:39.119Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中,可以通过两种形式来体现OOP的抽象:接口和抽象类。这两者有太多相似的地方,又有太多不同的地方。很多人在初学的时候会以为它们可以随意互换使用,但是实际则不然。</p><a id="more"></a><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>在了解抽象类之前,先来了解一下抽象方法。抽象方法是一种特殊的方法:它只有声明,而没有具体的实现。抽象方法的声明格式为:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>抽象方法必须用abstract关键字进行修饰。如果一个类含有抽象方法,则称这个类为抽象类,抽象类必须在类前用abstract关键字修饰。<strong>因为抽象类中含有无具体实现的方法,所以不能用抽象类创建对象</strong></p><p>下面要注意一个问题:在《JAVA编程思想》一书中,将抽象类定义为“包含抽象方法的类”,但是后面发现如果一个类不包含抽象方法,只是用abstract修饰的话也是抽象类。<strong>也就是说抽象类不一定必须含有抽象方法</strong>。个人觉得这个属于钻牛角尖的问题吧,因为如果一个抽象类不包含任何抽象方法,为何还要设计为抽象类？所以暂且记住这个概念吧,不必去深究为什么。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>] <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这里可以看出,抽象类就是为了继承而存在的,如果你定义了一个抽象类,却不去继承它,那么等于白白创建了这个抽象类,因为你不能用它来做任何事情。对于一个父类,如果它的某个方法在父类中实现出来没有任何意义,必须根据子类的实际需求来进行不同的实现,那么就可以将这个方法声明为abstract方法,此时这个类也就成为abstract类了。</p><p>包含抽象方法的类称为抽象类,但并不意味着抽象类中只能有抽象方法,它和普通类一样,同样可以拥有成员变量和普通的成员方法。注意,抽象类和普通类的主要有三点区别:</p><ol><li>抽象方法必须为public或者protected（因为如果为private,则不能被子类继承,子类便无法实现该方法）,缺省情况下默认为public。</li><li>抽象类不能用来创建对象；</li><li>如果一个类继承于一个抽象类,则子类必须实现父类的抽象方法。如果子类没有实现父类的抽象方法,则必须将子类也定义为为abstract类。</li></ol><p>在其他方面,抽象类和普通的类并没有区别。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口,英文称作interface,在软件工程中,接口泛指供别人调用的方法或者函数。从这里,我们可以体会到Java语言设计者的初衷,它是<strong>对行为的抽象</strong>。在Java中,定一个接口的形式如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">public</span>] <span class="class"><span class="keyword">interface</span> <span class="title">InterfaceName</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口中可以含有 变量和方法。但是要注意,接口中的变量会被隐式地指定为public static final变量（并且只能是public static final变量,用private修饰会报编译错误）,而方法会被隐式地指定为public abstract方法且只能是public abstract方法（用其他关键字,比如private、protected、static、 final等修饰会报编译错误）,并且接口中所有的方法不能有具体的实现,也就是说,接口中的方法必须都是抽象方法。从这里可以隐约看出接口和抽象类的区别,接口是一种极度抽象的类型,它比抽象类更加“抽象”,并且一般情况下不在接口中定义变量。</p><p>要让一个类遵循某组特地的接口需要使用implements关键字,具体格式如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class ClassName implements Interface1,Interface2,[....]&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出,允许一个类遵循多个特定的接口。如果一个非抽象类遵循了某个接口,就必须实现该接口中的所有方法。对于遵循某个接口的抽象类,可以不实现该接口中的抽象方法。</p><h2 id="抽象类和接口的区别"><a href="#抽象类和接口的区别" class="headerlink" title="抽象类和接口的区别"></a>抽象类和接口的区别</h2><h3 id="语法层面上的区别"><a href="#语法层面上的区别" class="headerlink" title="语法层面上的区别"></a>语法层面上的区别</h3><ol><li>抽象类可以提供成员方法的实现细节,而接口中只能存在public abstract 方法；</li><li>抽象类中的成员变量可以是各种类型的,而接口中的成员变量只能是public static final类型的；</li><li>接口中不能含有静态代码块以及静态方法,而抽象类可以有静态代码块和静态方法；</li><li>一个类只能继承一个抽象类,而一个类却可以实现多个接口。</li></ol><h3 id="设计层面上的区别"><a href="#设计层面上的区别" class="headerlink" title="设计层面上的区别"></a>设计层面上的区别</h3><ol><li><p><strong>抽象类是对一种事物的抽象,即对类抽象,而接口是对行为的抽象</strong>。抽象类是对整个类整体进行抽象,包括属性、行为,但是接口却是对类局部（行为）进行抽象。举个简单的例子,飞机和鸟是不同类的事物,但是它们都有一个共性,就是都会飞。那么在设计的时候,可以将飞机设计为一个类Airplane,将鸟设计为一个类Bird,但是不能将 飞行 这个特性也设计为类,因此它只是一个行为特性,并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly,包含方法fly( ),然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机,比如战斗机、民用飞机等直接继承Airplane即可,对于鸟也是类似的,不同种类的鸟直接继承Bird类即可。从这里可以看出,继承是一个 “是不是”的关系,而 接口 实现则是 “有没有”的关系。如果一个类继承了某个抽象类,则子类必定是抽象类的种类,而接口实现则是有没有、具备不具备的关系,比如鸟是否能飞（或者是否具备飞行这个特点）,能飞行则可以实现这个接口,不能飞行就不实现这个接口。</p></li><li><p><strong>设计层面不同,抽象类作为很多子类的父类,它是一种模板式设计。而接口是一种行为规范,它是一种辐射式设计</strong>。什么是模板式设计？最简单例子,大家都用过ppt里面的模板,如果用模板A设计了ppt B和ppt C,ppt B和ppt C公共的部分就是模板A了,如果它们的公共部分需要改动,则只需要改动模板A就可以了,不需要重新对ppt B和ppt C进行改动。而辐射式设计,比如某个电梯都装了某种报警器,一旦要更新报警器,就必须全部更新。也就是说对于抽象类,如果需要添加新的方法,可以直接在抽象类中添加具体的实现,子类可以不进行变更；而对于接口则不行,如果接口进行了变更,则所有实现这个接口的类都必须进行相应的改动。</p></li></ol><p>下面看一个网上流传最广泛的例子:门和警报的例子:门都有open( )和close( )两个动作,此时我们可以定义通过抽象类和接口来定义这个抽象概念:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>or<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是现在如果我们需要门具有报警alarm( )的功能,那么该如何实现？下面提供两种思路:</p><ol><li>将这三个功能都放在抽象类里面,但是这样一来所有继承于这个抽象类的子类都具备了报警功能,但是有的门并不一定具备报警功能；</li><li>将这三个功能都放在接口里面,需要用到报警功能的类就需要实现这个接口中的open( )和close( ),也许这个类根本就不具备open( )和close( )这两个功能,比如火灾报警器。</li></ol><p>从这里可以看出, Door的open() 、close()和alarm()根本就属于两个不同范畴内的行为,open()和close()属于门本身固有的行为特性,而alarm()属于延伸的附加行为。因此最好的解决办法是单独将报警设计为一个接口,包含alarm()行为,Door设计为单独的一个抽象类,包含open和close两种行为。再设计一个报警门继承Door类和实现Alarm接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Alram</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Door</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AlarmDoor</span> <span class="keyword">extends</span> <span class="title">Door</span> <span class="keyword">implements</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">oepn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">alarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ref: <a href="http://www.cnblogs.com/dolphin0520/p/3811437.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3811437.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java中,可以通过两种形式来体现OOP的抽象:接口和抽象类。这两者有太多相似的地方,又有太多不同的地方。很多人在初学的时候会以为它们可以随意互换使用,但是实际则不然。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.atecher.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.atecher.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-索引</title>
    <link href="http://blog.atecher.com/2017/10/13/Mysql-%E7%B4%A2%E5%BC%95/"/>
    <id>http://blog.atecher.com/2017/10/13/Mysql-索引/</id>
    <published>2017-10-13T00:00:00.000Z</published>
    <updated>2022-01-28T10:28:39.123Z</updated>
    
    <content type="html"><![CDATA[<p>一直是想知道一条SQL语句是怎么被执行的,它执行的顺序是怎样的。本文将从MySQL总体架构—&gt;查询执行流程—&gt;语句执行顺序来探讨一下其中的知识</p><a id="more"></a><h2 id="索引类型（按用途非严格划分）"><a href="#索引类型（按用途非严格划分）" class="headerlink" title="索引类型（按用途非严格划分）"></a>索引类型（按用途非严格划分）</h2><ul><li>普通索引，这是最基本的索引，无任何限制</li><li>唯一索引，与普通索引类似，索引列值必须唯一，允许NULL值</li><li>全文索引，基于词干方式创建索引，多用于BLOB数据类型</li><li>单列索引，仅基于一列创建的索引</li><li>多列索引，基于多列创建的索引，列顺序非常重要</li><li>空间索引，用作地理数据存储</li><li>主键索引，是一种特殊的唯一索引，不允许有NULL值，通常在建表时创建。</li></ul><h2 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h2><h3 id="索引的优点"><a href="#索引的优点" class="headerlink" title="索引的优点"></a>索引的优点</h3><ul><li>大大减少了服务器需要扫描的数据量</li><li>可以帮助服务器避免排序或减少使用临时表排序</li><li>索引可以随机I/O变为顺序I/O</li></ul><h3 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h3><ul><li>需要占用磁盘空间，因此冗余低效的索引将占用大量的磁盘空间</li><li>降低DML性能，对于数据的任意增删改都需要调整对应的索引，甚至出现索引分裂</li><li>索引会产生相应的碎片，产生维护开销</li></ul><h2 id="索引失效的情形"><a href="#索引失效的情形" class="headerlink" title="索引失效的情形"></a>索引失效的情形</h2><ul><li>请表上的数据行超出表总记录数30%，变成全表扫描</li><li>谓词上的索引列上存在NULL值</li><li>谓词上的索引列条件使用函数</li><li>谓词上的索引列条件进行了相关运算</li><li>负向查询<code>（not  , not in, not like, &lt;&gt;, != ,!&gt;,!&lt;  ）</code>不会使用索引</li><li>复合索引中，第一个索引列使用范围查询–只能用到部份或无法使用索引</li><li>复合索引中，第一个查询条件不是最左索引列</li><li>模糊查询条件列最左以通配符%开始</li><li>内存表（HEAP表）使用HASH索引时，使用范围检索或者ORDER BY</li><li>表关联字段类型不一样（包括某些长度不一样，但像varchar(10)与char(10)则可以，MYSQL经过内部优化处理）</li><li>如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引</li><li>如果mysql估计使用全表扫描要比使用索引快,则不使用索引</li><li>如果条件中有or(并且其中有or的条件是不带索引的)，即使其中有条件带索引也不会使用(这也是为什么尽量少用or的原因)。注意：要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引</li><li>在ORDER BY操作中，MYSQL只有在排序条件不是一个查询条件表达式的情况下才使用索引。尽管如此，在涉及多个数据表的查询里，即使有索引可用，那些索引在加快ORDER BY操作方面也没什么作用</li></ul><p>ps: 如果某个数据列里包含着许多重复的值，就算为它建立了索引也不会有很好的效果。比如说，如果某个数据列里包含了净是些诸如“0/1”或“Y/N”等值，就没有必要为它创建一个索引。</p><p>疑问: <a href="http://www.cnblogs.com/jyk/archive/2010/04/10/1708945.html" target="_blank" rel="noopener">http://www.cnblogs.com/jyk/archive/2010/04/10/1708945.html</a><br><a href="http://www.cnblogs.com/yuerdongni/p/4255395.html" target="_blank" rel="noopener">http://www.cnblogs.com/yuerdongni/p/4255395.html</a></p><p>补充: <a href="http://blog.sina.com.cn/s/blog_6e322ce7010101i7.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_6e322ce7010101i7.html</a><br><a href="https://www.2cto.com/database/201208/145888.html" target="_blank" rel="noopener">https://www.2cto.com/database/201208/145888.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直是想知道一条SQL语句是怎么被执行的,它执行的顺序是怎样的。本文将从MySQL总体架构—&amp;gt;查询执行流程—&amp;gt;语句执行顺序来探讨一下其中的知识&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.atecher.com/categories/Java/"/>
    
    
      <category term="Mysql" scheme="http://blog.atecher.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql-SQL解析顺序</title>
    <link href="http://blog.atecher.com/2017/10/12/Mysql-SQL%E8%A7%A3%E6%9E%90%E9%A1%BA%E5%BA%8F/"/>
    <id>http://blog.atecher.com/2017/10/12/Mysql-SQL解析顺序/</id>
    <published>2017-10-12T00:00:00.000Z</published>
    <updated>2022-01-28T10:28:39.123Z</updated>
    
    <content type="html"><![CDATA[<p>一直是想知道一条SQL语句是怎么被执行的,它执行的顺序是怎样的<br>本文将从MySQL总体架构—&gt;查询执行流程—&gt;语句执行顺序来探讨一下其中的知识</p><a id="more"></a><h2 id="MySQL架构总览"><a href="#MySQL架构总览" class="headerlink" title="MySQL架构总览"></a>MySQL架构总览</h2><p>下图根据参考书籍中一图为原本,再在其上添加上了自己的理解。</p><p><a href="//qn.atecher.com/701942-20151210224128402-1287669438.png"><img src="//qn.atecher.com/701942-20151210224128402-1287669438.png" alt=""></a></p><p>从上图中我们可以看到,整个架构分为两层,上层是MySQLD的被称为的‘SQL Layer’,下层是各种各样对上提供接口的存储引擎,被称为‘Storage Engine Layer’。其它各个模块和组件,从名字上就可以简单了解到它们的作用,这里就不再累述了。</p><h2 id="查询执行流程"><a href="#查询执行流程" class="headerlink" title="查询执行流程"></a>查询执行流程</h2><p>下面再向前走一些,容我根据自己的认识说一下查询执行的流程是怎样的:</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><ol><li>客户端发起一条Query请求,监听客户端的‘连接管理模块’接收请求</li><li>将请求转发到‘连接进/线程模块’</li><li>调用‘用户模块’来进行授权检查</li><li>通过检查后,‘连接进/线程模块’从‘线程连接池’中取出空闲的被缓存的连接线程和客户端请求对接,如果失败则创建一个新的连接请求</li></ol><h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><ol><li>先查询缓存,检查Query语句是否完全匹配,接着再检查是否具有权限,都成功则直接取数据返回</li><li>上一步有失败则转交给‘命令解析器’,经过词法分析,语法分析后生成解析树</li><li>接下来是预处理阶段,处理解析器无法解决的语义,检查权限等,生成新的解析树</li><li>再转交给对应的模块处理</li><li>如果是SELECT查询还会经由‘查询优化器’做大量的优化,生成执行计划</li><li>模块收到请求后,通过‘访问控制模块’检查所连接的用户是否有访问目标表和目标字段的权限</li><li>有则调用‘表管理模块’,先是查看table cache中是否存在,有则直接对应的表和获取锁,否则重新打开表文件</li><li>根据表的meta数据,获取表的存储引擎类型等信息,通过接口调用对应的存储引擎处理</li><li>上述过程中产生数据变化的时候,若打开日志功能,则会记录到相应二进制日志文件中</li></ol><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><ol><li>Query请求完成后,将结果集返回给‘连接进/线程模块’</li><li>返回的也可以是相应的状态标识,如成功或失败等</li><li>‘连接进/线程模块’进行后续的清理工作,并继续等待请求或断开与客户端的连接</li></ol><p><a href="//qn.atecher.com/701942-20151210224221011-1559007674.png"><img src="//qn.atecher.com/701942-20151210224221011-1559007674.png" alt=""></a></p><h2 id="SQL解析顺序"><a href="#SQL解析顺序" class="headerlink" title="SQL解析顺序"></a>SQL解析顺序</h2><p>首先看一下示例语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SELECT DISTINCT</span><br><span class="line">    &lt; select_list &gt;</span><br><span class="line">FROM</span><br><span class="line">    &lt; left_table &gt; &lt; join_type &gt;</span><br><span class="line">JOIN &lt; right_table &gt; ON &lt; join_condition &gt;</span><br><span class="line">WHERE</span><br><span class="line">    &lt; where_condition &gt;</span><br><span class="line">GROUP BY</span><br><span class="line">    &lt; group_by_list &gt;</span><br><span class="line">HAVING</span><br><span class="line">    &lt; having_condition &gt;</span><br><span class="line">ORDER BY</span><br><span class="line">    &lt; order_by_condition &gt;</span><br><span class="line">LIMIT &lt; limit_number &gt;</span><br></pre></td></tr></table></figure></p><p>然而它的执行顺序是这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;left_table&gt;</span><br><span class="line">ON &lt;join_condition&gt;</span><br><span class="line">&lt;join_type&gt; JOIN &lt;right_table&gt;</span><br><span class="line">WHERE &lt;where_condition&gt;</span><br><span class="line">GROUP BY &lt;group_by_list&gt;</span><br><span class="line">HAVING &lt;having_condition&gt;</span><br><span class="line">SELECT </span><br><span class="line">DISTINCT &lt;select_list&gt;</span><br><span class="line">ORDER BY &lt;order_by_condition&gt;</span><br><span class="line">LIMIT &lt;limit_number&gt;</span><br></pre></td></tr></table></figure></p><p>一步步来看看其中的细节吧</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>1.创建测试数据库<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database testQuery</span><br></pre></td></tr></table></figure></p><p>2.创建测试表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table1</span><br><span class="line">(</span><br><span class="line">    uid VARCHAR(10) NOT NULL,</span><br><span class="line">    name VARCHAR(10) NOT NULL,</span><br><span class="line">    PRIMARY KEY(uid)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=UTF8;</span><br><span class="line"></span><br><span class="line">CREATE TABLE table2</span><br><span class="line">(</span><br><span class="line">    oid INT NOT NULL auto_increment,</span><br><span class="line">    uid VARCHAR(10),</span><br><span class="line">    PRIMARY KEY(oid)</span><br><span class="line">)ENGINE=INNODB DEFAULT CHARSET=UTF8;</span><br></pre></td></tr></table></figure></p><p>3.插入数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO table1(uid,name) VALUES(&apos;aaa&apos;,&apos;mike&apos;),(&apos;bbb&apos;,&apos;jack&apos;),(&apos;ccc&apos;,&apos;mike&apos;),(&apos;ddd&apos;,&apos;mike&apos;);</span><br><span class="line">INSERT INTO table2(uid) VALUES(&apos;aaa&apos;),(&apos;aaa&apos;),(&apos;bbb&apos;),(&apos;bbb&apos;),(&apos;bbb&apos;),(&apos;ccc&apos;),(NULL);</span><br></pre></td></tr></table></figure></p><p>4.最后想要的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">    a.uid,</span><br><span class="line">    count(b.oid) AS total</span><br><span class="line">FROM</span><br><span class="line">    table1 AS a</span><br><span class="line">LEFT JOIN table2 AS b ON a.uid = b.uid</span><br><span class="line">WHERE</span><br><span class="line">    a. NAME = &apos;mike&apos;</span><br><span class="line">GROUP BY</span><br><span class="line">    a.uid</span><br><span class="line">HAVING</span><br><span class="line">    count(b.oid) &lt; 2</span><br><span class="line">ORDER BY</span><br><span class="line">    total DESC</span><br><span class="line">LIMIT 1;</span><br></pre></td></tr></table></figure></p><h3 id="SQL解析"><a href="#SQL解析" class="headerlink" title="SQL解析"></a>SQL解析</h3><p>1.FROM<br>当涉及多个表的时候,左边表的输出会作为右边表的输入,之后会生成一个虚拟表VT1。<br>(1-J1)笛卡尔积<br>计算两个相关联表的笛卡尔积(CROSS JOIN) ,生成虚拟表VT1-J1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from table1,table2;</span><br><span class="line">+-----+------+-----+------+</span><br><span class="line">| uid | name | oid | uid  |</span><br><span class="line">+-----+------+-----+------+</span><br><span class="line">| aaa | mike |   1 | aaa  |</span><br><span class="line">| bbb | jack |   1 | aaa  |</span><br><span class="line">| ccc | mike |   1 | aaa  |</span><br><span class="line">| ddd | mike |   1 | aaa  |</span><br><span class="line">| aaa | mike |   2 | aaa  |</span><br><span class="line">| bbb | jack |   2 | aaa  |</span><br><span class="line">| ccc | mike |   2 | aaa  |</span><br><span class="line">| ddd | mike |   2 | aaa  |</span><br><span class="line">| aaa | mike |   3 | bbb  |</span><br><span class="line">| bbb | jack |   3 | bbb  |</span><br><span class="line">| ccc | mike |   3 | bbb  |</span><br><span class="line">| ddd | mike |   3 | bbb  |</span><br><span class="line">| aaa | mike |   4 | bbb  |</span><br><span class="line">| bbb | jack |   4 | bbb  |</span><br><span class="line">| ccc | mike |   4 | bbb  |</span><br><span class="line">| ddd | mike |   4 | bbb  |</span><br><span class="line">| aaa | mike |   5 | bbb  |</span><br><span class="line">| bbb | jack |   5 | bbb  |</span><br><span class="line">| ccc | mike |   5 | bbb  |</span><br><span class="line">| ddd | mike |   5 | bbb  |</span><br><span class="line">| aaa | mike |   6 | ccc  |</span><br><span class="line">| bbb | jack |   6 | ccc  |</span><br><span class="line">| ccc | mike |   6 | ccc  |</span><br><span class="line">| ddd | mike |   6 | ccc  |</span><br><span class="line">| aaa | mike |   7 | NULL |</span><br><span class="line">| bbb | jack |   7 | NULL |</span><br><span class="line">| ccc | mike |   7 | NULL |</span><br><span class="line">| ddd | mike |   7 | NULL |</span><br><span class="line">+-----+------+-----+------+</span><br><span class="line">rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>(1-J2)ON过滤<br>基于虚拟表VT1-J1这一个虚拟表进行过滤,过滤出所有满足ON 谓词条件的列,生成虚拟表VT1-J2。<br>注意:这里因为语法限制,使用了’WHERE’代替,从中读者也可以感受到两者之间微妙的关系；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT</span><br><span class="line">    -&gt; *</span><br><span class="line">    -&gt; FROM</span><br><span class="line">    -&gt; table1,</span><br><span class="line">    -&gt; table2</span><br><span class="line">    -&gt; WHERE</span><br><span class="line">    -&gt; table1.uid = table2.uid</span><br><span class="line">    -&gt; ;</span><br><span class="line">+-----+------+-----+------+</span><br><span class="line">| uid | name | oid | uid  |</span><br><span class="line">+-----+------+-----+------+</span><br><span class="line">| aaa | mike |   1 | aaa  |</span><br><span class="line">| aaa | mike |   2 | aaa  |</span><br><span class="line">| bbb | jack |   3 | bbb  |</span><br><span class="line">| bbb | jack |   4 | bbb  |</span><br><span class="line">| bbb | jack |   5 | bbb  |</span><br><span class="line">| ccc | mike |   6 | ccc  |</span><br><span class="line">+-----+------+-----+------+</span><br><span class="line">rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>(1-J3)添加外部列<br>如果使用了外连接(LEFT,RIGHT,FULL),主表(保留表)中的不符合ON条件的列也会被加入到VT1-J2中,作为外部行,生成虚拟表VT1-J3。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT</span><br><span class="line">    -&gt; *</span><br><span class="line">    -&gt; FROM</span><br><span class="line">    -&gt; table1 AS a</span><br><span class="line">    -&gt; LEFT OUTER JOIN table2 AS b ON a.uid = b.uid;</span><br><span class="line">+-----+------+------+------+</span><br><span class="line">| uid | name | oid  | uid  |</span><br><span class="line">+-----+------+------+------+</span><br><span class="line">| aaa | mike |    1 | aaa  |</span><br><span class="line">| aaa | mike |    2 | aaa  |</span><br><span class="line">| bbb | jack |    3 | bbb  |</span><br><span class="line">| bbb | jack |    4 | bbb  |</span><br><span class="line">| bbb | jack |    5 | bbb  |</span><br><span class="line">| ccc | mike |    6 | ccc  |</span><br><span class="line">| ddd | mike | NULL | NULL |</span><br><span class="line">+-----+------+------+------+</span><br><span class="line">rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>SQL JOINS’的解释图</p><p><a href="//qn.atecher.com/701942-20151210224510246-264811072.png"><img src="//qn.atecher.com/701942-20151210224510246-264811072.png" alt=""></a></p><p>2.WHERE<br>对VT1过程中生成的临时表进行过滤,满足WHERE子句的列被插入到VT2表中。<br>注意:<br>此时因为分组,不能使用聚合运算；也不能使用SELECT中创建的别名；<br>与ON的区别:<br>如果有外部列,ON针对过滤的是关联表,主表(保留表)会返回所有的列；<br>如果没有添加外部列,两者的效果是一样的；<br>应用:<br>对主表的过滤应该放在WHERE；<br>对于关联表,先条件查询后连接则用ON,先连接后条件查询则用WHERE；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT</span><br><span class="line">    -&gt; *</span><br><span class="line">    -&gt; FROM</span><br><span class="line">    -&gt; table1 AS a</span><br><span class="line">    -&gt; LEFT OUTER JOIN table2 AS b ON a.uid = b.uid</span><br><span class="line">    -&gt; WHERE</span><br><span class="line">    -&gt; a. NAME = &apos;mike&apos;;</span><br><span class="line">+-----+------+------+------+</span><br><span class="line">| uid | name | oid  | uid  |</span><br><span class="line">+-----+------+------+------+</span><br><span class="line">| aaa | mike |    1 | aaa  |</span><br><span class="line">| aaa | mike |    2 | aaa  |</span><br><span class="line">| ccc | mike |    6 | ccc  |</span><br><span class="line">| ddd | mike | NULL | NULL |</span><br><span class="line">+-----+------+------+------+</span><br><span class="line">rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>3.GROUP BY<br>这个子句会把VT2中生成的表按照GROUP BY中的列进行分组。生成VT3表。<br>注意:<br>其后处理过程的语句,如SELECT,HAVING,所用到的列必须包含在GROUP BY中,对于没有出现的,得用聚合函数；<br>原因:<br>GROUP BY改变了对表的引用,将其转换为新的引用方式,能够对其进行下一级逻辑操作的列会减少；<br>我的理解是:<br>根据分组字段,将具有相同分组字段的记录归并成一条记录,因为每一个分组只能返回一条记录,除非是被过滤掉了,而不在分组字段里面的字段可能会有多个值,多个值是无法放进一条记录的,所以必须通过聚合函数将这些具有多值的列转换成单值；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT</span><br><span class="line">    -&gt; *</span><br><span class="line">    -&gt; FROM</span><br><span class="line">    -&gt; table1 AS a</span><br><span class="line">    -&gt; LEFT OUTER JOIN table2 AS b ON a.uid = b.uid</span><br><span class="line">    -&gt; WHERE</span><br><span class="line">    -&gt; a. NAME = &apos;mike&apos;</span><br><span class="line">    -&gt; GROUP BY</span><br><span class="line">    -&gt; a.uid;</span><br><span class="line">+-----+------+------+------+</span><br><span class="line">| uid | name | oid  | uid  |</span><br><span class="line">+-----+------+------+------+</span><br><span class="line">| aaa | mike |    1 | aaa  |</span><br><span class="line">| ccc | mike |    6 | ccc  |</span><br><span class="line">| ddd | mike | NULL | NULL |</span><br><span class="line">+-----+------+------+------+</span><br><span class="line">rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>4.HAVING<br>这个子句对VT3表中的不同的组进行过滤,只作用于分组后的数据,满足HAVING条件的子句被加入到VT4表中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT</span><br><span class="line">    -&gt; *</span><br><span class="line">    -&gt; FROM</span><br><span class="line">    -&gt; table1 AS a</span><br><span class="line">    -&gt; LEFT OUTER JOIN table2 AS b ON a.uid = b.uid</span><br><span class="line">    -&gt; WHERE</span><br><span class="line">    -&gt; a. NAME = &apos;mike&apos;</span><br><span class="line">    -&gt; GROUP BY</span><br><span class="line">    -&gt; a.uid</span><br><span class="line">    -&gt; HAVING</span><br><span class="line">    -&gt; count(b.oid) &lt; 2;</span><br><span class="line">+-----+------+------+------+</span><br><span class="line">| uid | name | oid  | uid  |</span><br><span class="line">+-----+------+------+------+</span><br><span class="line">| ccc | mike |    6 | ccc  |</span><br><span class="line">| ddd | mike | NULL | NULL |</span><br><span class="line">+-----+------+------+------+</span><br><span class="line">rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>5.SELECT<br>这个子句对SELECT子句中的元素进行处理,生成VT5表。<br>(5-J1)计算表达式 计算SELECT 子句中的表达式,生成VT5-J1<br>(5-J2)DISTINCT<br>寻找VT5-1中的重复列,并删掉,生成VT5-J2<br>如果在查询中指定了DISTINCT子句,则会创建一张内存临时表(如果内存放不下,就需要存放在硬盘了)。这张临时表的表结构和上一步产生的虚拟表VT5是一样的,不同的是对进行DISTINCT操作的列增加了一个唯一索引,以此来除重复数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT</span><br><span class="line">    -&gt; a.uid,</span><br><span class="line">    -&gt; count(b.oid) AS total</span><br><span class="line">    -&gt; FROM</span><br><span class="line">    -&gt; table1 AS a</span><br><span class="line">    -&gt; LEFT OUTER JOIN table2 AS b ON a.uid = b.uid</span><br><span class="line">    -&gt; WHERE</span><br><span class="line">    -&gt; a. NAME = &apos;mike&apos;</span><br><span class="line">    -&gt; GROUP BY</span><br><span class="line">    -&gt; a.uid</span><br><span class="line">    -&gt; HAVING</span><br><span class="line">    -&gt; count(b.oid) &lt; 2;</span><br><span class="line">+-----+-------+</span><br><span class="line">| uid | total |</span><br><span class="line">+-----+-------+</span><br><span class="line">| ccc |     1 |</span><br><span class="line">| ddd |     0 |</span><br><span class="line">+-----+-------+</span><br><span class="line">rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>6.ORDER BY<br>从VT5-J2中的表中,根据ORDER BY 子句的条件对结果进行排序,生成VT6表。<br>注意:<br>唯一可使用SELECT中别名的地方；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT</span><br><span class="line">    -&gt; a.uid,</span><br><span class="line">    -&gt; count(b.oid) AS total</span><br><span class="line">    -&gt; FROM</span><br><span class="line">    -&gt; table1 AS a</span><br><span class="line">    -&gt; LEFT OUTER JOIN table2 AS b ON a.uid = b.uid</span><br><span class="line">    -&gt; WHERE</span><br><span class="line">    -&gt; a. NAME = &apos;mike&apos;</span><br><span class="line">    -&gt; GROUP BY</span><br><span class="line">    -&gt; a.uid</span><br><span class="line">    -&gt; HAVING</span><br><span class="line">    -&gt; count(b.oid) &lt; 2</span><br><span class="line">    -&gt; ORDER BY</span><br><span class="line">    -&gt; total DESC;</span><br><span class="line">+-----+-------+</span><br><span class="line">| uid | total |</span><br><span class="line">+-----+-------+</span><br><span class="line">| ccc |     1 |</span><br><span class="line">| ddd |     0 |</span><br><span class="line">+-----+-------+</span><br><span class="line">rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>7.LIMIT<br>LIMIT子句从上一步得到的VT6虚拟表中选出从指定位置开始的指定行数据。<br>注意:<br>offset和rows的正负带来的影响；<br>当偏移量很大时效率是很低的,可以这么做:<br>采用子查询的方式优化,在子查询里先从索引获取到最大id,然后倒序排,再取N行结果集<br>采用INNER JOIN优化,JOIN子句里也优先从索引获取ID列表,然后直接关联查询获得最终结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT</span><br><span class="line">    -&gt; a.uid,</span><br><span class="line">    -&gt; count(b.oid) AS total</span><br><span class="line">    -&gt; FROM</span><br><span class="line">    -&gt; table1 AS a</span><br><span class="line">    -&gt; LEFT JOIN table2 AS b ON a.uid = b.uid</span><br><span class="line">    -&gt; WHERE</span><br><span class="line">    -&gt; a. NAME = &apos;mike&apos;</span><br><span class="line">    -&gt; GROUP BY</span><br><span class="line">    -&gt; a.uid</span><br><span class="line">    -&gt; HAVING</span><br><span class="line">    -&gt; count(b.oid) &lt; 2</span><br><span class="line">    -&gt; ORDER BY</span><br><span class="line">    -&gt; total DESC</span><br><span class="line">    -&gt; LIMIT 1;</span><br><span class="line">+-----+-------+</span><br><span class="line">| uid | total |</span><br><span class="line">+-----+-------+</span><br><span class="line">| ccc |     1 |</span><br><span class="line">+-----+-------+</span><br><span class="line">row in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><a href="//qn.atecher.com/701942-20151210224616246-320415795.png"><img src="//qn.atecher.com/701942-20151210224616246-320415795.png" alt=""></a></p><p>ref:<br>《MySQL性能调优与架构实践》<br>《MySQL技术内幕:SQL编程》<br><a href="http://www.cnblogs.com/annsshadow/p/5037667.html" target="_blank" rel="noopener">http://www.cnblogs.com/annsshadow/p/5037667.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直是想知道一条SQL语句是怎么被执行的,它执行的顺序是怎样的&lt;br&gt;本文将从MySQL总体架构—&amp;gt;查询执行流程—&amp;gt;语句执行顺序来探讨一下其中的知识&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.atecher.com/categories/Java/"/>
    
    
      <category term="Mysql" scheme="http://blog.atecher.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Java-NIO</title>
    <link href="http://blog.atecher.com/2017/10/09/Java-NIO/"/>
    <id>http://blog.atecher.com/2017/10/09/Java-NIO/</id>
    <published>2017-10-09T00:00:00.000Z</published>
    <updated>2022-01-28T10:28:39.119Z</updated>
    
    <content type="html"><![CDATA[<p>Java NIO(New IO)是一个可以替代标准Java IO API的IO API(从Java 1.4开始),Java NIO提供了与标准IO不同的IO工作方式。</p><p><strong>Java NIO: Channels and Buffers(通道和缓冲区)</strong></p><p>标准的IO基于字节流和字符流进行操作的,而NIO是基于通道(Channel)和缓冲区(Buffer)进行操作,数据总是从通道读取到缓冲区中,或者从缓冲区写入到通道中。</p><p><strong>Java NIO: Non-blocking IO(非阻塞IO)</strong></p><p>Java NIO可以让你非阻塞的使用IO,例如:当线程从通道读取数据到缓冲区时,线程还是可以进行其他事情。当数据被写入到缓冲区时,线程可以继续处理它。从缓冲区写入通道也类似。</p><p><strong>Java NIO: Selectors(选择器)</strong></p><p>Java NIO引入了选择器的概念,选择器用于监听多个通道的事件(比如:连接打开,数据到达)。因此,单个的线程可以监听多个数据通道。</p><a id="more"></a><h2 id="Java-NIO-概述"><a href="#Java-NIO-概述" class="headerlink" title="Java NIO 概述"></a>Java NIO 概述</h2><p>Java NIO 由以下几个核心部分组成:</p><ul><li>Channels</li><li>Buffers</li><li>Selectors</li></ul><p>虽然Java NIO 中除此之外还有很多类和组件,但在我看来,Channel,Buffer 和 Selector 构成了核心的API。其它组件,如Pipe和FileLock,只不过是与三个核心组件共同使用的工具类。因此,在概述中我将集中在这三个组件上。其它组件会在单独的章节中讲到。</p><h3 id="Channel-和-Buffer"><a href="#Channel-和-Buffer" class="headerlink" title="Channel 和 Buffer"></a>Channel 和 Buffer</h3><p>基本上,所有的 IO 在NIO 中都从一个Channel 开始。Channel 有点象流。 数据可以从Channel读到Buffer中,也可以从Buffer 写到Channel中。这里有个图示:</p><p><a href="//qn.atecher.com/overview-channels-buffers1.png"><img src="//qn.atecher.com/overview-channels-buffers1.png" alt=""></a></p><p>Channel和Buffer有好几种类型。下面是JAVA NIO中的一些主要Channel的实现:</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p>正如你所看到的,这些通道涵盖了UDP 和 TCP 网络IO,以及文件IO。</p><p>与这些类一起的有一些有趣的接口,但为简单起见,我尽量在概述中不提到它们。本教程其它章节与它们相关的地方我会进行解释。</p><p>以下是Java NIO里关键的Buffer实现:</p><ul><li>ByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul><p>这些Buffer覆盖了你能通过IO发送的基本数据类型:byte, short, int, long, float, double 和 char。</p><p>Java NIO 还有个 MappedByteBuffer,用于表示内存映射文件, 我也不打算在概述中说明。</p><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector允许单线程处理多个 Channel。如果你的应用打开了多个连接(通道),但每个连接的流量都很低,使用Selector就会很方便。例如,在一个聊天服务器中。</p><p>这是在一个单线程中使用一个Selector处理3个Channel的图示:</p><p><a href="//qn.atecher.com/overview-selectors.png"><img src="//qn.atecher.com/overview-selectors.png" alt=""></a></p><p>要使用Selector,得向Selector注册Channel,然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回,线程就可以处理这些事件,事件的例子有如新连接进来,数据接收等。</p><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Java NIO的通道类似流,但又有些不同:</p><ul><li>既可以从通道中读取数据,又可以写数据到通道。但流的读写通常是单向的。</li><li>通道可以异步地读写。</li><li>通道中的数据总是要先读到一个Buffer,或者总是要从一个Buffer中写入。</li></ul><p>正如上面所说,从通道读取数据到缓冲区,从缓冲区写入数据到通道。如下图所示:</p><p><a href="//qn.atecher.com/overview-channels-buffers.png"><img src="//qn.atecher.com/overview-channels-buffers.png" alt=""></a></p><h3 id="Channel的实现"><a href="#Channel的实现" class="headerlink" title="Channel的实现"></a>Channel的实现</h3><p>这些是Java NIO中最重要的通道的实现:</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li><li>FileChannel 从文件中读写数据。</li></ul><p>DatagramChannel 能通过UDP读写网络中的数据。</p><p>SocketChannel 能通过TCP读写网络中的数据。</p><p>ServerSocketChannel可以监听新进来的TCP连接,像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。</p><h3 id="基本的-Channel-示例"><a href="#基本的-Channel-示例" class="headerlink" title="基本的 Channel 示例"></a>基本的 Channel 示例</h3><p>下面是一个使用FileChannel读取数据到Buffer中的示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">"Read "</span> + bytesRead);</span><br><span class="line">    buf.flip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>) buf.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buf.clear();</span><br><span class="line">    bytesRead = inChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure></p><p>注意 buf.flip() 的调用,首先读取数据到Buffer,然后反转Buffer,接着再从Buffer中读取数据。下一节会深入讲解Buffer的更多细节。</p><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>Java NIO中的Buffer用于和NIO通道进行交互。如你所知,数据是从通道读入缓冲区,从缓冲区写入到通道中的。</p><p>缓冲区本质上是一块可以写入数据,然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象,并提供了一组方法,用来方便的访问该块内存。</p><h3 id="Buffer的基本用法"><a href="#Buffer的基本用法" class="headerlink" title="Buffer的基本用法"></a>Buffer的基本用法</h3><p>使用Buffer读写数据一般遵循以下四个步骤:</p><ol><li>写入数据到Buffer</li><li>调用flip()方法</li><li>从Buffer中读取数据</li><li>调用clear()方法或者compact()方法</li></ol><p>当向buffer写入数据时,buffer会记录下写了多少数据。一旦要读取数据,需要通过flip()方法将Buffer从写模式切换到读模式。在读模式下,可以读取之前写入到buffer的所有数据。</p><p>一旦读完了所有的数据,就需要清空缓冲区,让它可以再次被写入。有两种方式能清空缓冲区:调用clear()或compact()方法。clear()方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。任何未读的数据都被移到缓冲区的起始处,新写入的数据将放到缓冲区未读数据的后面。</p><p>下面是一个使用Buffer的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="comment">//create buffer with capacity of 48 bytes</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf); <span class="comment">//read into buffer.</span></span><br><span class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">  buf.flip();  <span class="comment">//make buffer ready for read</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">      System.out.print((<span class="keyword">char</span>) buf.get()); <span class="comment">// read 1 byte at a time</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buf.clear(); <span class="comment">//make buffer ready for writing</span></span><br><span class="line">  bytesRead = inChannel.read(buf);</span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure></p><h3 id="Buffer的capacity-position和limit"><a href="#Buffer的capacity-position和limit" class="headerlink" title="Buffer的capacity,position和limit"></a>Buffer的capacity,position和limit</h3><p>缓冲区本质上是一块可以写入数据,然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象,并提供了一组方法,用来方便的访问该块内存。</p><p>为了理解Buffer的工作原理,需要熟悉它的三个属性:</p><ul><li>capacity</li><li>position</li><li>limit</li></ul><p>position和limit的含义取决于Buffer处在读模式还是写模式。不管Buffer处在什么模式,capacity的含义总是一样的。</p><p>这里有一个关于capacity,position和limit在读写模式中的说明,详细的解释在插图后面。</p><p><a href="//qn.atecher.com/buffers-modes.png"><img src="//qn.atecher.com/buffers-modes.png" alt=""></a></p><h4 id="capacity"><a href="#capacity" class="headerlink" title="capacity"></a>capacity</h4><p>作为一个内存块,Buffer有一个固定的大小值,也叫“capacity”.你只能往里写capacity个byte、long,char等类型。一旦Buffer满了,需要将其清空(通过读数据或者清除数据)才能继续写数据往里写数据。</p><h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><p>当你写数据到Buffer中时,position表示当前的位置。初始的position值为0.当一个byte、long等数据写到Buffer后, position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1.</p><p>当读取数据时,也是从某个特定位置读。当将Buffer从写模式切换到读模式,position会被重置为0. 当从Buffer的position处读取数据时,position向前移动到下一个可读的位置。</p><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p>在写模式下,Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下,limit等于Buffer的capacity。</p><p>当切换Buffer到读模式时, limit表示你最多能读到多少数据。因此,当切换Buffer到读模式时,limit会被设置成写模式下的position值。换句话说,你能读到之前写入的所有数据(limit被设置成已写数据的数量,这个值在写模式下就是position)</p><h3 id="Buffer的类型"><a href="#Buffer的类型" class="headerlink" title="Buffer的类型"></a>Buffer的类型</h3><p>Java NIO 有以下Buffer类型</p><ul><li>ByteBuffer</li><li>MappedByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul><p>如你所见,这些Buffer类型代表了不同的数据类型。换句话说,就是可以通过char,short,int,long,float 或 double类型来操作缓冲区中的字节。</p><p>MappedByteBuffer 有些特别,在涉及它的专门章节中再讲。</p><h3 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a>Buffer的分配</h3><p>要想获得一个Buffer对象首先要进行分配。 每一个Buffer类都有一个allocate方法。下面是一个分配48字节capacity的ByteBuffer的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br></pre></td></tr></table></figure><p>这是分配一个可存储1024个字符的CharBuffer:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CharBuffer buf = CharBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure></p><h3 id="向Buffer中写数据"><a href="#向Buffer中写数据" class="headerlink" title="向Buffer中写数据"></a>向Buffer中写数据</h3><p>写数据到Buffer有两种方式:</p><ul><li>从Channel写到Buffer。</li><li>通过Buffer的put()方法写到Buffer里。</li></ul><p>从Channel写到Buffer的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf); <span class="comment">//read into buffer.</span></span><br></pre></td></tr></table></figure><p>通过put方法写Buffer的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put(<span class="number">127</span>);</span><br></pre></td></tr></table></figure></p><p>put方法有很多版本,允许你以不同的方式把数据写入到Buffer中。例如, 写到一个指定的位置,或者把一个字节数组写入到Buffer。 更多Buffer实现的细节参考JavaDoc。</p><h3 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h3><p>flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0,并将limit设置成之前position的值。</p><p>换句话说,position现在用于标记读的位置,limit表示之前写进了多少个byte、char等 —— 现在能读取多少个byte、char等。</p><h3 id="从Buffer中读取数据"><a href="#从Buffer中读取数据" class="headerlink" title="从Buffer中读取数据"></a>从Buffer中读取数据</h3><p>从Buffer中读取数据有两种方式:</p><ul><li>从Buffer读取数据到Channel。</li><li>使用get()方法从Buffer中读取数据。</li></ul><p>从Buffer读取数据到Channel的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//read from buffer into channel.</span></span><br><span class="line"><span class="keyword">int</span> bytesWritten = inChannel.write(buf);</span><br></pre></td></tr></table></figure></p><p>使用get()方法从Buffer中读取数据的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> aByte = buf.get();</span><br></pre></td></tr></table></figure></p><p>get方法有很多版本,允许你以不同的方式从Buffer中读取数据。例如,从指定position读取,或者从Buffer中读取数据到字节数组。更多Buffer实现的细节参考JavaDoc。</p><h3 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h3><p>Buffer.rewind()将position设回0,所以你可以重读Buffer中的所有数据。limit保持不变,仍然表示能从Buffer中读取多少个元素(byte、char等)。</p><h3 id="clear-与compact-方法"><a href="#clear-与compact-方法" class="headerlink" title="clear()与compact()方法"></a>clear()与compact()方法</h3><p>一旦读完Buffer中的数据,需要让Buffer准备好再次被写入。可以通过clear()或compact()方法来完成。</p><p>如果调用的是clear()方法,position将被设回0,limit被设置成 capacity的值。换句话说,Buffer 被清空了。Buffer中的数据并未清除,只是这些标记告诉我们可以从哪里开始往Buffer里写数据。</p><p>如果Buffer中有一些未读的数据,调用clear()方法,数据将“被遗忘”,意味着不再有任何标记会告诉你哪些数据被读过,哪些还没有。</p><p>如果Buffer中仍有未读的数据,且后续还需要这些数据,但是此时想要先先写些数据,那么使用compact()方法。</p><p>compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样,设置成capacity。现在Buffer准备好写数据了,但是不会覆盖未读的数据。</p><h3 id="mark-与reset-方法"><a href="#mark-与reset-方法" class="headerlink" title="mark()与reset()方法"></a>mark()与reset()方法</h3><p>通过调用Buffer.mark()方法,可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。例如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.mark();</span><br><span class="line"><span class="comment">//call buffer.get() a couple of times, e.g. during parsing.</span></span><br><span class="line">buffer.reset();  <span class="comment">//set position back to mark.</span></span><br></pre></td></tr></table></figure></p><h3 id="equals-与compareTo-方法"><a href="#equals-与compareTo-方法" class="headerlink" title="equals()与compareTo()方法"></a>equals()与compareTo()方法</h3><p>可以使用equals()和compareTo()方法比较两个Buffer。</p><h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p>当满足下列条件时,表示两个Buffer相等:</p><ol><li>有相同的类型(byte、char、int等)。</li><li>Buffer中剩余的byte、char等的个数相等。</li><li>Buffer中所有剩余的byte、char等都相同。</li></ol><p>如你所见,equals只是比较Buffer的一部分,不是每一个在它里面的元素都比较。实际上,它只比较Buffer中的剩余元素。</p><h4 id="compareTo-方法"><a href="#compareTo-方法" class="headerlink" title="compareTo()方法"></a>compareTo()方法</h4><p>compareTo()方法比较两个Buffer的剩余元素(byte、char等), 如果满足下列条件,则认为一个Buffer“小于”另一个Buffer:</p><ol><li>第一个不相等的元素小于另一个Buffer中对应的元素 。</li><li>所有元素都相等,但第一个Buffer比另一个先耗尽(第一个Buffer的元素个数比另一个少)。</li></ol><p>(译注:剩余元素是从 position到limit之间的元素)</p><h2 id="Scatter-Gather"><a href="#Scatter-Gather" class="headerlink" title="Scatter/Gather"></a>Scatter/Gather</h2><p>Java NIO开始支持scatter/gather,scatter/gather用于描述从Channel(译者注:Channel在中文经常翻译为通道)中读取或者写入到Channel的操作。<br>分散(scatter)从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此,Channel将从Channel中读取的数据“分散(scatter)”到多个Buffer中。<br>聚集(gather)写入Channel是指在写操作时将多个buffer的数据写入同一个Channel,因此,Channel 将多个Buffer中的数据“聚集(gather)”后发送到Channel。</p><p>scatter / gather经常用于需要将传输的数据分开处理的场合,例如传输一个由消息头和消息体组成的消息,你可能会将消息体和消息头分散到不同的buffer中,这样你可以方便的处理消息头和消息体。</p><h3 id="Scattering-Reads"><a href="#Scattering-Reads" class="headerlink" title="Scattering Reads"></a>Scattering Reads</h3><p>Scattering Reads是指数据从一个channel读取到多个buffer中。如下图描述:</p><p><a href="//qn.atecher.com/scatter.png"><img src="//qn.atecher.com/scatter.png" alt=""></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line"></span><br><span class="line">channel.read(bufferArray);</span><br></pre></td></tr></table></figure><p>注意buffer首先被插入到数组,然后再将数组作为channel.read() 的输入参数。read()方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer,当一个buffer被写满后,channel紧接着向另一个buffer中写。</p><p>Scattering Reads在移动下一个buffer前,必须填满当前的buffer,这也意味着它不适用于动态消息(译者注:消息大小不固定)。换句话说,如果存在消息头和消息体,消息头必须完成填充(例如 128byte),Scattering Reads才能正常工作。</p><h3 id="Gathering-Writes"><a href="#Gathering-Writes" class="headerlink" title="Gathering Writes"></a>Gathering Writes</h3><p>Gathering Writes是指数据从多个buffer写入到同一个channel。如下图描述:</p><p><a href="//qn.atecher.com/gather.png"><img src="//qn.atecher.com/gather.png" alt=""></a></p><p>代码示例如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//write data into buffers</span></span><br><span class="line"></span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line"></span><br><span class="line">channel.write(bufferArray);</span><br></pre></td></tr></table></figure></p><p>buffers数组是write()方法的入参,write()方法会按照buffer在数组中的顺序,将数据写入到channel,注意只有position和limit之间的数据才会被写入。因此,如果一个buffer的容量为128byte,但是仅仅包含58byte的数据,那么这58byte的数据将被写入到channel中。因此与Scattering Reads相反,Gathering Writes能较好的处理动态消息。</p><h2 id="通道之间的数据传输"><a href="#通道之间的数据传输" class="headerlink" title="通道之间的数据传输"></a>通道之间的数据传输</h2><p>在Java NIO中,如果两个通道中有一个是FileChannel,那你可以直接将数据从一个channel(译者注:channel中文常译作通道)传输到另外一个channel。</p><h3 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom()"></a>transferFrom()</h3><p>FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中(译者注:这个方法在JDK文档中的解释为将字节从给定的可读取字节通道传输到此通道的文件中)。下面是一个简单的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line">toChannel.transferFrom(position, count, fromChannel);</span><br></pre></td></tr></table></figure></p><p>方法的输入参数position表示从position处开始向目标文件写入数据,count表示最多传输的字节数。如果源通道的剩余空间小于 count 个字节,则所传输的字节数要小于请求的字节数。<br>此外要注意,在SoketChannel的实现中,SocketChannel只会传输此刻准备好的数据(可能不足count字节)。因此,SocketChannel可能不会将请求的所有数据(count个字节)全部传输到FileChannel中。</p><h3 id="transferTo"><a href="#transferTo" class="headerlink" title="transferTo()"></a>transferTo()</h3><p>transferTo()方法将数据从FileChannel传输到其他的channel中。下面是一个简单的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"fromFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"toFile.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br></pre></td></tr></table></figure></p><p>是不是发现这个例子和前面那个例子特别相似？除了调用方法的FileChannel对象不一样外,其他的都一样。<br>上面所说的关于SocketChannel的问题在transferTo()方法中同样存在。SocketChannel会一直传输数据直到目标buffer被填满。</p><h2 id="Selector-1"><a href="#Selector-1" class="headerlink" title="Selector"></a>Selector</h2><p>Selector(选择器)是Java NIO中能够检测一到多个NIO通道,并能够知晓通道是否为诸如读写事件做好准备的组件。这样,一个单独的线程可以管理多个channel,从而管理多个网络连接。</p><h3 id="为什么使用Selector"><a href="#为什么使用Selector" class="headerlink" title="为什么使用Selector?"></a>为什么使用Selector?</h3><p>仅用单个线程来处理多个Channels的好处是,只需要更少的线程来处理通道。事实上,可以只用一个线程处理所有的通道。对于操作系统来说,线程之间上下文切换的开销很大,而且每个线程都要占用系统的一些资源(如内存)。因此,使用的线程越少越好。</p><p>但是,需要记住,现代的操作系统和CPU在多任务方面表现的越来越好,所以多线程的开销随着时间的推移,变得越来越小了。实际上,如果一个CPU有多个内核,不使用多任务可能是在浪费CPU能力。不管怎么说,关于那种设计的讨论应该放在另一篇不同的文章中。在这里,只要知道使用Selector能够处理多个通道就足够了。</p><p>下面是单线程使用一个Selector处理3个channel的示例图:</p><p><a href="//qn.atecher.com/overview-selectors.png"><img src="//qn.atecher.com/overview-selectors.png" alt=""></a></p><h3 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h3><p>通过调用Selector.open()方法创建一个Selector,如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure></p><h3 id="向Selector注册通道"><a href="#向Selector注册通道" class="headerlink" title="向Selector注册通道"></a>向Selector注册通道</h3><p>为了将Channel和Selector配合使用,必须将channel注册到selector上。通过SelectableChannel.register()方法来实现,如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector,</span><br><span class="line">Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure></p><p>与Selector一起使用时,Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用,因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p><p>注意register()方法的第二个参数。这是一个“interest集合”,意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件:</p><ol><li>Connect</li><li>Accept</li><li>Read</li><li>Write</li></ol><p>通道触发了一个事件意思是该事件已经就绪。所以,某个channel成功连接到另一个服务器称为“连接就绪”。一个server socket channel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。</p><p>这四种事件用SelectionKey的四个常量来表示:</p><ol><li>SelectionKey.OP_CONNECT</li><li>SelectionKey.OP_ACCEPT</li><li>SelectionKey.OP_READ</li><li>SelectionKey.OP_WRITE</li></ol><p>如果你对不止一种事件感兴趣,那么可以用“位或”操作符将常量连接起来,如下:</p><p>int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;<br>在下面还会继续提到interest集合。</p><h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p>在上一小节中,当向Selector注册Channel时,register()方法会返回一个SelectionKey对象。这个对象包含了一些你感兴趣的属性:</p><ul><li>interest集合</li><li>ready集合</li><li>Channel</li><li>Selector</li><li>附加的对象(可选)</li></ul><p>下面我会描述这些属性。</p><h4 id="interest集合"><a href="#interest集合" class="headerlink" title="interest集合"></a>interest集合</h4><p>就像向Selector注册通道一节中所描述的,interest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合,像这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = (interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInConnect = interestSet &amp; SelectionKey.OP_CONNECT;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInRead    = interestSet &amp; SelectionKey.OP_READ;</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInWrite   = interestSet &amp; SelectionKey.OP_WRITE;</span><br></pre></td></tr></table></figure></p><p>可以看到,用“位与”操作interest 集合和给定的SelectionKey常量,可以确定某个确定的事件是否在interest 集合中。</p><h4 id="ready集合"><a href="#ready集合" class="headerlink" title="ready集合"></a>ready集合</h4><p>ready 集合是通道已经准备就绪的操作的集合。在一次选择(Selection)之后,你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> readySet = selectionKey.readyOps();</span><br></pre></td></tr></table></figure></p><p>可以用像检测interest集合那样的方法,来检测channel中什么事件或操作已经就绪。但是,也可以使用以下四个方法,它们都会返回一个布尔类型:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure></p><h4 id="Channel-Selector"><a href="#Channel-Selector" class="headerlink" title="Channel + Selector"></a>Channel + Selector</h4><p>从SelectionKey访问Channel和Selector很简单。如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure></p><h4 id="附加的对象"><a href="#附加的对象" class="headerlink" title="附加的对象"></a>附加的对象</h4><p>可以将一个对象或者更多信息附着到SelectionKey上,这样就能方便的识别某个给定的通道。例如,可以附加 与通道一起使用的Buffer,或是包含聚集数据的某个对象。使用方法如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure></p><p>还可以在用register()方法向Selector注册Channel的时候附加对象。如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure></p><h3 id="通过Selector选择通道"><a href="#通过Selector选择通道" class="headerlink" title="通过Selector选择通道"></a>通过Selector选择通道</h3><p>一旦向Selector注册了一或多个通道,就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件(如连接、接受、读或写)已经准备就绪的那些通道。换句话说,如果你对“读就绪”的通道感兴趣,select()方法会返回读事件已经就绪的那些通道。</p><p>下面是select()方法:</p><ul><li>int select()</li><li>int select(long timeout)</li><li>int selectNow()</li></ul><p>select()阻塞到至少有一个通道在你注册的事件上就绪了。</p><p>select(long timeout)和select()一样,除了最长会阻塞timeout毫秒(参数)。</p><p>selectNow()不会阻塞,不管什么通道就绪都立刻返回(译者注:此方法执行非阻塞的选择操作。如果自从前一次选择操作后,没有通道变成可选择的,则此方法直接返回零。)。</p><p>select()方法返回的int值表示有多少通道已经就绪。亦即,自上次调用select()方法后有多少通道变成就绪状态。如果调用select()方法,因为有一个通道变成就绪状态,返回了1,若再次调用select()方法,如果另一个通道就绪了,它会再次返回1。如果对第一个就绪的channel没有做任何操作,现在就有两个就绪的通道,但在每次select()方法调用之间,只有一个通道就绪了。</p><h4 id="selectedKeys"><a href="#selectedKeys" class="headerlink" title="selectedKeys()"></a>selectedKeys()</h4><p>一旦调用了select()方法,并且返回值表明有一个或更多个通道就绪了,然后可以通过调用selector的selectedKeys()方法,访问“已选择键集(selected key set)”中的就绪通道。如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure></p><p>当像Selector注册Channel时,Channel.register()方法会返回一个SelectionKey 对象。这个对象代表了注册到该Selector的通道。可以通过SelectionKey的selectedKeySet()方法访问这些对象。</p><p>可以遍历这个已选择的键集合来访问就绪的通道。如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个循环遍历已选择键集中的每个键,并检测各个键所对应的通道的就绪事件。</p><p>注意每次迭代末尾的keyIterator.remove()调用。Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除。下次该通道变成就绪时,Selector会再次将其放入已选择键集中。</p><p>SelectionKey.channel()方法返回的通道需要转型成你要处理的类型,如ServerSocketChannel或SocketChannel等。</p><h3 id="wakeUp"><a href="#wakeUp" class="headerlink" title="wakeUp()"></a>wakeUp()</h3><p>某个线程调用select()方法后阻塞了,即使没有通道已经就绪,也有办法让其从select()方法返回。只要让其它线程在第一个线程调用select()方法的那个对象上调用Selector.wakeup()方法即可。阻塞在select()方法上的线程会立马返回。</p><p>如果有其它线程调用了wakeup()方法,但当前没有线程阻塞在select()方法上,下个调用select()方法的线程会立即“醒来(wake up)”。</p><h3 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h3><p>用完Selector后调用其close()方法会关闭该Selector,且使注册到该Selector上的所有SelectionKey实例无效。通道本身并不会关闭。</p><p>完整的示例</p><p>这里有一个完整的示例,打开一个Selector,注册一个通道注册到这个Selector上(通道的初始化过程略去),然后持续监控这个Selector的四种事件(接受,连接,读,写)是否就绪。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">  <span class="keyword">int</span> readyChannels = selector.select();</span><br><span class="line">  <span class="keyword">if</span>(readyChannels == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">  Set selectedKeys = selector.selectedKeys();</span><br><span class="line">  Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line">  <span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><p>Java NIO中的FileChannel是一个连接到文件的通道。可以通过文件通道读写文件。</p><p>FileChannel无法设置为非阻塞模式,它总是运行在阻塞模式下。</p><h3 id="打开FileChannel"><a href="#打开FileChannel" class="headerlink" title="打开FileChannel"></a>打开FileChannel</h3><p>在使用FileChannel之前,必须先打开它。但是,我们无法直接打开一个FileChannel,需要通过使用一个InputStream、OutputStream或RandomAccessFile来获取一个FileChannel实例。下面是通过RandomAccessFile打开FileChannel的示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"data/nio-data.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br></pre></td></tr></table></figure></p><h3 id="从FileChannel读取数据"><a href="#从FileChannel读取数据" class="headerlink" title="从FileChannel读取数据"></a>从FileChannel读取数据</h3><p>调用多个read()方法之一从FileChannel中读取数据。如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br></pre></td></tr></table></figure></p><p>首先,分配一个Buffer。从FileChannel中读取的数据将被读到Buffer中。</p><p>然后,调用FileChannel.read()方法。该方法将数据从FileChannel读取到Buffer中。read()方法返回的int值表示了有多少字节被读到了Buffer中。如果返回-1,表示到了文件末尾。</p><h3 id="向FileChannel写数据"><a href="#向FileChannel写数据" class="headerlink" title="向FileChannel写数据"></a>向FileChannel写数据</h3><p>使用FileChannel.write()方法向FileChannel写数据,该方法的参数是一个Buffer。如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意FileChannel.write()是在while循环中调用的。因为无法保证write()方法一次能向FileChannel写入多少字节,因此需要重复调用write()方法,直到Buffer中已经没有尚未写入通道的字节。</p><h3 id="关闭FileChannel"><a href="#关闭FileChannel" class="headerlink" title="关闭FileChannel"></a>关闭FileChannel</h3><p>用完FileChannel后必须将其关闭。如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.close();</span><br></pre></td></tr></table></figure></p><h3 id="FileChannel的position方法"><a href="#FileChannel的position方法" class="headerlink" title="FileChannel的position方法"></a>FileChannel的position方法</h3><p>有时可能需要在FileChannel的某个特定位置进行数据的读/写操作。可以通过调用position()方法获取FileChannel的当前位置。</p><p>也可以通过调用position(long pos)方法设置FileChannel的当前位置。</p><p>这里有两个例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> pos = channel.position();</span><br><span class="line">channel.position(pos +<span class="number">123</span>);</span><br></pre></td></tr></table></figure></p><p>如果将位置设置在文件结束符之后,然后试图从文件通道中读取数据,读方法将返回-1 —— 文件结束标志。</p><p>如果将位置设置在文件结束符之后,然后向通道中写数据,文件将撑大到当前位置并写入数据。这可能导致“文件空洞”,磁盘上物理文件中写入的数据间有空隙。</p><h3 id="FileChannel的size方法"><a href="#FileChannel的size方法" class="headerlink" title="FileChannel的size方法"></a>FileChannel的size方法</h3><p>FileChannel实例的size()方法将返回该实例所关联文件的大小。如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> fileSize = channel.size();</span><br></pre></td></tr></table></figure></p><h3 id="FileChannel的truncate方法"><a href="#FileChannel的truncate方法" class="headerlink" title="FileChannel的truncate方法"></a>FileChannel的truncate方法</h3><p>可以使用FileChannel.truncate()方法截取一个文件。截取文件时,文件将中指定长度后面的部分将被删除。如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.truncate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure></p><p>这个例子截取文件的前1024个字节。</p><h3 id="FileChannel的force方法"><a href="#FileChannel的force方法" class="headerlink" title="FileChannel的force方法"></a>FileChannel的force方法</h3><p>FileChannel.force()方法将通道里尚未写入磁盘的数据强制写到磁盘上。出于性能方面的考虑,操作系统会将数据缓存在内存中,所以无法保证写入到FileChannel里的数据一定会即时写到磁盘上。要保证这一点,需要调用force()方法。</p><p>force()方法有一个boolean类型的参数,指明是否同时将文件元数据(权限信息等)写到磁盘上。</p><p>下面的例子同时将文件数据和元数据强制写到磁盘上:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.force(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p><h2 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h2><p>Java NIO中的SocketChannel是一个连接到TCP网络套接字的通道。可以通过以下2种方式创建SocketChannel:</p><ol><li>打开一个SocketChannel并连接到互联网上的某台服务器。</li><li>一个新连接到达ServerSocketChannel时,会创建一个SocketChannel。</li></ol><h3 id="打开-SocketChannel"><a href="#打开-SocketChannel" class="headerlink" title="打开 SocketChannel"></a>打开 SocketChannel</h3><p>下面是SocketChannel的打开方式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://jenkov.com"</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure></p><h3 id="关闭-SocketChannel"><a href="#关闭-SocketChannel" class="headerlink" title="关闭 SocketChannel"></a>关闭 SocketChannel</h3><p>当用完SocketChannel之后调用SocketChannel.close()关闭SocketChannel:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.close();</span><br></pre></td></tr></table></figure></p><h3 id="从-SocketChannel-读取数据"><a href="#从-SocketChannel-读取数据" class="headerlink" title="从 SocketChannel 读取数据"></a>从 SocketChannel 读取数据</h3><p>要从SocketChannel中读取数据,调用一个read()的方法之一。以下是例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = socketChannel.read(buf);</span><br></pre></td></tr></table></figure></p><p>首先,分配一个Buffer。从SocketChannel读取到的数据将会放到这个Buffer中。</p><p>然后,调用SocketChannel.read()。该方法将数据从SocketChannel 读到Buffer中。read()方法返回的int值表示读了多少字节进Buffer里。如果返回的是-1,表示已经读到了流的末尾(连接关闭了)。</p><h3 id="写入-SocketChannel"><a href="#写入-SocketChannel" class="headerlink" title="写入 SocketChannel"></a>写入 SocketChannel</h3><p>写数据到SocketChannel用的是SocketChannel.write()方法,该方法以一个Buffer作为参数。示例如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意SocketChannel.write()方法的调用是在一个while循环中的。Write()方法无法保证能写多少字节到SocketChannel。所以,我们重复调用write()直到Buffer没有要写的字节为止。</p><h3 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h3><p>可以设置 SocketChannel 为非阻塞模式(non-blocking mode).设置之后,就可以在异步模式下调用connect(), read() 和write()了。</p><h4 id="connect"><a href="#connect" class="headerlink" title="connect()"></a>connect()</h4><p>如果SocketChannel在非阻塞模式下,此时调用connect(),该方法可能在连接建立之前就返回了。为了确定连接是否建立,可以调用finishConnect()的方法。像这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"http://jenkov.com"</span>, <span class="number">80</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(! socketChannel.finishConnect() )&#123;</span><br><span class="line">    <span class="comment">//wait, or do something else...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="write"><a href="#write" class="headerlink" title="write()"></a>write()</h4><p>非阻塞模式下,write()方法在尚未写出任何内容时可能就返回了。所以需要在循环中调用write()。前面已经有例子了,这里就不赘述了。</p><h4 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h4><p>非阻塞模式下,read()方法在尚未读取到任何数据时可能就返回了。所以需要关注它的int返回值,它会告诉你读取了多少字节。</p><h3 id="非阻塞模式与选择器"><a href="#非阻塞模式与选择器" class="headerlink" title="非阻塞模式与选择器"></a>非阻塞模式与选择器</h3><p>非阻塞模式与选择器搭配会工作的更好,通过将一或多个SocketChannel注册到Selector,可以询问选择器哪个通道已经准备好了读取,写入等。Selector与SocketChannel的搭配使用会在后面详讲。</p><h2 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h2><p>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道, 就像标准IO中的ServerSocket一样。ServerSocketChannel类在 java.nio.channels包中。</p><p>这里有个例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">    <span class="comment">//do something with socketChannel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="打开-ServerSocketChannel"><a href="#打开-ServerSocketChannel" class="headerlink" title="打开 ServerSocketChannel"></a>打开 ServerSocketChannel</h3><p>通过调用 ServerSocketChannel.open() 方法来打开ServerSocketChannel.如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br></pre></td></tr></table></figure></p><h3 id="关闭-ServerSocketChannel"><a href="#关闭-ServerSocketChannel" class="headerlink" title="关闭 ServerSocketChannel"></a>关闭 ServerSocketChannel</h3><p>通过调用ServerSocketChannel.close() 方法来关闭ServerSocketChannel. 如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.close();</span><br></pre></td></tr></table></figure></p><h3 id="监听新进来的连接"><a href="#监听新进来的连接" class="headerlink" title="监听新进来的连接"></a>监听新进来的连接</h3><p>通过 ServerSocketChannel.accept() 方法监听新进来的连接。当 accept()方法返回的时候,它返回一个包含新进来的连接的 SocketChannel。因此, accept()方法会一直阻塞到有新连接到达。</p><p>通常不会仅仅只监听一个连接,在while循环中调用 accept()方法. 如下面的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">    <span class="comment">//do something with socketChannel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然,也可以在while循环中使用除了true以外的其它退出准则。</p><h3 id="非阻塞模式-1"><a href="#非阻塞模式-1" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h3><p>ServerSocketChannel可以设置成非阻塞模式。在非阻塞模式下,accept() 方法会立刻返回,如果还没有新进来的连接,返回的将是null。 因此,需要检查返回的SocketChannel是否是null.如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">    <span class="keyword">if</span>(socketChannel != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//do something with socketChannel...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="非阻塞式服务器"><a href="#非阻塞式服务器" class="headerlink" title="非阻塞式服务器"></a>非阻塞式服务器</h2><p>即使你知道Java NIO 非阻塞的工作特性(如Selector,Channel,Buffer等组件),但是想要设计一个非阻塞的服务器仍然是一件很困难的事。非阻塞式服务器相较于阻塞式来说要多上许多挑战。本文将会讨论非阻塞式服务器的主要几个难题,并针对这些难题给出一些可能的解决方案。</p><p>本文的设计思路想法都是基于Java NIO的。但是我相信如果某些语言中也有像Selector之类的组件的话,文中的想法也能用于该语言。据我所知,类似的组件底层操作系统会提供,所以对你来说也可以根据其中的思想运用在其他语言上。</p><h3 id="非阻塞式服务器–-GitHub-仓库"><a href="#非阻塞式服务器–-GitHub-仓库" class="headerlink" title="非阻塞式服务器– GitHub 仓库"></a>非阻塞式服务器– GitHub 仓库</h3><p>我已经创建了一些简单的这些思想的概念验证呈现在这篇教程中,并且为了让你可以看到,我把源码放到了github资源库上了。这里是GitHub资源库地址:<br><a href="https://github.com/jjenkov/java-nio-server" target="_blank" rel="noopener">https://github.com/jjenkov/java-nio-server</a></p><h3 id="非阻塞式IO管道-Pipelines"><a href="#非阻塞式IO管道-Pipelines" class="headerlink" title="非阻塞式IO管道(Pipelines)"></a>非阻塞式IO管道(Pipelines)</h3><p>一个非阻塞式IO管道是由各个处理非阻塞式IO组件组成的链。其中包括读/写IO。下图就是一个简单的非阻塞式IO管道组成:</p><p><a href="//qn.atecher.com/non-blocking-server-1.png"><img src="//qn.atecher.com/non-blocking-server-1.png" alt=""></a></p><p>一个组件使用 Selector 监控 Channel 什么时候有可读数据。然后这个组件读取输入并且根据输入生成相应的输出。最后输出将会再次写入到一个Channel中。</p><p>一个非阻塞式IO管道不需要将读数据和写数据都包含,有一些管道可能只会读数据,另一些可能只会写数据。</p><p>上图仅显示了一个单一的组件。一个非阻塞式IO管道可能拥有超过一个以上的组件去处理输入数据。一个非阻塞式管道的长度是由他的所要完成的任务决定。</p><p>一个非阻塞IO管道可能同时读取多个Channel里的数据。举个例子:从多个SocketChannel管道读取数据。</p><p>其实上图的控制流程还是太简单了。这里是组件从Selector开始从Channel中读取数据,而不是Channel将数据推送给Selector进入组件中,即便上图画的就是这样。</p><h3 id="非阻塞式vs-阻塞式管道"><a href="#非阻塞式vs-阻塞式管道" class="headerlink" title="非阻塞式vs. 阻塞式管道"></a>非阻塞式vs. 阻塞式管道</h3><p>非阻塞和阻塞IO管道两者之间最大的区别在于他们如何从底层Channel(Socket或者file)读取数据。</p><p>IO管道通常从流中读取数据(来自socket或者file)并且将这些数据拆分为一系列连贯的消息。这和使用tokenizer(这里估计是解析器之类的意思)将数据流解析为token(这里应该是数据包的意思)类似。相反你只是将数据流分解为更大的消息体。我将拆分数据流成消息这一组件称为“消息读取器”(Message Reader)下面是Message Reader拆分流为消息的示意图:</p><p><a href="//qn.atecher.com/non-blocking-server-2.png"><img src="//qn.atecher.com/non-blocking-server-2.png" alt=""></a></p><p>一个阻塞IO管道可以使用类似InputStream的接口每次一个字节地从底层Channel读取数据,并且这个接口阻塞直到有数据可以读取。这就是阻塞式Message Reader的实现过程。</p><p>使用阻塞式IO接口简化了Message Reader的实现。阻塞式Message Reader从不用处理在流没有数据可读的情况,或者它只读取流中的部分数据并且对于消息的恢复也要延迟处理的情况。</p><p>同样,阻塞式Message Writer(一个将数据写入流中组件)也从不用处理只有部分数据被写入和写入消息要延迟恢复的情况。</p><h4 id="阻塞式IO管道的缺陷"><a href="#阻塞式IO管道的缺陷" class="headerlink" title="阻塞式IO管道的缺陷"></a>阻塞式IO管道的缺陷</h4><p>虽然阻塞式Message Reader容易实现,但是也有一个不幸的缺点:每一个要分解成消息的流都需要一个独立的线程。必须要这样做的理由是每一个流的IO接口会阻塞,直到它有数据读取。这就意味着一个单独的线程是无法尝试从一个没有数据的流中读取数据转去读另一个流。一旦一个线程尝试从一个流中读取数据,那么这个线程将会阻塞直到有数据可以读取。</p><p>如果IO管道是必须要处理大量并发链接服务器的一部分的话,那么服务器就需要为每一个链接维护一个线程。对于任何时间都只有几百条并发链接的服务器这确实不是什么问题。但是如果服务器拥有百万级别的并发链接量,这种设计方式就没有良好收放。每个线程都会占用栈32bit-64bit的内存。所以一百万个线程占用的内存将会达到1TB！不过在此之前服务器将会把所有的内存用以处理传经来的消息(例如:分配给消息处理期间使用对象的内存)</p><p>为了将线程数量降下来,许多服务器使用了服务器维持线程池(例如:常用线程为100)的设计,从而一次一个地从入站链接(inbound connections)地读取。入站链接保存在一个队列中,线程按照进入队列的顺序处理入站链接。这一设计如下图所示:(译者注:Tomcat就是这样的)</p><p><a href="//qn.atecher.com/non-blocking-server-3.png"><img src="//qn.atecher.com/non-blocking-server-3.png" alt=""></a></p><p>然而,这一设计需要入站链接合理地发送数据。如果入站链接长时间不活跃,那么大量的不活跃链接实际上就造成了线程池中所有线程阻塞。这意味着服务器响应变慢甚至是没有反应。</p><p>一些服务器尝试通过弹性控制线程池的核心线程数量这一设计减轻这一问题。例如,如果线程池线程不足时,线程池可能开启更多的线程处理请求。这一方案意味着需要大量的长时链接才能使服务器不响应。但是记住,对于并发线程数任然是有一个上限的。因此,这一方案仍然无法很好地解决一百万个长时链接。</p><h3 id="基础非阻塞式IO管道设计"><a href="#基础非阻塞式IO管道设计" class="headerlink" title="基础非阻塞式IO管道设计"></a>基础非阻塞式IO管道设计</h3><p>一个非阻塞式IO管道可以使用一个单独的线程向多个流读取数据。这需要流可以被切换到非阻塞模式。在非阻塞模式下,当你读取流信息时可能会返回0个字节或更多字节的信息。如果流中没有数据可读就返回0字节,如果流中有数据可读就返回1+字节。</p><p>为了避免检查没有可读数据的流我们可以使用 Java NIO Selector. 一个或多个SelectableChannel 实例可以同时被一个Selector注册。<strong>当你调用Selector的select()或者 selectNow() 方法它只会返回有数据读取的SelectableChannel的实例</strong>. 下图是该设计的示意图:</p><p><a href="//qn.atecher.com/non-blocking-server-4.png"><img src="//qn.atecher.com/non-blocking-server-4.png" alt=""></a></p><h3 id="读取部分消息"><a href="#读取部分消息" class="headerlink" title="读取部分消息"></a>读取部分消息</h3><p>当我们从一个SelectableChannel读取一个数据包时,我们不知道这个数据包相比于源文件是否有丢失或者重复数据(原文是:When we read a block of data from a SelectableChannel we do not know if that data block contains less or more than a message)。一个数据包可能的情况有:缺失数据(比原有消息的数据少)、与原有一致、比原来的消息的数据更多(例如:是原来的1.5或者2.5倍)。数据包可能出现的情况如下图所示:</p><p><a href="//qn.atecher.com/non-blocking-server-5.png"><img src="//qn.atecher.com/non-blocking-server-5.png" alt=""></a></p><p>在处理类似上面这样部分信息时,有两个问题:</p><ul><li>判断你是否能在数据包中获取完整的消息。</li><li>在其余消息到达之前如何处理已到达的部分消息。</li></ul><p>判断消息的完整性需要消息读取器(Message Reader)在数据包中寻找是否存在至少一个完整消息体的数据。如果一个数据包包含一个或多个完整消息体,这些消息就能够被发送到管道进行处理。寻找完整消息体这一处理可能会重复多次,因此这一操作应该尽可能的快。</p><p>判断消息完整性和存储部分消息都是消息读取器(Message Reader)的责任。为了避免混合来自不同Channel的消息,我们将对每一个Channel使用一个Message Reader。设计如下图所示:</p><p><a href="//qn.atecher.com/non-blocking-server-6.png"><img src="//qn.atecher.com/non-blocking-server-6.png" alt=""></a></p><p>在从Selector得到可从中读取数据的Channel实例之后, 与该Channel相关联的Message Reader读取数据并尝试将他们分解为消息。这样读出的任何完整消息可以被传到读取通道(read pipeline)任何需要处理这些消息的组件中。</p><p>一个Message Reader一定满足特定的协议。Message Reader需要知道它尝试读取的消息的消息格式。如果我们的服务器可以通过协议来复用,那它需要有能够插入Message Reader实现的功能 – 可能通过接收一个Message Reader工厂作为配置参数。</p><h3 id="存储部分消息"><a href="#存储部分消息" class="headerlink" title="存储部分消息"></a>存储部分消息</h3><p>现在我们已经确定Message Reader有责任存储部分消息,直到收到完整的消息,我们需要弄清楚这些部分消息的存储应该如何实现。</p><p>有两个设计因素我们要考虑:</p><ul><li>我们想尽可能少地复制消息数据。复制越多,性能越低。</li><li>我们希望将完整的消息存储在连续的字节序列中,使解析消息更容易。</li></ul><h4 id="每个Message-Reader的缓冲区"><a href="#每个Message-Reader的缓冲区" class="headerlink" title="每个Message Reader的缓冲区"></a>每个Message Reader的缓冲区</h4><p>很显然部分消息需要存储某些缓冲区中。简单的实现方式可以是每一个Message Reader内部简单地有一个缓冲区。但是这个缓冲区应该多大？它要大到足够储存最大允许储存消息。因此,如果最大允许储存消息是1MB,那么Message Reader内部缓冲区将至少需要1MB。</p><p>当我们的链接达到百万数量级,每个链接都使用1MB并没有什么作用。1,000,000 * 1MB仍然是1TB的内存！那如果最大的消息是16MB甚至是128MB呢？</p><h4 id="大小可调的缓冲区"><a href="#大小可调的缓冲区" class="headerlink" title="大小可调的缓冲区"></a>大小可调的缓冲区</h4><p>另一个选择是在Message Reader内部实现一个大小可调的缓冲区。大小可调的缓冲区开始的时候很小,如果它获取的消息过大,那缓冲区会扩大。这样每一条链接就不一定需要如1MB的缓冲区。每条链接的缓冲区只要需要足够储存下一条消息的内存就行了。</p><p>有几个可实现可调大小缓冲区的方法。它们都各自有自己的优缺点,所以接下来的部分我将逐个讨论。</p><p><strong>通过复制调整大小</strong></p><p>实现可调大小缓冲区的第一种方式是从一个大小(例如:4KB)的缓冲区开始。如果4KB的缓冲区装不下一个消息,则会分配一个更大的缓冲区(如:8KB),并将大小为4KB的缓冲区数据复制到这个更大的缓冲区中去。</p><p>通过复制实现大小可调缓冲区的优点在于消息的所有数据被保存在一个连续的字节数组中,这就使得消息的解析更加容易。它的缺点就是在复制更大消息的时候会导致大量的数据。</p><p>为了减少消息的复制,你可以分析流进你系统的消息的大小,并找出尽量减少复制量的缓冲区的大小。例如,你可能看到大多数消息都小于4KB,这是因为它们都仅包含很小的 request/responses。这意味着缓冲区的初始值应该设为4KB。</p><p>然后你可能有一个消息大于4KB,这通常是因为它里面包含一个文件。你可能注意到大多数流进系统的文件都是小于128KB的。这样第二个缓冲区的大小设置为128KB就较为合理。</p><p>最后你可能会发现一旦消息超过128KB之后,消息的大小就没有什么固定的模式,因此缓冲区最终的大小可能就是最大消息的大小。</p><p>根据流经系统的消息大小,上面三种缓冲区大小可以减少数据的复制。小于4KB的消息将不会复制。对于一百万个并发链接其结果是:1,000,000 * 4KB = 4GB,对于目前大多数服务器还是有可能的。介于4KB – 128KB的消息将只会复制一次,并且只有4KB的数据复制进128KB的缓冲区中。介于128KB至最大消息大小的消息将会复制两次。第一次复制4KB,第二次复制128KB,所以最大的消息总共复制了132KB。假设没有那么多超过128KB大小的消息那还是可以接受的。</p><p>一旦消息处理完毕,那么分配的内存将会被清空。这样在同一链接接收到的下一条消息将会再次从最小缓冲区大小开始算。这样做的必要性是确保了不同连接间内存的有效共享。所有的连接很有可能在同一时间并不需要打的缓冲区。</p><p>我有一篇介绍如何实现这样支持可调整大小的数组的内存缓冲区的完整文章:</p><p>Resizable Arrays(<a href="http://tutorials.jenkov.com/java-performance/resizable-array.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-performance/resizable-array.html</a>)</p><p>文章包含一个GitHub仓库连接,其中的代码演示了是如何实现的。</p><p><strong>通过追加调整大小</strong></p><p>调整缓冲区大小的另一种方法是使缓冲区由多个数组组成。当你需要调整缓冲区大小时,你只需要另一个字节数组并将数据写进去就行了。</p><p>这里有两种方法扩张一个缓冲区。一个方法是分配单独的字节数组,并将这些数组保存在一个列表中。另一个方法是分配较大的共享字节数组的片段,然后保留分配给缓冲区的片段的列表。就个人而言,我觉得片段的方式会好些,但是差别不大。</p><p>通过追加单独的数组或片段来扩展缓冲区的优点在于写入过程中不需要复制数据。所有的数据可以直接从socket (Channel)复制到一个数组或片段中。</p><p>以这种方式扩展缓冲区的缺点是在于数据不是存储在单独且连续的数组中。这将使得消息的解析更困难,因为解析器需要同时查找每个单独数组的结尾处和所有数组的结尾处。由于你需要在写入的数据中查找消息的结尾,所以该模型并不容易使用。</p><h3 id="TLV编码消息"><a href="#TLV编码消息" class="headerlink" title="TLV编码消息"></a>TLV编码消息</h3><p>一些协议消息格式是使用TLV格式(类型(Type)、长度(Length)、值(Value))编码。这意味着当消息到达时,消息的总长度被存储在消息的开头。这一方式你可以立即知道应该对整个消息分配多大的内存。</p><p>TLV编码使得内存管理变得更加容易。你可以立即知道要分配多大的内存给这个消息。只有部分在结束时使用的缓冲区才会使得内存浪费。</p><p>TLV编码的一个缺点是你要在消息的所有数据到达之前就分配好这个消息需要的所有内存。一些慢连接可能因此分配完你所有可用内存,从而使得你的服务器无法响应。</p><p>此问题的解决方法是使用包含多个TLV字段的消息格式。因此,服务器是为每个字段分配内存而不是为整个消息分配内存,并且是字段到达之后再分配内存。然而,一个大消息中的一个大字段在你的内存管理有同样的影响。</p><p>另外一个方案就是对于还未到达的信息设置超时时间,例如10-15秒。当恰好有许多大消息到达服务器时,这个方案能够使得你的服务器可以恢复,但是仍然会造成服务器一段时间无法响应。另外,恶意的DoS(Denial of Service拒绝服务)攻击仍然可以分配完你服务器的所有内存。</p><p>TLV编码存在许多不同的形式。实际使用的字节数、自定字段的类型和长度都依赖于每一个TLV编码。TLV编码首先放置字段的长度、然后是类型、然后是值(一个LTV编码)。 虽然字段的顺序不同,但它仍然是TLV的一种。</p><p>TLV编码使内存管理更容易这一事实,其实是HTTP 1.1是如此可怕的协议的原因之一。 这是他们试图在HTTP 2.0中修复数据的问题之一,数据在LTV编码帧中传输。 这也是为什么我们使用TLV编码的VStack.co project 设计了我们自己的网络协议。</p><h3 id="写部分数据"><a href="#写部分数据" class="headerlink" title="写部分数据"></a>写部分数据</h3><p>在非阻塞IO管道中写数据仍然是一个挑战。当你调用一个处于非阻塞式Channel对象的write(ByteBuffer)方法时,ByteBuffer写入多少数据是无法保证的。write(ByteBuffer)方法会返回写入的字节数,因此可以跟踪写入的字节数。这就是挑战:跟踪部分写入的消息,以便最终可以发送一条消息的所有字节。</p><p>为了管理部分消息写入Channel,我们将创建一个消息写入器(Message Writer)。就像Message Reader一样,每一个要写入消息的Channel我们都需要一个Message Writer。在每个Message Writer中,我们跟踪正在写入的消息的字节数。</p><p>如果达到的消息量超过Message Writer可直接写入Channel的消息量,消息就需要在Message Writer排队。然后Message Writer尽快地将消息写入到Channel中。</p><p>下图是部分消息如何写入的设计图:</p><p><a href="//qn.atecher.com/non-blocking-server-8.png"><img src="//qn.atecher.com/non-blocking-server-8.png" alt=""></a></p><p>为了使Message Writer能够尽快发送数据,Message Writer需要能够不时被调用,这样就能发送更多的消息。</p><p>如果你又大量的连接那你将需要大量的Message Writer实例。检查Message Writer实例(如:一百万个)看写任何数据时是否缓慢。 首先,许多Message Writer实例都没有任何消息要发送,我们并不想检查那些Message Writer实例。其次,并不是所有的Channel实例都可以准备好写入数据。 我们不想浪费时间尝试将数据写入无法接受任何数据的Channel。</p><p>为了检查Channel是否准备好进行写入,您可以使用Selector注册Channel。然而我们并不想将所有的Channel实例注册到Selector中去。想象一下,如果你有1,000,000个连接且其中大多是空闲的,并且所有的连接已经与Selector注册。然后当你调用select()时,这些Channel实例的大部分将被写入就绪(它们大都是空闲的,记得吗？)然后你必须检查所有这些连接的Message Writer,以查看他们是否有任何数据要写入。</p><p>为了避免检查所有消息的Message Writer实例和所有不可能被写入任何信息的Channel实例,我们使用这两步的方法:</p><ul><li>当一个消息被写入Message Writer,Message Writer向Selector注册其相关Channel(如果尚未注册)。</li><li>当你的服务器有时间时,它检查Selector以查看哪些注册的Channel实例已准备好进行写入。 对于每个写就绪Channel,请求其关联的Message Writer将数据写入Channel。 如果Message Writer将其所有消息写入其Channel,则Channel将再次从Selector注册。</li></ul><p>这两个小步骤确保了有消息写入的Channel实际上已经被Selector注册了。</p><h3 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h3><p>正如你所见,一个非阻塞式服务器需要时不时检查输入的消息来判断是否有任何的新的完整的消息发送过来。服务器可能会在一个或多个完整消息发来之前就检查了多次。检查一次是不够的。</p><p>同样,一个非阻塞式服务器需要时不时检查是否有任何数据需要写入。如果有,服务器需要检查是否有任何相应的连接准备好将该数据写入它们。只有在第一次排队消息时才检查是不够的,因为消息可能被部分写入。</p><p>所有这些非阻塞服务器最终都需要定期执行的三个“管道”(pipelines)::</p><p>读取管道(The read pipeline),用于检查是否有新数据从开放连接进来的。<br>处理管道(The process pipeline),用于所有任何完整消息。<br>写入管道(The write pipeline),用于检查是否可以将任何传出的消息写入任何打开的连接。<br>这三条管道在循环中重复执行。你可能可以稍微优化执行。例如,如果没有排队的消息可以跳过写入管道。 或者,如果我们没有收到新的,完整的消息,也许您可以跳过流程管道。</p><p>以下是说明完整服务器循环的图:</p><p><a href="//qn.atecher.com/non-blocking-server-9.png"><img src="//qn.atecher.com/non-blocking-server-9.png" alt=""></a></p><p>如果仍然发现这有点复杂,请记住查看GitHub资料库:<a href="https://github.com/jjenkov/java-nio-server" target="_blank" rel="noopener">https://github.com/jjenkov/java-nio-server</a></p><p>也许看到正在执行的代码可能会帮助你了解如何实现这一点。</p><h3 id="服务器线程模型"><a href="#服务器线程模型" class="headerlink" title="服务器线程模型"></a>服务器线程模型</h3><p>GitHub资源库里面的非阻塞式服务器实现使用了两个线程的线程模式。第一个线程用来接收来自ServerSocketChannel的传入连接。第二个线程处理接受的连接,意思是读取消息,处理消息并将响应写回连接。这两个线程模型的图解如下:</p><p><a href="//qn.atecher.com/non-blocking-server-10.png"><img src="//qn.atecher.com/non-blocking-server-10.png" alt=""></a></p><p>上一节中说到的服务器循环处理是由处理线程(Processor Thread)执行。</p><h2 id="Java-NIO-DatagramChannel"><a href="#Java-NIO-DatagramChannel" class="headerlink" title="Java NIO DatagramChannel"></a>Java NIO DatagramChannel</h2><p>Java NIO中的DatagramChannel是一个能收发UDP包的通道。因为UDP是无连接的网络协议,所以不能像其它通道那样读取和写入。它发送和接收的是数据包。</p><h3 id="打开-DatagramChannel"><a href="#打开-DatagramChannel" class="headerlink" title="打开 DatagramChannel"></a>打开 DatagramChannel</h3><p>下面是 DatagramChannel 的打开方式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DatagramChannel channel = DatagramChannel.open();</span><br><span class="line">channel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br></pre></td></tr></table></figure></p><p>这个例子打开的 DatagramChannel可以在UDP端口9999上接收数据包。</p><h3 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h3><p>通过receive()方法从DatagramChannel接收数据,如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">channel.receive(buf);</span><br></pre></td></tr></table></figure></p><p>receive()方法会将接收到的数据包内容复制到指定的Buffer. 如果Buffer容不下收到的数据,多出的数据将被丢弃。</p><h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><p>通过send()方法从DatagramChannel发送数据,如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesSent = channel.send(buf, <span class="keyword">new</span> InetSocketAddress(<span class="string">"jenkov.com"</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure></p><p>这个例子发送一串字符到”jenkov.com”服务器的UDP端口80。 因为服务端并没有监控这个端口,所以什么也不会发生。也不会通知你发出的数据包是否已收到,因为UDP在数据传送方面没有任何保证。</p><h3 id="连接到特定的地址"><a href="#连接到特定的地址" class="headerlink" title="连接到特定的地址"></a>连接到特定的地址</h3><p>可以将DatagramChannel“连接”到网络中的特定地址的。由于UDP是无连接的,连接到特定地址并不会像TCP通道那样创建一个真正的连接。而是锁住DatagramChannel ,让其只能从特定地址收发数据。</p><p>这里有个例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"jenkov.com"</span>, <span class="number">80</span>));</span><br></pre></td></tr></table></figure></p><p>当连接后,也可以使用read()和write()方法,就像在用传统的通道一样。只是在数据传送方面没有任何保证。这里有几个例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> bytesRead = channel.read(buf);</span><br><span class="line"><span class="keyword">int</span> bytesWritten = channel.write(but);</span><br></pre></td></tr></table></figure></p><h2 id="Pipe"><a href="#Pipe" class="headerlink" title="Pipe"></a>Pipe</h2><p>Java NIO 管道是2个线程之间的单向数据连接。Pipe有一个source通道和一个sink通道。数据会被写到sink通道,从source通道读取。</p><p>这里是Pipe原理的图示:</p><p><a href="//qn.atecher.com/pipe.bmp"><img src="//qn.atecher.com/pipe.bmp" alt=""></a></p><h3 id="创建管道"><a href="#创建管道" class="headerlink" title="创建管道"></a>创建管道</h3><p>通过Pipe.open()方法打开管道。例如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe pipe = Pipe.open();</span><br></pre></td></tr></table></figure></p><h3 id="向管道写数据"><a href="#向管道写数据" class="headerlink" title="向管道写数据"></a>向管道写数据</h3><p>要向管道写数据,需要访问sink通道。像这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe.SinkChannel sinkChannel = pipe.sink();</span><br></pre></td></tr></table></figure></p><p>通过调用SinkChannel的write()方法,将数据写入SinkChannel,像这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String newData = <span class="string">"New String to write to file..."</span> + System.currentTimeMillis();</span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">buf.clear();</span><br><span class="line">buf.put(newData.getBytes());</span><br><span class="line"></span><br><span class="line">buf.flip();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buf.hasRemaining()) &#123;</span><br><span class="line">    sinkChannel.write(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="从管道读取数据"><a href="#从管道读取数据" class="headerlink" title="从管道读取数据"></a>从管道读取数据</h3><p>从读取管道的数据,需要访问source通道,像这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Pipe.SourceChannel sourceChannel = pipe.source();</span><br></pre></td></tr></table></figure></p><p>调用source通道的read()方法来读取数据,像这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = sourceChannel.read(buf);</span><br></pre></td></tr></table></figure></p><p>read()方法返回的int值会告诉我们多少字节被读进了缓冲区。</p><h2 id="Java-NIO与IO"><a href="#Java-NIO与IO" class="headerlink" title="Java NIO与IO"></a>Java NIO与IO</h2><p>当学习了Java NIO和IO的API后,一个问题马上涌入脑海:</p><p>我应该何时使用IO,何时使用NIO呢？在本文中,我会尽量清晰地解析Java NIO和IO的差异、它们的使用场景,以及它们如何影响您的代码设计。</p><h3 id="Java-NIO和IO的主要区别"><a href="#Java-NIO和IO的主要区别" class="headerlink" title="Java NIO和IO的主要区别"></a>Java NIO和IO的主要区别</h3><p>下表总结了Java NIO和IO之间的主要差别,我会更详细地描述表中每部分的差异。</p><table><thead><tr><th style="text-align:left">IO</th><th style="text-align:left">NIO</th></tr></thead><tbody><tr><td style="text-align:left">面向流</td><td style="text-align:left">面向缓冲</td></tr><tr><td style="text-align:left">阻塞IO</td><td style="text-align:left">非阻塞IO</td></tr><tr><td style="text-align:left">无</td><td style="text-align:left">选择器</td></tr></tbody></table><h4 id="面向流与面向缓冲"><a href="#面向流与面向缓冲" class="headerlink" title="面向流与面向缓冲"></a>面向流与面向缓冲</h4><p>Java NIO和IO之间第一个最大的区别是,IO是面向流的,NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节,直至读取所有字节,它们没有被缓存在任何地方。此外,它不能前后移动流中的数据。如果需要前后移动从流中读取的数据,需要先将它缓存到一个缓冲区。 Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区,需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是,还需要检查是否该缓冲区中包含所有您需要处理的数据。而且,需确保当更多的数据读入缓冲区时,不要覆盖缓冲区里尚未处理的数据。</p><h4 id="阻塞与非阻塞IO"><a href="#阻塞与非阻塞IO" class="headerlink" title="阻塞与非阻塞IO"></a>阻塞与非阻塞IO</h4><p>Java IO的各种流是阻塞的。这意味着,当一个线程调用read() 或 write()时,该线程被阻塞,直到有一些数据被读取,或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式,使一个线程从某通道发送请求读取数据,但是它仅能得到目前可用的数据,如果目前没有数据可用时,就什么都不会获取。而不是保持线程阻塞,所以直至数据变的可以读取之前,该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道,但不需要等待它完全写入,这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作,所以一个单独的线程现在可以管理多个输入和输出通道(channel)。</p><h4 id="选择器-Selectors"><a href="#选择器-Selectors" class="headerlink" title="选择器(Selectors)"></a>选择器(Selectors)</h4><p>Java NIO的选择器允许一个单独的线程来监视多个输入通道,你可以注册多个通道使用一个选择器,然后使用一个单独的线程来“选择”通道:这些通道里已经有可以处理的输入,或者选择已准备写入的通道。这种选择机制,使得一个单独的线程很容易来管理多个通道。</p><h3 id="NIO和IO如何影响应用程序的设计"><a href="#NIO和IO如何影响应用程序的设计" class="headerlink" title="NIO和IO如何影响应用程序的设计"></a>NIO和IO如何影响应用程序的设计</h3><p>无论您选择IO或NIO工具箱,可能会影响您应用程序设计的以下几个方面:</p><ol><li>对NIO或IO类的API调用。</li><li>数据处理。</li><li>用来处理数据的线程数。</li></ol><h3 id="API调用"><a href="#API调用" class="headerlink" title="API调用"></a>API调用</h3><p>当然,使用NIO的API调用时看起来与使用IO时有所不同,但这并不意外,因为并不是仅从一个InputStream逐字节读取,而是数据必须先读入缓冲区再处理。</p><h3 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h3><p>使用纯粹的NIO设计相较IO设计,数据处理也受到影响。</p><p>在IO设计中,我们从InputStream或 Reader逐字节读取数据。假设你正在处理一基于行的文本数据流,例如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name: Anna</span><br><span class="line">Age: 25</span><br><span class="line">Email: anna@mailserver.com</span><br><span class="line">Phone: 1234567890</span><br></pre></td></tr></table></figure></p><p>该文本行的流可以这样处理:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = ... ; <span class="comment">// get the InputStream from the client socket</span></span><br><span class="line">BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(input));</span><br><span class="line"></span><br><span class="line">String nameLine   = reader.readLine();</span><br><span class="line">String ageLine    = reader.readLine();</span><br><span class="line">String emailLine  = reader.readLine();</span><br><span class="line">String phoneLine  = reader.readLine();</span><br></pre></td></tr></table></figure></p><p>请注意处理状态由程序执行多久决定。换句话说,一旦reader.readLine()方法返回,你就知道肯定文本行就已读完, readline()阻塞直到整行读完,这就是原因。你也知道此行包含名称；同样,第二个readline()调用返回的时候,你知道这行包含年龄等。 正如你可以看到,该处理程序仅在有新数据读入时运行,并知道每步的数据是什么。一旦正在运行的线程已处理过读入的某些数据,该线程不会再回退数据(大多如此)。下图也说明了这条原则:</p><p><a href="//qn.atecher.com/nio-vs-io-1.png"><img src="//qn.atecher.com/nio-vs-io-1.png" alt=""></a></p><p>(Java IO: 从一个阻塞的流中读数据) 而一个NIO的实现会有所不同,下面是一个简单的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buffer);</span><br></pre></td></tr></table></figure></p><p>注意第二行,从通道读取字节到ByteBuffer。当这个方法调用返回时,你不知道你所需的所有数据是否在缓冲区内。你所知道的是,该缓冲区包含一些字节,这使得处理有点困难。<br>假设第一次 read(buffer)调用后,读入缓冲区的数据只有半行,例如,“Name:An”,你能处理数据吗？显然不能,需要等待,直到整行数据读入缓存,在此之前,对数据的任何处理毫无意义。</p><p>所以,你怎么知道是否该缓冲区包含足够的数据可以处理呢？好了,你不知道。发现的方法只能查看缓冲区中的数据。其结果是,在你知道所有数据都在缓冲区里之前,你必须检查几次缓冲区的数据。这不仅效率低下,而且可以使程序设计方案杂乱不堪。例如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buffer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(! bufferFull(bytesRead) ) &#123;</span><br><span class="line">    bytesRead = inChannel.read(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>bufferFull()方法必须跟踪有多少数据读入缓冲区,并返回真或假,这取决于缓冲区是否已满。换句话说,如果缓冲区准备好被处理,那么表示缓冲区满了。</p><p>bufferFull()方法扫描缓冲区,但必须保持在bufferFull()方法被调用之前状态相同。如果没有,下一个读入缓冲区的数据可能无法读到正确的位置。这是不可能的,但却是需要注意的又一问题。</p><p>如果缓冲区已满,它可以被处理。如果它不满,并且在你的实际案例中有意义,你或许能处理其中的部分数据。但是许多情况下并非如此。下图展示了“缓冲区数据循环就绪”:</p><p><a href="//qn.atecher.com/nio-vs-io-2.png"><img src="//qn.atecher.com/nio-vs-io-2.png" alt=""></a></p><p>Java NIO:从一个通道里读数据,直到所有的数据都读到缓冲区里.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>NIO可让您只使用一个(或几个)单线程管理多个通道(网络连接或文件),但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。</p><p>如果需要管理同时打开的成千上万个连接,这些连接每次只是发送少量的数据,例如聊天服务器,实现NIO的服务器可能是一个优势。同样,如果你需要维持许多打开的连接到其他计算机上,如P2P网络中,使用一个单独的线程来管理你所有出站连接,可能是一个优势。一个线程多个连接的设计方案如下图所示:</p><p><a href="//qn.atecher.com/nio-vs-io-3.png"><img src="//qn.atecher.com/nio-vs-io-3.png" alt=""></a></p><p>Java NIO: 单线程管理多个连接</p><p>如果你有少量的连接使用非常高的带宽,一次发送大量的数据,也许典型的IO服务器实现可能非常契合。下图说明了一个典型的IO服务器设计:</p><p><a href="//qn.atecher.com/nio-vs-io-4.png"><img src="//qn.atecher.com/nio-vs-io-4.png" alt=""></a></p><p>Java IO: 一个典型的IO服务器设计- 一个连接通过一个线程处理.</p><p>未完待续…</p><p>ref:<br><a href="http://ifeve.com/java-nio-all/" target="_blank" rel="noopener">http://ifeve.com/java-nio-all/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java NIO(New IO)是一个可以替代标准Java IO API的IO API(从Java 1.4开始),Java NIO提供了与标准IO不同的IO工作方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java NIO: Channels and Buffers(通道和缓冲区)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;标准的IO基于字节流和字符流进行操作的,而NIO是基于通道(Channel)和缓冲区(Buffer)进行操作,数据总是从通道读取到缓冲区中,或者从缓冲区写入到通道中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java NIO: Non-blocking IO(非阻塞IO)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java NIO可以让你非阻塞的使用IO,例如:当线程从通道读取数据到缓冲区时,线程还是可以进行其他事情。当数据被写入到缓冲区时,线程可以继续处理它。从缓冲区写入通道也类似。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java NIO: Selectors(选择器)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java NIO引入了选择器的概念,选择器用于监听多个通道的事件(比如:连接打开,数据到达)。因此,单个的线程可以监听多个数据通道。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.atecher.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.atecher.com/tags/Java/"/>
    
      <category term="NIO" scheme="http://blog.atecher.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Java-IO</title>
    <link href="http://blog.atecher.com/2017/10/09/Java-IO/"/>
    <id>http://blog.atecher.com/2017/10/09/Java-IO/</id>
    <published>2017-10-09T00:00:00.000Z</published>
    <updated>2022-01-28T10:28:39.119Z</updated>
    
    <content type="html"><![CDATA[<p>Java IO 是一套Java用来读写数据(输入和输出)的API。大部分程序都要处理一些输入,并由输入产生一些输出。Java为此提供了java.io包。</p><p>如果你浏览下java.io包,会对其中各样的类选择感到迷惑。这些类的作用都是什么？对于某个任务该选择哪个类？怎样创建你自己的类做插件？这个手册的目的就是给你介绍这些类是如何组织的,以及怎样使用他们,因此你就不会疑惑需要时怎样选取合适的类,或者是否有一个满足你需求的类已经存在了。</p><a id="more"></a><h2 id="Java-io-包的范围"><a href="#Java-io-包的范围" class="headerlink" title="Java.io 包的范围"></a>Java.io 包的范围</h2><p>java.io 包并没有涵盖所有输入输出类型。例如,并不包含GUI或者网页上的输入输出,这些输入和输出在其它地方都涉及,比如Swing工程中的JFC (Java Foundation Classes) 类,或者J2EE里的Servlet和HTTP包。<br>Java.io 包主要涉及文件,网络数据流,内存缓冲等的输入输出。</p><h2 id="更多的Java-IO工具-提示等"><a href="#更多的Java-IO工具-提示等" class="headerlink" title="更多的Java IO工具,提示等"></a>更多的Java IO工具,提示等</h2><p>这个手册也被称为” <a href="http://tutorials.jenkov.com/java-howto/index.html" target="_blank" rel="noopener">Java How To’s and Utilities</a> ”,包含一些Java IO的工具,例如替换流数据中的字符串,使用缓冲来反复处理流数据。</p><h2 id="此Java-IO-手册的范围"><a href="#此Java-IO-手册的范围" class="headerlink" title="此Java IO 手册的范围"></a>此Java IO 手册的范围</h2><p>这个手册开始部分会给你一个Java IO API 工作的概览,以及你该怎样使用这些他们,接着会介绍包括所有Java IO API 的核心类。<br>这个手册不只是一个API的列表,这样的列表你可以从Sun公司的官方Java文档获得。事实上,每篇文档都是对一个类的简要介绍,设计它的目的以及一些实用的例子。换句话说,这些内容你在Sun公司的官方文档上是找不到的。</p><h2 id="Java-IO-概述"><a href="#Java-IO-概述" class="headerlink" title="Java IO 概述"></a>Java IO 概述</h2><p>在这一小节,我会试着给出Java IO(java.io)包下所有类的概述。更具体地说,我会根据类的用途对类进行分组。这个分组将会使你在未来的工作中,进行类的用途判定时,或者是为某个特定用途选择类时变得更加容易。</p><h3 id="输入和输出-–-数据源和目标媒介"><a href="#输入和输出-–-数据源和目标媒介" class="headerlink" title="输入和输出 – 数据源和目标媒介"></a>输入和输出 – 数据源和目标媒介</h3><p>术语“输入”和“输出”有时候会有一点让人疑惑。一个应用程序的输入往往是另外一个应用程序的输出。那么OutputStream流到底是一个输出到目的地的流呢,还是一个产生输出的流？InputStream流到底会不会输出它的数据给读取数据的程序呢？就我个人而言,在第一天学习Java IO的时候我就感觉到了一丝疑惑。(校对注:输入流可以理解为向内存输入,输出流可以理解为从内存输出)</p><p>为了消除这个疑惑,我试着给输入和输出起一些不一样的别名,让它们从概念上与数据的来源和数据的流向相联系。</p><p>Java的IO包主要关注的是从原始数据源的读取以及输出原始数据到目标媒介。以下是最典型的数据源和目标媒介:</p><ul><li>文件</li><li>管道</li><li>网络连接</li><li>内存缓存</li><li>System.in, System.out, System.error(注:Java标准输入、输出、错误输出)</li></ul><p>下面这张图描绘了一个程序从数据源读取数据,然后将数据输出到其他媒介的原理:</p><p><a href="//qn.atecher.com/无标题1.png"><img src="//qn.atecher.com/无标题1.png" alt=""></a></p><h3 id="流"><a href="#流" class="headerlink" title="流"></a>流</h3><p>在Java IO中,流是一个核心的概念。流从概念上来说是一个连续的数据流。你既可以从流中读取数据,也可以往流中写数据。流与数据源或者数据流向的媒介相关联。在Java IO中流既可以是字节流(以字节为单位进行读写),也可以是字符流(以字符为单位进行读写)。</p><h3 id="类InputStream-OutputStream-Reader-和Writer"><a href="#类InputStream-OutputStream-Reader-和Writer" class="headerlink" title="类InputStream, OutputStream, Reader 和Writer"></a>类InputStream, OutputStream, Reader 和Writer</h3><p>一个程序需要InputStream或者Reader从数据源读取数据,需要OutputStream或者Writer将数据写入到目标媒介中。以下的图说明了这一点:</p><p><a href="//qn.atecher.com/无标题2.png"><img src="//qn.atecher.com/无标题2.png" alt=""></a></p><p>InputStream和Reader与数据源相关联,OutputStream和writer与目标媒介相关联。</p><p>Java IO中包含了许多InputStream、OutputStream、Reader、Writer的子类。这样设计的原因是让每一个类都负责不同的功能。这也就是为什么IO包中有这么多不同的类的缘故。各类用途汇总如下:</p><ul><li>文件访问</li><li>网络访问</li><li>内存缓存访问</li><li>线程内部通信(管道)</li><li>缓冲</li><li>过滤</li><li>解析</li><li>读写文本 (Readers / Writers)</li><li>读写基本类型数据 (long, int etc.)</li><li>读写对象</li></ul><p>当通读过Java IO类的源代码之后,我们很容易就能了解这些用途。这些用途或多或少让我们更加容易地理解,不同的类用于针对不同业务场景。</p><h3 id="Java-IO类概述表"><a href="#Java-IO类概述表" class="headerlink" title="Java IO类概述表"></a>Java IO类概述表</h3><p>已经讨论了数据源、目标媒介、输入、输出和各类不同用途的Java IO类,接下来是一张通过输入、输出、基于字节或者字符、以及其他比如缓冲、解析之类的特定用途划分的大部分Java IO类的表格。</p><p><a href="//qn.atecher.com/QQ截图20141020174145.png"><img src="//qn.atecher.com/QQ截图20141020174145.png" alt=""></a></p><h2 id="Java-IO-文件"><a href="#Java-IO-文件" class="headerlink" title="Java IO: 文件"></a>Java IO: 文件</h2><p>在Java应用程序中,文件是一种常用的数据源或者存储数据的媒介。所以这一小节将会对Java中文件的使用做一个简短的概述。这篇文章不会对每一个技术细节都做出解释,而是会针对文件存取的方法提供给你一些必要的知识点。在之后的文章中,将会更加详细地描述这些方法或者类,包括方法示例等等。</p><h3 id="通过Java-IO读文件"><a href="#通过Java-IO读文件" class="headerlink" title="通过Java IO读文件"></a>通过Java IO读文件</h3><p>如果你需要在不同端之间读取文件,你可以根据该文件是二进制文件还是文本文件来选择使用FileInputStream或者FileReader。这两个类允许你从文件开始到文件末尾一次读取一个字节或者字符,或者将读取到的字节写入到字节数组或者字符数组。你不必一次性读取整个文件,相反你可以按顺序地读取文件中的字节和字符。</p><p>如果你需要跳跃式地读取文件其中的某些部分,可以使用RandomAccessFile。</p><h3 id="通过Java-IO写文件"><a href="#通过Java-IO写文件" class="headerlink" title="通过Java IO写文件"></a>通过Java IO写文件</h3><p>如果你需要在不同端之间进行文件的写入,你可以根据你要写入的数据是二进制型数据还是字符型数据选用FileOutputStream或者FileWriter。你可以一次写入一个字节或者字符到文件中,也可以直接写入一个字节数组或者字符数据。数据按照写入的顺序存储在文件当中。</p><h3 id="通过Java-IO随机存取文件"><a href="#通过Java-IO随机存取文件" class="headerlink" title="通过Java IO随机存取文件"></a>通过Java IO随机存取文件</h3><p>正如我所提到的,你可以通过RandomAccessFile对文件进行随机存取。</p><p>随机存取并不意味着你可以在真正随机的位置进行读写操作,它只是意味着你可以跳过文件中某些部分进行操作,并且支持同时读写,不要求特定的存取顺序。这使得RandomAccessFile可以覆盖一个文件的某些部分、或者追加内容到它的末尾、或者删除它的某些内容,当然它也可以从文件的任何位置开始读取文件</p><h3 id="文件和目录信息的获取"><a href="#文件和目录信息的获取" class="headerlink" title="文件和目录信息的获取"></a>文件和目录信息的获取</h3><p>有时候你可能需要读取文件的信息而不是文件的内容,举个例子,如果你需要知道文件的大小和文件的属性。对于目录来说也是一样的,比如你需要获取某个目录下的文件列表。通过File类可以获取文件和目录的信息。</p><h2 id="Java-IO-管道"><a href="#Java-IO-管道" class="headerlink" title="Java IO: 管道"></a>Java IO: 管道</h2><p>Java IO中的管道为运行在同一个JVM中的两个线程提供了通信的能力。所以管道也可以作为数据源以及目标媒介。</p><p>你不能利用管道与不同的JVM中的线程通信(不同的进程)。在概念上,Java的管道不同于Unix/Linux系统中的管道。在Unix/Linux中,运行在不同地址空间的两个进程可以通过管道通信。在Java中,通信的双方应该是运行在同一进程中的不同线程。</p><h3 id="通过Java-IO创建管道"><a href="#通过Java-IO创建管道" class="headerlink" title="通过Java IO创建管道"></a>通过Java IO创建管道</h3><p>可以通过Java IO中的PipedOutputStream和PipedInputStream创建管道。一个PipedInputStream流应该和一个PipedOutputStream流相关联。一个线程通过PipedOutputStream写入的数据可以被另一个线程通过相关联的PipedInputStream读取出来。</p><h3 id="Java-IO管道示例"><a href="#Java-IO管道示例" class="headerlink" title="Java IO管道示例"></a>Java IO管道示例</h3><p>这是一个如何将PipedInputStream和PipedOutputStream关联起来的简单例子:</p><p><a href="//qn.atecher.com/1.png"><img src="//qn.atecher.com/1.png" alt=""></a></p><p>注:本例忽略了流的关闭。请在处理流的过程中,务必保证关闭流,或者使用jdk7引入的try-resources代替显示地调用close方法的方式。</p><p>你也可以使用两个管道共有的connect()方法使之相关联。PipedInputStream和PipedOutputStream都拥有一个可以互相关联的connect()方法。</p><h3 id="管道和线程"><a href="#管道和线程" class="headerlink" title="管道和线程"></a>管道和线程</h3><p>请记得,当使用两个相关联的管道流时,务必将它们分配给不同的线程。read()方法和write()方法调用时会导致流阻塞,这意味着如果你尝试在一个线程中同时进行读和写,可能会导致线程死锁。</p><h3 id="管道的替代"><a href="#管道的替代" class="headerlink" title="管道的替代"></a>管道的替代</h3><p>除了管道之外,一个JVM中不同线程之间还有许多通信的方式。实际上,线程在大多数情况下会传递完整的对象信息而非原始的字节数据。但是,如果你需要在线程之间传递字节数据,Java IO的管道是一个不错的选择。</p><h3 id="Java-IO-网络"><a href="#Java-IO-网络" class="headerlink" title="Java IO: 网络"></a>Java IO: 网络</h3><p>Java中网络的内容或多或少的超出了Java IO的范畴。关于Java网络更多的是在我的<a href="http://ifeve.com/java-network/" target="_blank" rel="noopener">Java网络教程</a>中探讨。但是既然网络是一个常见的数据来源以及数据流目的地,并且因为你使用Java IO的API通过网络连接进行通信,所以本文将简要的涉及网络应用。</p><p>当两个进程之间建立了网络连接之后,他们通信的方式如同操作文件一样:利用InputStream读取数据,利用OutputStream写入数据。换句话来说,Java网络API用来在不同进程之间建立网络连接,而Java IO则用来在建立了连接之后的进程之间交换数据。</p><p>基本上意味着如果你有一份能够对文件进行写入某些数据的代码,那么这些数据也可以很容易地写入到网络连接中去。你所需要做的仅仅只是在代码中利用OutputStream替代FileOutputStream进行数据的写入。因为FileOutputStream是OutputStream的子类,所以这么做并没有什么问题.<br>实际上对于文件的读操作也类似,一个具有读取文件数据功能的组件,同样可以轻松读取网络连接中的数据。只需要保证读取数据的组件是基于InputStream而非FileInputStream即可。<br>这是一份简单的代码示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\myfile.txt"</span>);</span><br><span class="line">        process(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(InputStream input)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//do something with the InputStream</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中,process()方法并不关心InputStream参数的输入流,是来自于文件还是网络(例子只展示了输入流来自文件的版本)。process()方法只会对InputStream进行操作。</p><h2 id="Java-IO-字节和字符数组"><a href="#Java-IO-字节和字符数组" class="headerlink" title="Java IO: 字节和字符数组"></a>Java IO: 字节和字符数组</h2><p>内容列表</p><ul><li>从InputStream或者Reader中读入数组</li><li>从OutputStream或者Writer中写数组</li></ul><p>在java中常用字节和字符数组在应用中临时存储数据。而这些数组又是通常的数据读取来源或者写入目的地。如果你需要在程序运行时需要大量读取文件里的内容,那么你也可以把一个文件加载到数组中。当然你可以通过直接指定索引来读取这些数组。但如果设计成为从InputStream或者Reader,而不是从数组中读取某些数据的话,你会用什么组件呢？</p><h3 id="从-InputStream-或-Reader中读取数组"><a href="#从-InputStream-或-Reader中读取数组" class="headerlink" title="从 InputStream 或 Reader中读取数组"></a>从 InputStream 或 Reader中读取数组</h3><p>用ByteArrayInputStream或者CharArrayReader封装字节或者字符数组从数组中读取数据。通过这种方式字节和字符就可以以数组的形式读出了。<br>样例如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//把数据写入字节数组...</span></span><br><span class="line">InputStream input = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取第一个字节</span></span><br><span class="line"><span class="keyword">int</span> data = input.read();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//操作数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读下一个字节</span></span><br><span class="line">    data = input.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以同样的方式也可以用于读取字符数组,只要把字符数组封装在CharArrayReader上就行了。</p><h3 id="通过-OutputStream-或者-Writer写数组"><a href="#通过-OutputStream-或者-Writer写数组" class="headerlink" title="通过 OutputStream 或者 Writer写数组"></a>通过 OutputStream 或者 Writer写数组</h3><p>同样,也可以把数据写到ByteArrayOutputStream或者CharArrayWriter中。你只需要创建ByteArrayOutputStream或者CharArrayWriter,把数据写入,就像写其它的流一样。当所有的数据都写进去了以后,只要调用toByteArray()或者toCharArray,所有写入的数据就会以数组的形式返回。</p><p>样例如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">OutputStream output = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">output.write(<span class="string">"This text is converted to bytes"</span>.toBytes(<span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bytes = output.toByteArray();</span><br></pre></td></tr></table></figure></p><p>写字符数组也和此例子类似。只要把字符数组封装在CharArrayWriter上就可以了。</p><h2 id="Java-IO-System-in-System-out-System-err"><a href="#Java-IO-System-in-System-out-System-err" class="headerlink" title="Java IO: System.in, System.out, System.err"></a>Java IO: System.in, System.out, System.err</h2><p>System.in, System.out, System.err这3个流同样是常见的数据来源和数据流目的地。使用最多的可能是在控制台程序里利用System.out将输出打印到控制台上。</p><p>JVM启动的时候通过Java运行时初始化这3个流,所以你不需要初始化它们(尽管你可以在运行时替换掉它们)。</p><h3 id="System-in"><a href="#System-in" class="headerlink" title="System.in"></a>System.in</h3><p>System.in是一个典型的连接控制台程序和键盘输入的InputStream流。通常当数据通过命令行参数或者配置文件传递给命令行Java程序的时候,System.in并不是很常用。图形界面程序通过界面传递参数给程序,这是一块单独的Java IO输入机制。</p><h3 id="System-out"><a href="#System-out" class="headerlink" title="System.out"></a>System.out</h3><p>System.out是一个PrintStream流。System.out一般会把你写到其中的数据输出到控制台上。System.out通常仅用在类似命令行工具的控制台程序上。System.out也经常用于打印程序的调试信息(尽管它可能并不是获取程序调试信息的最佳方式)。</p><h3 id="System-err"><a href="#System-err" class="headerlink" title="System.err"></a>System.err</h3><p>System.err是一个PrintStream流。System.err与System.out的运行方式类似,但它更多的是用于打印错误文本。一些类似Eclipse的程序,为了让错误信息更加显眼,会将错误信息以红色文本的形式通过System.err输出到控制台上。</p><h3 id="System-out和System-err的简单例子"><a href="#System-out和System-err的简单例子" class="headerlink" title="System.out和System.err的简单例子:"></a>System.out和System.err的简单例子:</h3><p>这是一个System.out和System.err结合使用的简单示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\..."</span>);</span><br><span class="line">    System.out.println(<span class="string">"File opened..."</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    System.err.println(<span class="string">"File opening failed:"</span>);</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="替换系统流"><a href="#替换系统流" class="headerlink" title="替换系统流"></a>替换系统流</h3><p>尽管System.in, System.out, System.err这3个流是java.lang.System类中的静态成员(译者注:这3个变量均为final static常量),并且已经预先在JVM启动的时候初始化完成,你依然可以更改它们。只需要把一个新的InputStream设置给System.in或者一个新的OutputStream设置给System.out或者System.err,之后的数据都将会在新的流中进行读取、写入。</p><p>可以使用System.setIn(), System.setOut(), System.setErr()方法设置新的系统流(译者注:这三个方法均为静态方法,内部调用了本地native方法重新设置系统流)。例子如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\system.out.txt"</span>);</span><br><span class="line">PrintStream printOut = <span class="keyword">new</span> PrintStream(output);</span><br><span class="line">System.setOut(printOut);</span><br></pre></td></tr></table></figure></p><p>现在所有的System.out都将重定向到”c:\data\system.out.txt”文件中。请记住,务必在JVM关闭之前冲刷System.out(译者注:调用flush()),确保System.out把数据输出到了文件中。</p><h2 id="Java-IO-流"><a href="#Java-IO-流" class="headerlink" title="Java IO: 流"></a>Java IO: 流</h2><p>Java IO流是既可以从中读取,也可以写入到其中的数据流。正如这个系列教程之前提到过的,流通常会与数据源、数据流向目的地相关联,比如文件、网络等等。</p><p>流和数组不一样,不能通过索引读写数据。在流中,你也不能像数组那样前后移动读取数据,除非使用<a href="http://tutorials.jenkov.com/java-io/randomaccessfile.html" target="_blank" rel="noopener">RandomAccessFile</a> 处理文件。流仅仅只是一个连续的数据流。</p><p>某些类似<a href="http://tutorials.jenkov.com/java-io/pushbackinputstream.html" target="_blank" rel="noopener">PushbackInputStream</a> 流的实现允许你将数据重新推回到流中,以便重新读取。然而你只能把有限的数据推回流中,并且你不能像操作数组那样随意读取数据。流中的数据只能够顺序访问。</p><p>Java IO流通常是基于字节或者基于字符的。字节流通常以“stream”命名,比如InputStream和OutputStream。除了<a href="http://tutorials.jenkov.com/java-io/datainputstream.html" target="_blank" rel="noopener">DataInputStream</a> 和<a href="http://tutorials.jenkov.com/java-io/dataoutputstream.html" target="_blank" rel="noopener">DataOutputStream</a> 还能够读写int, long, float和double类型的值以外,其他流在一个操作时间内只能读取或者写入一个原始字节。</p><p>字符流通常以“Reader”或者“Writer”命名。字符流能够读写字符(比如Latin1或者Unicode字符)。可以浏览<a href="http://tutorials.jenkov.com/java-io/readers-writers.html" target="_blank" rel="noopener">Java Readers and Writers</a>获取更多关于字符流输入输出的信息。</p><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><p>java.io.InputStream类是所有Java IO输入流的基类。如果你正在开发一个从流中读取数据的组件,请尝试用InputStream替代任何它的子类(比如FileInputStream)进行开发。这么做能够让你的代码兼容任何类型而非某种确定类型的输入流。</p><p>然而仅仅依靠InputStream并不总是可行。如果你需要将读过的数据推回到流中,你必须使用PushbackInputStream,这意味着你的流变量只能是这个类型,否则在代码中就不能调用PushbackInputStream的unread()方法。</p><p>通常使用输入流中的read()方法读取数据。read()方法返回一个整数,代表了读取到的字节的内容(译者注:0 ~ 255)。当达到流末尾没有更多数据可以读取的时候,read()方法返回-1。</p><p>这是一个简单的示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-file.txt"</span>);</span><br><span class="line"><span class="keyword">int</span> data = input.read(); </span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">        data = input.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><p>java.io.OutputStream是Java IO中所有输出流的基类。如果你正在开发一个能够将数据写入流中的组件,请尝试使用OutputStream替代它的所有子类。</p><p>这是一个简单的示例:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output-file.txt"</span>);</span><br><span class="line">output.write(<span class="string">"Hello World"</span>.getBytes());</span><br><span class="line">output.close();</span><br></pre></td></tr></table></figure></p><h3 id="组合流"><a href="#组合流" class="headerlink" title="组合流"></a>组合流</h3><p>你可以将流整合起来以便实现更高级的输入和输出操作。比如,一次读取一个字节是很慢的,所以可以从磁盘中一次读取一大块数据,然后从读到的数据块中获取字节。为了实现缓冲,可以把InputStream包装到BufferedInputStream中。代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-file.txt"</span>));</span><br></pre></td></tr></table></figure><p>缓冲同样可以应用到OutputStream中。你可以实现将大块数据批量地写入到磁盘(或者相应的流)中,这个功能由BufferedOutputStream实现。</p><p>缓冲只是通过流整合实现的其中一个效果。你可以把InputStream包装到PushbackInputStream中,之后可以将读取过的数据推回到流中重新读取,在解析过程中有时候这样做很方便。或者,你可以将两个InputStream整合成一个<a href="http://tutorials.jenkov.com/java-io/sequenceinputstream.html" target="_blank" rel="noopener">SequenceInputStream</a>。</p><p>将不同的流整合到一个链中,可以实现更多种高级操作。通过编写包装了标准流的类,可以实现你想要的效果和过滤器。</p><h2 id="Java-IO-Input-Parsing"><a href="#Java-IO-Input-Parsing" class="headerlink" title="Java IO: Input Parsing"></a>Java IO: Input Parsing</h2><p>Some of the classes in the Java IO API are designed to help you parse input. These classes are:</p><ul><li><a href="http://tutorials.jenkov.com/java-io/pushbackinputstream.html" target="_blank" rel="noopener">PusbackInputStream</a></li><li><a href="http://tutorials.jenkov.com/java-io/pushbackreader.html" target="_blank" rel="noopener">PusbackReader</a></li><li><a href="http://tutorials.jenkov.com/java-io/streamtokenizer.html" target="_blank" rel="noopener">StreamTokenizer</a></li><li><a href="http://tutorials.jenkov.com/java-io/pushbackreader.html" target="_blank" rel="noopener">PushbackReader</a></li><li><a href="http://tutorials.jenkov.com/java-io/linenumberreader.html" target="_blank" rel="noopener">LineNumberReader</a></li></ul><p>It is not the purpose of this text to give you a complete course in parsing of data. The purpose was rather to give you above quick list of classes related to parsing of input data.</p><p>If you have to parse data you will often end up writing your own classes that use some of the classes in this list. I know I did when I wrote the parser for the Butterfly Container Script. I used the PushbackInputStream at the core of my parser, because sometimes I needed to read ahead a character or two, to determine what the character at hand meant.</p><p>I have a real life example that uses the PushbackReader in my article about <a href="http://tutorials.jenkov.com/java-howto/replace-strings-in-streams-arrays-files.html" target="_blank" rel="noopener">Replace Strings in Streams, Arrays, Files</a> tutorial. The example creates a TokenReplacingReader which can replace tokens of the format ${tokenName} in data read from an underlying Reader with values of your own choosing. The user of the TokenReplacingReader cannot see that this replacement takes place.</p><h2 id="Java-IO-Reader-And-Writer"><a href="#Java-IO-Reader-And-Writer" class="headerlink" title="Java IO: Reader And Writer"></a>Java IO: Reader And Writer</h2><p>Java IO的Reader和Writer除了基于字符之外,其他方面都与InputStream和OutputStream非常类似。他们被用于读写文本。InputStream和OutputStream是基于字节的</p><h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><p>Reader类是Java IO中所有Reader的基类。子类包括BufferedReader,PushbackReader,InputStreamReader,StringReader和其他Reader。</p><p>这是一个简单的Java IO Reader的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Reader reader = <span class="keyword">new</span> FileReader(<span class="string">"c:\\data\\myfile.txt"</span>);</span><br><span class="line"><span class="keyword">int</span> data = reader.read();</span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">char</span> dataChar = (<span class="keyword">char</span>) data;</span><br><span class="line">    data = reader.read();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请注意,InputStream的read()方法返回一个字节,意味着这个返回值的范围在0到255之间(当达到流末尾时,返回-1),Reader的read()方法返回一个字符,意味着这个返回值的范围在0到65535之间(当达到流末尾时,同样返回-1)。这并不意味着Reade只会从数据源中一次读取2个字节,Reader会根据文本的编码,一次读取一个或者多个字节。</p><p>你通常会使用Reader的子类,而不会直接使用Reader。Reader的子类包括InputStreamReader,CharArrayReader,FileReader等等。可以查看Java IO概述浏览完整的Reader表格。</p><h3 id="整合Reader与InputStream"><a href="#整合Reader与InputStream" class="headerlink" title="整合Reader与InputStream"></a>整合Reader与InputStream</h3><p>一个Reader可以和一个InputStream相结合。如果你有一个InputStream输入流,并且想从其中读取字符,可以把这个InputStream包装到InputStreamReader中。把InputStream传递到InputStreamReader的构造函数中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(inputStream);</span><br></pre></td></tr></table></figure></p><p>在构造函数中可以指定解码方式。更多内容请参阅InputStreamReader。</p><h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3><p>Writer类是Java IO中所有Writer的基类。子类包括BufferedWriter和PrintWriter等等。这是一个Java IO Writer的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">"c:\\data\\file-output.txt"</span>); </span><br><span class="line">writer.write(<span class="string">"Hello World Writer"</span>); </span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure></p><p>同样,你最好使用Writer的子类,不需要直接使用Writer,因为子类的实现更加明确,更能表现你的意图。常用子类包括OutputStreamWriter,CharArrayWriter,FileWriter等。Writer的write(int c)方法,会将传入参数的低16位写入到Writer中,忽略高16位的数据。</p><h3 id="整合Writer和OutputStream"><a href="#整合Writer和OutputStream" class="headerlink" title="整合Writer和OutputStream"></a>整合Writer和OutputStream</h3><p>与Reader和InputStream类似,一个Writer可以和一个OutputStream相结合。把OutputStream包装到OutputStreamWriter中,所有写入到OutputStreamWriter的字符都将会传递给OutputStream。这是一个OutputStreamWriter的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = <span class="keyword">new</span> OutputStreamWriter(outputStream);</span><br></pre></td></tr></table></figure></p><h3 id="整合Reader和Writer"><a href="#整合Reader和Writer" class="headerlink" title="整合Reader和Writer"></a>整合Reader和Writer</h3><p>和字节流一样,Reader和Writer可以相互结合实现更多更有趣的IO,工作原理和把Reader与InputStream或者Writer与OutputStream相结合类似。举个栗子,可以通过将Reader包装到BufferedReader、Writer包装到BufferedWriter中实现缓冲。以下是例子:<br>Reader reader = new BufferedReader(new FileReader(…));<br>Writer writer = new BufferedWriter(new FileWriter(…));</p><h2 id="Java-IO-并发IO"><a href="#Java-IO-并发IO" class="headerlink" title="Java IO: 并发IO"></a>Java IO: 并发IO</h2><p>有时候你可能需要并发地处理输入和输出。换句话说,你可能有超过一个线程处理输入和产生输出。比如,你有一个程序需要处理磁盘上的大量文件,这个任务可以通过并发操作提高性能。又比如,你有一个web服务器或者聊天服务器,接收许多连接和请求,这些任务都可以通过并发获得性能的提升。</p><p>如果你需要并发处理IO,这里有几个问题可能需要注意一下:</p><p>在同一时刻不能有多个线程同时从InputStream或者Reader中读取数据,也不能同时往OutputStream或者Writer里写数据。你没有办法保证每个线程读取多少数据,以及多个线程写数据时的顺序。</p><p>如果线程之间能够保证操作的顺序,它们可以使用同一个stream、reader、writer。比如,你有一个线程判断当前的输入流来自哪种类型的请求,然后将流数据传递给其他合适的线程做后续处理。当有序存取流、reader、writer时,这种做法是可行的。请注意,在线程之间传递流数据的代码应当是同步的。</p><p>注意:在Java NIO中,你可以让一个线程读写多个“channel”。比如,你有很多网络连接处于开启状态,但是每个连接中都只有少量数据,类似于聊天服务器,可以让一个线程监视多个频道(连接)。Java NIO是另一个话题了,会后续教程中介绍。</p><h2 id="Java-IO-异常处理"><a href="#Java-IO-异常处理" class="headerlink" title="Java IO: 异常处理"></a>Java IO: 异常处理</h2><p>流与Reader和Writer在结束使用的时候,需要正确地关闭它们。通过调用close()方法可以达到这一点。不过这需要一些思考。请看下边的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-text.txt"</span>);</span><br><span class="line"><span class="keyword">int</span> data = input.read();</span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//do something with data...  </span></span><br><span class="line">    doSomethingWithData(data);</span><br><span class="line">    data = input.read();</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure></p><p>第一眼看这段代码时,可能觉得没什么问题。可是如果在调用doSomethingWithData()方法时出现了异常,会发生什么呢？没错,这个InputStream对象就不会被关闭。</p><p>为了避免异常造成流无法被关闭,我们可以把代码重写成这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    input = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-text.txt"</span>);</span><br><span class="line">    <span class="keyword">int</span> data = input.read();</span><br><span class="line">    <span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//do something with data...</span></span><br><span class="line">        doSomethingWithData(data);</span><br><span class="line">        data = input.read();</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    <span class="comment">//do something with e... log, perhaps rethrow etc.</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(input != <span class="keyword">null</span>)</span><br><span class="line">        input.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意到这里把InputStream的关闭代码放到了finally块中,无论在try-catch块中发生了什么,finally内的代码始终会被执行,所以这个InputStream总是会被关闭。</p><p>但是如果close()方法抛出了异常,告诉你流已经被关闭过了呢？为了解决这个难题,你也需要把close()方法写在try-catch内部,就像这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(input != <span class="keyword">null</span>)</span><br><span class="line">            input.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">        <span class="comment">//do something, or ignore.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段解决了InputStream(或者OutputStream)流关闭的问题的代码,确实是有一些不优雅,尽管能够正确处理异常。如果你的代码中重复地遍布了这段丑陋的异常处理代码,这不是很好的一个解决方案。如果一个匆忙的家伙贪图方便忽略了异常处理呢？</p><p>此外,想象一下某个异常最先从doSomethingWithData方法内抛出。第一个catch会捕获到异常,然后在finally里程序会尝试关闭InputStream。但是如果还有异常从close()方法内抛出呢？这两个异常中得哪个异常应当往调用栈上传播呢？</p><p>幸运的是,有一个办法能够解决这个问题。这个解决方案称作“异常处理模板”。创建一个正确关闭流的模板,能够在代码中做到一次编写,重复使用,既优雅又简单。详情参见<a href="http://tutorials.jenkov.com/java-exception-handling/exception-handling-templates.html" target="_blank" rel="noopener">Java异常处理模板</a>。</p><h3 id="Java7中IO的异常处理"><a href="#Java7中IO的异常处理" class="headerlink" title="Java7中IO的异常处理"></a>Java7中IO的异常处理</h3><p>从Java7开始,一种新的被称作“try-with-resource”的异常处理机制被引入进来。这种机制旨在解决针对InputStream和OutputStream这类在使用完毕之后需要关闭的资源的异常处理。可以浏览<a href="http://tutorials.jenkov.com/java-exception-handling/try-with-resources.html" target="_blank" rel="noopener">Try with Resource in Java 7</a>获得更多信息。</p><h2 id="Java-IO-InputStream"><a href="#Java-IO-InputStream" class="headerlink" title="Java IO: InputStream"></a>Java IO: InputStream</h2><p>InputStream类是Java IO API中所有输入流的基类。InputStream子类包括FileInputStream,BufferedInputStream,PushbackInputStream等等。参考Java IO概述这一小节底部的表格,可以浏览完整的InputStream子类的列表。</p><h3 id="Java-InputStream例子"><a href="#Java-InputStream例子" class="headerlink" title="Java InputStream例子"></a>Java InputStream例子</h3><p>InputStream用于读取基于字节的数据,一次读取一个字节,这是一个InputStream的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputstream = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-text.txt"</span>);</span><br><span class="line"><span class="keyword">int</span> data = inputstream.read();</span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123; </span><br><span class="line">    <span class="comment">//do something with data...  </span></span><br><span class="line">    doSomethingWithData(data);   </span><br><span class="line">    data = inputstream.read();</span><br><span class="line">&#125;</span><br><span class="line">inputstream.close();</span><br></pre></td></tr></table></figure></p><p>这个例子创建了FileInputStream实例。FileInputStream是InputStream的子类,所以可以把FileInputStream实例赋值给InputStream变量。</p><p>注意:为了清晰,代码忽略了一些必要的异常处理。想了解更多异常处理的信息,请参考Java IO异常处理。</p><p>从Java7开始,你可以使用“try-with-resource”结构确保InputStream在结束使用之后关闭,链接指向了一篇关于“try-with-resource”是如何工作的文章,这里只是一个简单的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>( InputStream inputstream = <span class="keyword">new</span> FileInputStream(<span class="string">"file.txt"</span>) ) &#123;</span><br><span class="line">    <span class="keyword">int</span> data = inputstream.read();</span><br><span class="line">    <span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>) data);</span><br><span class="line">        data = inputstream.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当执行线程退出try语句块的时候,InputStream变量会被关闭。</p><h3 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h3><p>read()方法返回从InputStream流内读取到的一个字节内容(译者注:0~255),例子如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data = inputstream.read();</span><br></pre></td></tr></table></figure></p><p>你可以把返回的int类型转化成char类型:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> aChar = (<span class="keyword">char</span>) data;</span><br></pre></td></tr></table></figure></p><p>InputStream的子类可能会包含read()方法的替代方法。比如,DataInputStream允许你利用readBoolean(),readDouble()等方法读取Java基本类型变量int,long,float,double和boolean。</p><h3 id="流末尾"><a href="#流末尾" class="headerlink" title="流末尾"></a>流末尾</h3><p>如果read()方法返回-1,意味着程序已经读到了流的末尾,此时流内已经没有多余的数据可供读取了。-1是一个int类型,不是byte或者char类型,这是不一样的。</p><p>当达到流末尾时,你就可以关闭流了。</p><h3 id="read-byte"><a href="#read-byte" class="headerlink" title="read(byte[])"></a>read(byte[])</h3><p>InputStream包含了2个从InputStream中读取数据并将数据存储到缓冲数组中的read()方法,他们分别是:</p><ul><li>int read(byte[])</li><li>int read(byte, int offset, int length)</li></ul><p>一次性读取一个字节数组的方式,比一次性读取一个字节的方式快的多,所以,尽可能使用这两个方法代替read()方法。</p><p>read(byte[])方法会尝试读取与给定字节数组容量一样大的字节数,返回值说明了已经读取过的字节数。如果InputStream内可读的数据不足以填满字节数组,那么数组剩余的部分将包含本次读取之前的数据。记得检查有多少数据实际被写入到了字节数组中。</p><p>read(byte, int offset, int length)方法同样将数据读取到字节数组中,不同的是,该方法从数组的offset位置开始,并且最多将length个字节写入到数组中。同样地,read(byte, int offset, int length)方法返回一个int变量,告诉你已经有多少字节已经被写入到字节数组中,所以请记得在读取数据前检查上一次调用read(byte, int offset, int length)的返回值。</p><p>这两个方法都会在读取到达到流末尾时返回-1。</p><p>这是一个使用InputStream的read(byte[])的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputstream = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-text.txt"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> bytesRead = inputstream.read(data);</span><br><span class="line"><span class="keyword">while</span>(bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">    doSomethingWithData(data, bytesRead);</span><br><span class="line">    bytesRead = inputstream.read(data);</span><br><span class="line">&#125;</span><br><span class="line">inputstream.close();</span><br></pre></td></tr></table></figure></p><p>在代码中,首先创建了一个字节数组。然后声明一个叫做bytesRead的存储每次调用read(byte[])返回值的int变量,并且将第一次调用read(byte[])得到的返回值赋值给它。</p><p>在while循环内部,把字节数组和已读取字节数作为参数传递给doSomethingWithData方法然后执行调用。在循环的末尾,再次将数据写入到字节数组中。</p><p>你不需要想象出read(byte, int offset, int length)替代read(byte[])的场景,几乎可以在使用read(byte, int offset, int length)的任何地方使用read(byte[])。</p><h3 id="输入流和数据源"><a href="#输入流和数据源" class="headerlink" title="输入流和数据源"></a>输入流和数据源</h3><p>一个输入流往往会和数据源联系起来,比如文件,网络连接,管道等,更多细节已经在Java IO概述文章中介绍过了。</p><h2 id="Java-IO-OutputStream"><a href="#Java-IO-OutputStream" class="headerlink" title="Java IO: OutputStream"></a>Java IO: OutputStream</h2><p>OutputStream类是Java IO API中所有输出流的基类。子类包括BufferedOutputStream,FileOutputStream等等。参考Java IO概述这一小节底部的表格,可以浏览完整的子类的列表。</p><h3 id="输出流和目标媒介"><a href="#输出流和目标媒介" class="headerlink" title="输出流和目标媒介"></a>输出流和目标媒介</h3><p>输出流往往和某些数据的目标媒介相关联,比如文件,网络连接,管道等。更多细节请参考Java IO概述。当写入到输出流的数据逐渐输出完毕时,目标媒介是所有数据的归属地。</p><h3 id="write-byte"><a href="#write-byte" class="headerlink" title="write(byte)"></a>write(byte)</h3><p>write(byte)方法用于把单个字节写入到输出流中。OutputStream的write(byte)方法将一个包含了待写入数据的int变量作为参数进行写入。只有int类型的第一个字节会被写入,其余位会被忽略。(译者注:写入低8位,忽略高24位)。</p><p>OutputStream的子类可能会包含write()方法的替代方法。比如,DataOutputStream允许你利用writeBoolean(),writeDouble()等方法将基本类型int,long,float,double,boolean等变量写入。</p><p>这是一个OutputStream的write()方法例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output-text.txt"</span>);</span><br><span class="line"><span class="keyword">while</span>(hasMoreData()) &#123;</span><br><span class="line">    <span class="keyword">int</span> data = getMoreData();</span><br><span class="line">    output.write(data);</span><br><span class="line">&#125;</span><br><span class="line">output.close();</span><br></pre></td></tr></table></figure></p><p>这个例子首先创建了待写入的FileOutputStream。在进入while循环之后,循环的判断条件是hasMoreData()方法的返回值。hasMoreData()方法的实现不予展示,请把这个函数理解为:当有剩余可写数据时,返回true,否则返回false。</p><p>请注意,为了清晰,这里忽略了必要的异常处理。想了解更多异常处理的信息,请参考Java IO异常处理。</p><h3 id="write-byte-1"><a href="#write-byte-1" class="headerlink" title="write(byte[])"></a>write(byte[])</h3><p>OutputStream同样包含了将字节数据中全部或者部分数据写入到输出流中的方法,分别是write(byte[])和write(byte[], int offset, int length)。</p><p>write(byte[])把字节数组中所有数据写入到输出流中。</p><p>write(byte[], int offset, int length)把字节数据中从offset位置开始,length个字节的数据写入到输出流。</p><h3 id="flush"><a href="#flush" class="headerlink" title="flush()"></a>flush()</h3><p>OutputStream的flush()方法将所有写入到OutputStream的数据冲刷到相应的目标媒介中。比如,如果输出流是FileOutputStream,那么写入到其中的数据可能并没有真正写入到磁盘中。即使所有数据都写入到了FileOutputStream,这些数据还是有可能保留在内存的缓冲区中。通过调用flush()方法,可以把缓冲区内的数据刷新到磁盘(或者网络,以及其他任何形式的目标媒介)中。</p><h3 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h3><p>当你结束数据写入时,需要关闭OutputStream。通过调用close()可以达到这一点。因为OutputStream的各种write()方法可能会抛出IO异常,所以你需要把调用close()的关闭操作方在finally块中执行。这是一个OutputStream调用close()的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">OutputStream output = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output-text.txt"</span>);</span><br><span class="line">    <span class="keyword">while</span>(hasMoreData()) &#123;</span><br><span class="line">        <span class="keyword">int</span> data = getMoreData();</span><br><span class="line">        output.write(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(output != <span class="keyword">null</span>) &#123;</span><br><span class="line">        output.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子在finally块中调用close()方法。虽然这种方式可以确保OutputStream关闭,但却不是一个完美的异常处理方案。我在Java IO异常处理这文章中更加详细地探讨了IO的异常处理。</p><h2 id="Java-IO-FileInputStream"><a href="#Java-IO-FileInputStream" class="headerlink" title="Java IO: FileInputStream"></a>Java IO: FileInputStream</h2><p>FileInputStream可以以字节流的形式读取文件内容。FileInputStream是InputStream的子类,这意味着你可以把FileInputStream当做InputStream使用(FileInputStream与InputStream的行为类似)。</p><p>这是一个FileInputStream的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input-text.txt"</span>);</span><br><span class="line"><span class="keyword">int</span> data = input.read();</span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//do something with data...</span></span><br><span class="line">    doSomethingWithData(data);</span><br><span class="line">    data = input.read();</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure></p><p>请注意,为了清晰,这里忽略了必要的异常处理。想了解更多异常处理的信息,请参考Java IO异常处理。</p><p>FileInputStream的read()方法返回读取到的包含一个字节内容的int变量(译者注:0~255)。如果read()方法返回-1,意味着程序已经读到了流的末尾,此时流内已经没有多余的数据可供读取了,你可以关闭流。-1是一个int类型,不是byte类型,这是不一样的。</p><p>FileInputStream也有其他的构造函数,允许你通过不同的方式读取文件。请参考<a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="noopener">官方文档</a>查阅更多信息。</p><p>其中一个FileInputStream构造函数取一个File对象替代String对象作为参数。这里是一个使用该构造函数的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\data\\input-text.txt"</span>);</span><br><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(file);</span><br></pre></td></tr></table></figure></p><p>至于你该采用参数是String对象还是File对象的构造函数,取决于你当前是否已经拥有一个File对象,也取决于你是否要在打开FileOutputStream之前通过File对象执行某些检查(比如检查文件是否存在)。</p><h2 id="Java-IO-FileOutputStream"><a href="#Java-IO-FileOutputStream" class="headerlink" title="Java IO: FileOutputStream"></a>Java IO: FileOutputStream</h2><p>FileOutputStream可以往文件里写入字节流,它是OutputStream的子类,所以你可以像使用OutputStream那样使用FileOutputStream。</p><p>这是一个FileOutputStream的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output-text.txt"</span>);</span><br><span class="line"><span class="keyword">while</span>(moreData) &#123;</span><br><span class="line">    <span class="keyword">int</span> data = getMoreData();</span><br><span class="line">    output.write(data);</span><br><span class="line">&#125;</span><br><span class="line">output.close();</span><br></pre></td></tr></table></figure></p><p>请注意,为了清晰,这里忽略了必要的异常处理。想了解更多异常处理的信息,请参考Java IO异常处理。</p><p>FileOutputStream的write()方法取一个包含了待写入字节(译者注:低8位数据)的int变量作为参数进行写入。</p><p>FileOutputStream也有其他的构造函数,允许你通过不同的方式写入文件。请参考<a href="http://docs.oracle.com/javase/7/docs/api/" target="_blank" rel="noopener">官方文档</a>查阅更多信息。</p><h3 id="文件内容的覆盖Override-VS追加Appending"><a href="#文件内容的覆盖Override-VS追加Appending" class="headerlink" title="文件内容的覆盖Override VS追加Appending"></a>文件内容的覆盖Override VS追加Appending</h3><p>当你创建了一个指向已存在文件的FileOutputStream,你可以选择覆盖整个文件,或者在文件末尾追加内容。通过使用不同的构造函数可以实现不同的目的。</p><p>其中一个构造函数取文件名作为参数,会覆盖任何此文件名指向的文件。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output-text.txt"</span>);</span><br></pre></td></tr></table></figure></p><p>另外一个构造函数取2个参数:文件名和一个布尔值,布尔值表明你是否需要覆盖文件。这是构造函数的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output-text.txt"</span>, <span class="keyword">true</span>); <span class="comment">//appends to file</span></span><br><span class="line">OutputStream output = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output-text.txt"</span>, <span class="keyword">false</span>); <span class="comment">//overwrites file</span></span><br></pre></td></tr></table></figure></p><h3 id="写入字节数组"><a href="#写入字节数组" class="headerlink" title="写入字节数组"></a>写入字节数组</h3><p>既然FileOutputStream是OutputStream的子类,所以你也可以往FileOutputStream中写入字节数组,而不需要每次都只写入一个字节。可以参考我的OutputStream教程查阅更多关于写入字节数组的信息。</p><h3 id="flush-1"><a href="#flush-1" class="headerlink" title="flush()"></a>flush()</h3><p>当你往FileOutputStream里写数据的时候,这些数据有可能会缓存在内存中。在之后的某个时间,比如,每次都只有X份数据可写,或者FileOutputStream关闭的时候,才会真正地写入磁盘。当FileOutputStream没被关闭,而你又想确保写入到FileOutputStream中的数据写入到磁盘中,可以调用flush()方法,该方法可以保证所有写入到FileOutputStream的数据全部写入到磁盘中。</p><h2 id="Java-IO-RandomAccessFile"><a href="#Java-IO-RandomAccessFile" class="headerlink" title="Java IO: RandomAccessFile"></a>Java IO: RandomAccessFile</h2><p>RandomAccessFile允许你来回读写文件,也可以替换文件中的某些部分。FileInputStream和FileOutputStream没有这样的功能。</p><h3 id="创建一个RandomAccessFile"><a href="#创建一个RandomAccessFile" class="headerlink" title="创建一个RandomAccessFile"></a>创建一个RandomAccessFile</h3><p>在使用RandomAccessFile之前,必须初始化它。这是例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"c:\\data\\file.txt"</span>, <span class="string">"rw"</span>);</span><br></pre></td></tr></table></figure></p><p>请注意构造函数的第二个参数:“rw”,表明你以读写方式打开文件。请查阅Java文档获知你需要以何种方式构造RandomAccessFile。</p><h3 id="在RandomAccessFile中来回读写"><a href="#在RandomAccessFile中来回读写" class="headerlink" title="在RandomAccessFile中来回读写"></a>在RandomAccessFile中来回读写</h3><p>在RandomAccessFile的某个位置读写之前,必须把文件指针指向该位置。通过seek()方法可以达到这一目标。可以通过调用getFilePointer()获得当前文件指针的位置。例子如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"c:\\data\\file.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">file.seek(<span class="number">200</span>);</span><br><span class="line"><span class="keyword">long</span> pointer = file.getFilePointer();</span><br><span class="line">file.close();</span><br></pre></td></tr></table></figure></p><h3 id="读取RandomAccessFile"><a href="#读取RandomAccessFile" class="headerlink" title="读取RandomAccessFile"></a>读取RandomAccessFile</h3><p>RandomAccessFile中的任何一个read()方法都可以读取RandomAccessFile的数据。例子如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"c:\\data\\file.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line"><span class="keyword">int</span> aByte = file.read();</span><br><span class="line">file.close();</span><br></pre></td></tr></table></figure></p><p>read()方法返回当前RandomAccessFile实例的文件指针指向的位置中包含的字节内容。Java文档中遗漏了一点:read()方法在读取完一个字节之后,会自动把指针移动到下一个可读字节。这意味着使用者在调用完read()方法之后不需要手动移动文件指针。</p><h3 id="写入RandomAccessFile"><a href="#写入RandomAccessFile" class="headerlink" title="写入RandomAccessFile"></a>写入RandomAccessFile</h3><p>RandomAccessFile中的任何一个write()方法都可以往RandomAccessFile中写入数据。例子如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"c:\\data\\file.txt"</span>, <span class="string">"rw"</span>);</span><br><span class="line">file.write(<span class="string">"Hello World"</span>.getBytes());</span><br><span class="line">file.close();</span><br></pre></td></tr></table></figure></p><p>与read()方法类似,write()方法在调用结束之后自动移动文件指针,所以你不需要频繁地把指针移动到下一个将要写入数据的位置。</p><h3 id="RandomAccessFile异常处理"><a href="#RandomAccessFile异常处理" class="headerlink" title="RandomAccessFile异常处理"></a>RandomAccessFile异常处理</h3><p>为了本篇内容清晰,暂时忽略RandomAccessFile异常处理的内容。RandomAccessFile与其他流一样,在使用完毕之后必须关闭。想要了解更多信息,请参考Java IO异常处理。</p><h2 id="Java-IO-File"><a href="#Java-IO-File" class="headerlink" title="Java IO: File"></a>Java IO: File</h2><p>Java IO API中的FIle类可以让你访问底层文件系统,通过File类,你可以做到以下几点:</p><ul><li>检测文件是否存在</li><li>读取文件长度</li><li>重命名或移动文件</li><li>删除文件</li><li>检测某个路径是文件还是目录</li><li>读取目录中的文件列表</li></ul><p>请注意:File只能访问文件以及文件系统的元数据。如果你想读写文件内容,需要使用FileInputStream、FileOutputStream或者RandomAccessFile。如果你正在使用Java NIO,并且想使用完整的NIO解决方案,你会使用到java.nio.FileChannel(否则你也可以使用File)。</p><p>实例化一个java.io.File对象<br>在使用File之前,必须拥有一个File对象,这是实例化的代码例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\data\\input-file.txt"</span>);</span><br></pre></td></tr></table></figure></p><p>很简单,对吗？File类同样拥有多种不同实例化方式的构造函数。</p><h3 id="检测文件是否存在"><a href="#检测文件是否存在" class="headerlink" title="检测文件是否存在"></a>检测文件是否存在</h3><p>当你获得一个File对象之后,可以检测相应的文件是否存在。当文件不存在的时候,构造函数并不会执行失败。你已经准备好创建一个File了,对吧？</p><p>通过调用exists()方法,可以检测文件是否存在,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\data\\input-file.txt"</span>);</span><br><span class="line"><span class="keyword">boolean</span> fileExists = file.exists();</span><br></pre></td></tr></table></figure></p><h3 id="文件长度"><a href="#文件长度" class="headerlink" title="文件长度"></a>文件长度</h3><p>通过调用length()可以获得文件的字节长度,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\data\\input-file.txt"</span>);</span><br><span class="line"><span class="keyword">long</span> length = file.length();</span><br></pre></td></tr></table></figure></p><h3 id="重命名或移动文件"><a href="#重命名或移动文件" class="headerlink" title="重命名或移动文件"></a>重命名或移动文件</h3><p>通过调用File类中的renameTo()方法可以重命名(或者移动)文件,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\data\\input-file.txt"</span>);</span><br><span class="line"><span class="keyword">boolean</span> success = file.renameTo(<span class="keyword">new</span> File(<span class="string">"c:\\data\\new-file.txt"</span>));</span><br></pre></td></tr></table></figure></p><h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>通过调用delete()方法可以删除文件,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\data\\input-file.txt"</span>);</span><br><span class="line"><span class="keyword">boolean</span> success = file.delete();</span><br></pre></td></tr></table></figure></p><p>delete()方法与rename()方法一样,返回布尔值表明是否成功删除文件,同样也会有相同的操作失败原因。</p><h3 id="检测某个路径是文件还是目录"><a href="#检测某个路径是文件还是目录" class="headerlink" title="检测某个路径是文件还是目录"></a>检测某个路径是文件还是目录</h3><p>File对象既可以指向一个文件,也可以指向一个目录。可以通过调用isDirectory()方法,可以判断当前File对象指向的是文件还是目录。当方法返回值是true时,File指向的是目录,否则指向的是文件,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\data"</span>);</span><br><span class="line"><span class="keyword">boolean</span> isDirectory = file.isDirectory();</span><br></pre></td></tr></table></figure></p><h3 id="读取目录中的文件列表"><a href="#读取目录中的文件列表" class="headerlink" title="读取目录中的文件列表"></a>读取目录中的文件列表</h3><p>你可以通过调用list()或者listFiles()方法获取一个目录中的所有文件列表。list()方法返回当前File对象指向的目录中所有文件与子目录的字符串名称(译者注:不会返回子目录下的文件及其子目录名称)。listFiles()方法返回当前File对象指向的目录中所有文件与子目录相关联的File对象(译者注:与list()方法类似,不会返回子目录下的文件及其子目录)。代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"c:\\data"</span>);</span><br><span class="line">String[] fileNames = file.list();</span><br><span class="line">File[] files = file.listFiles();</span><br></pre></td></tr></table></figure></p><h2 id="Java-IO-PipedInputStream"><a href="#Java-IO-PipedInputStream" class="headerlink" title="Java IO: PipedInputStream"></a>Java IO: PipedInputStream</h2><p>PipedInputStream可以从管道中读取字节流数据,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InputStream input = <span class="keyword">new</span> PipedInputStream(pipedOutputStream);</span><br><span class="line"><span class="keyword">int</span> data = input.read();</span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//do something with data...</span></span><br><span class="line">    doSomethingWithData(data);</span><br><span class="line">    data = input.read();</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure></p><p>请注意,为了清晰,这里忽略了必要的异常处理。想了解更多异常处理的信息,请参考Java IO异常处理。</p><p>PipedInputStream的read()方法返回读取到的包含一个字节内容的int变量(译者注:0~255)。如果read()方法返回-1,意味着程序已经读到了流的末尾,此时流内已经没有多余的数据可供读取了,你可以关闭流。-1是一个int类型,不是byte类型,这是不一样的。</p><h3 id="Java-IO管道"><a href="#Java-IO管道" class="headerlink" title="Java IO管道"></a>Java IO管道</h3><p>正如你所看到的例子那样,一个PipedInputStream需要与一个PipedOutputStream相关联,当这两种流联系起来时,就形成了一条管道。要想更多地了解Java IO中的管道,请参考Java IO管道。</p><h2 id="Java-IO-PipedOutputStream"><a href="#Java-IO-PipedOutputStream" class="headerlink" title="Java IO: PipedOutputStream"></a>Java IO: PipedOutputStream</h2><p>PipedOutputStream可以往管道里写入读取字节流数据,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OutputStream output = <span class="keyword">new</span> PipedOutputStream(pipedInputStream);</span><br><span class="line"><span class="keyword">while</span>(moreData) &#123;</span><br><span class="line">    <span class="keyword">int</span> data = getMoreData();</span><br><span class="line">    output.write(data);</span><br><span class="line">&#125;</span><br><span class="line">output.close();</span><br></pre></td></tr></table></figure></p><p>请注意,为了清晰,这里忽略了必要的异常处理。想了解更多异常处理的信息,请参考Java IO异常处理。</p><p>PipedOutputStream的write()方法取一个包含了待写入字节的int类型变量作为参数进行写入。</p><h3 id="Java-IO管道-1"><a href="#Java-IO管道-1" class="headerlink" title="Java IO管道"></a>Java IO管道</h3><p>一个PipedOutputStream总是需要与一个PipedInputStream相关联。当这两种流联系起来时,它们就形成了一条管道。要想更多地了解Java IO中的管道,请参考Java IO管道。</p><h2 id="Java-IO-ByteArray和Filter"><a href="#Java-IO-ByteArray和Filter" class="headerlink" title="Java IO: ByteArray和Filter"></a>Java IO: ByteArray和Filter</h2><p>本小节会简要概括Java IO中字节数组与过滤器的输入输出流,主要涉及以下4个类型的流:ByteArrayInputStream,ByteArrayOutputStream,FilterInputStream,FilterOutputStream。请注意,为了清晰,这里忽略了必要的异常处理。想了解更多异常处理的信息,请参考Java IO异常处理。</p><h3 id="ByteArrayInputStream"><a href="#ByteArrayInputStream" class="headerlink" title="ByteArrayInputStream"></a>ByteArrayInputStream</h3><p>ByteArrayInputStream允许你从字节数组中读取字节流数据,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = ... <span class="comment">//get byte array from somewhere.</span></span><br><span class="line">InputStream input = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line"><span class="keyword">int</span> data = input.read();</span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//do something with data</span></span><br><span class="line">    data = input.read();</span><br><span class="line">&#125;</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure></p><p>如果数据存储在数组中,ByteArrayInputStream可以很方便地读取数据。如果你有一个InputStream变量,又想从数组中读取数据呢？很简单,只需要把字节数组传递给ByteArrayInputStream的构造函数,在把这个ByteArrayInputStream赋值给InputStream变量就可以了(译者注:InputStream是所有字节输入流流的基类,Reader是所有字符输入流的基类,OutputStream与Writer同理)。</p><h3 id="ByteArrayOutputStream"><a href="#ByteArrayOutputStream" class="headerlink" title="ByteArrayOutputStream"></a>ByteArrayOutputStream</h3><p>ByteArrayOutputStream允许你以数组的形式获取写入到该输出流中的数据,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayOutputStream output = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"><span class="comment">//write data to output stream</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = output.toByteArray();</span><br></pre></td></tr></table></figure></p><h3 id="FilterInputStream"><a href="#FilterInputStream" class="headerlink" title="FilterInputStream"></a>FilterInputStream</h3><p>FilterInputStream是实现自定义过滤输入流的基类,基本上它仅仅只是覆盖了InputStream中的所有方法。</p><p>就我自己而言,我没发现这个类明显的用途。除了构造函数取一个InputStream变量作为参数之外,我没看到FilterInputStream任何对InputStream新增或者修改的地方。如果你选择继承FilterInputStream实现自定义的类,同样也可以直接继承自InputStream从而避免额外的类层级结构。</p><h3 id="FilterOutputStream"><a href="#FilterOutputStream" class="headerlink" title="FilterOutputStream"></a>FilterOutputStream</h3><p>内容同FilterInputStream,不再赘述。</p><h2 id="Java-IO-序列化与ObjectInputStream、ObjectOutputStream"><a href="#Java-IO-序列化与ObjectInputStream、ObjectOutputStream" class="headerlink" title="Java IO: 序列化与ObjectInputStream、ObjectOutputStream"></a>Java IO: 序列化与ObjectInputStream、ObjectOutputStream</h2><p>本小节会简要概括Java IO中的序列化以及涉及到的流,主要包括ObjectInputStream和ObjectOutputStream。</p><h3 id="Serializable"><a href="#Serializable" class="headerlink" title="Serializable"></a>Serializable</h3><p>如果你希望类能够序列化和反序列化,必须实现Serializable接口,就像所展示的ObjectInputStream和ObjectOutputStream例子一样。</p><p>对象序列化本身就是一个主题。Java IO系列教程主要关注流、reader和writer,所以我不会深入探讨对象序列化的细节。</p><h3 id="ObjectInputStream"><a href="#ObjectInputStream" class="headerlink" title="ObjectInputStream"></a>ObjectInputStream</h3><p>ObjectInputStream能够让你从输入流中读取Java对象,而不需要每次读取一个字节。你可以把InputStream包装到ObjectInputStream中,然后就可以从中读取对象了。代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream input = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"object.data"</span>));</span><br><span class="line">MyClass object = (MyClass) input.readObject(); <span class="comment">//etc.</span></span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure></p><p>在这个例子中,你读取的对象必须是MyClass的一个实例,并且必须事先通过ObjectOutputStream序列化到“object.data”文件中。(译者注:ObjectInputStream和ObjectOutputStream还有许多read和write方法,比如readInt、writeLong等等,详细信息请查看官方文档)</p><p>在你序列化和反序列化一个对象之前,该对象的类必须实现了java.io.Serializable接口。</p><h3 id="ObjectOutputStream"><a href="#ObjectOutputStream" class="headerlink" title="ObjectOutputStream"></a>ObjectOutputStream</h3><p>ObjectOutputStream能够让你把对象写入到输出流中,而不需要每次写入一个字节。你可以把OutputStream包装到ObjectOutputStream中,然后就可以把对象写入到该输出流中了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectOutputStream output = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"object.data"</span>));</span><br><span class="line">MyClass object = <span class="keyword">new</span> MyClass();  output.writeObject(object); <span class="comment">//etc.</span></span><br><span class="line">output.close();</span><br></pre></td></tr></table></figure></p><p>例子中序列化的对象object现在可以从ObjectInputStream中读取了。</p><p>同样,在你序列化和反序列化一个对象之前,该对象的类必须实现了java.io.Serializable接口。</p><h2 id="Java-IO-Reader和Writer"><a href="#Java-IO-Reader和Writer" class="headerlink" title="Java IO: Reader和Writer"></a>Java IO: Reader和Writer</h2><h3 id="Reader-1"><a href="#Reader-1" class="headerlink" title="Reader"></a>Reader</h3><p>Reader是Java IO中所有Reader的基类。Reader与InputStream类似,不同点在于,Reader基于字符而非基于字节。换句话说,Reader用于读取文本,而InputStream用于读取原始字节。</p><p>请记住,Java内部使用UTF8编码表示字符串。输入流中一个字节可能并不等同于一个UTF8字符。如果你从输入流中以字节为单位读取UTF8编码的文本,并且尝试将读取到的字节转换成字符,你可能会得不到预期的结果。</p><p>read()方法返回一个包含了读取到的字符内容的int类型变量(译者注:0~65535)。如果方法返回-1,表明Reader中已经没有剩余可读取字符,此时可以关闭Reader。-1是一个int类型,不是byte或者char类型,这是不一样的。</p><p>你通常会使用Reader的子类,而不会直接使用Reader。Reader的子类包括InputStreamReader,CharArrayReader,FileReader等等。可以查看Java IO概述浏览完整的Reader表格。</p><p>Reader通常与文件、字符数组、网络等数据源相关联,Java IO概述中同样说明了这一点。</p><p>###Writer</p><p>Writer是Java IO中所有Writer的基类。与Reader和InputStream的关系类似,Writer基于字符而非基于字节,Writer用于写入文本,OutputStream用于写入字节。</p><p>同样,你最好使用Writer的子类,不需要直接使用Writer,因为子类的实现更加明确,更能表现你的意图。常用子类包括OutputStreamWriter,CharArrayWriter,FileWriter等。</p><p>Writer的write(int c)方法,会将传入参数的低16位写入到Writer中,忽略高16位的数据。</p><h2 id="Java-IO-InputStreamReader和OutputStreamWriter"><a href="#Java-IO-InputStreamReader和OutputStreamWriter" class="headerlink" title="Java IO: InputStreamReader和OutputStreamWriter"></a>Java IO: InputStreamReader和OutputStreamWriter</h2><p>本章节将简要介绍InputStreamReader和OutputStreamWriter。细心的读者可能会发现,在之前的文章中,IO中的类要么以Stream结尾,要么以Reader或者Writer结尾,那这两个同时以字节流和字符流的类名后缀结尾的类是什么用途呢？简单来说,这两个类把字节流转换成字符流,中间做了数据的转换,类似适配器模式的思想</p><h3 id="InputStreamReader"><a href="#InputStreamReader" class="headerlink" title="InputStreamReader"></a>InputStreamReader</h3><p>InputStreamReader会包含一个InputStream,从而可以将该输入字节流转换成字符流,代码例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input.txt"</span>);</span><br><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(inputStream);</span><br><span class="line"><span class="keyword">int</span> data = reader.read();</span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">char</span> theChar = (<span class="keyword">char</span>) data;</span><br><span class="line">    data = reader.read();</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure></p><p>注意:为了清晰,代码忽略了一些必要的异常处理。想了解更多异常处理的信息,请参考Java IO异常处理。</p><p>read()方法返回一个包含了读取到的字符内容的int类型变量(译者注:0~65535)。代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data = reader.read();</span><br></pre></td></tr></table></figure></p><p>你可以把返回的int值转换成char变量,就像这样:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> aChar = (<span class="keyword">char</span>) data; <span class="comment">//译者注:这里不会造成数据丢失,因为返回的int类型变量data只有低16位有数据,高16位没有数据</span></span><br></pre></td></tr></table></figure></p><p>如果方法返回-1,表明Reader中已经没有剩余可读取字符,此时可以关闭Reader。-1是一个int类型,不是byte或者char类型,这是不一样的。</p><p>InputStreamReader同样拥有其他可选的构造函数,能够让你指定将底层字节流解释成何种编码的字符流。例子如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input.txt"</span>);</span><br><span class="line">Reader reader = <span class="keyword">new</span> InputStreamReader(inputStream, <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure></p><p>注意构造函数的第二个参数,此时该InputStreamReader会将输入的字节流转换成UTF8字符流。</p><h3 id="OutputStreamWriter"><a href="#OutputStreamWriter" class="headerlink" title="OutputStreamWriter"></a>OutputStreamWriter</h3><p>OutputStreamWriter会包含一个OutputStream,从而可以将该输出字节流转换成字符流,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"c:\\data\\output.txt"</span>);</span><br><span class="line">Writer writer = <span class="keyword">new</span> OutputStreamWriter(outputStream);</span><br><span class="line">writer.write(<span class="string">"Hello World"</span>);</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure></p><p>OutputStreamWriter同样拥有将输出字节流转换成指定编码的字符流的构造函数。</p><h2 id="Java-IO-FileReader和FileWriter"><a href="#Java-IO-FileReader和FileWriter" class="headerlink" title="Java IO: FileReader和FileWriter"></a>Java IO: FileReader和FileWriter</h2><p>本章节将简要介绍FileReader和FileWriter。与FileInputStream和FileOutputStream类似,FileReader与FileWriter用于处理文件内容。</p><p>FileReader<br>原文链接</p><p>FileReader能够以字符流的形式读取文件内容。除了读取的单位不同之外(译者注:FileReader读取字符,FileInputStream读取字节),FileReader与FileInputStream并无太大差异,也就是说,FileReader用于读取文本。根据不同的编码方案,一个字符可能会相当于一个或者多个字节。代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reader reader = <span class="keyword">new</span> FileReader(<span class="string">"c:\\data\\input-text.txt"</span>);</span><br><span class="line"><span class="keyword">int</span> data = reader.read();</span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//do something with data...</span></span><br><span class="line">    doSomethingWithData(data);</span><br><span class="line">    data = reader.read();</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure></p><p>注意:为了清晰,代码忽略了一些必要的异常处理。想了解更多异常处理的信息,请参考Java IO异常处理。</p><p>read()方法返回一个包含了读取到的字符内容的int类型变量(译者注:0~65535)。如果方法返回-1,表明FileReader中已经没有剩余可读取字符,此时可以关闭FileReader。-1是一个int类型,不是byte或者char类型,这是不一样的。</p><p>FileReader拥有其他可选的构造函数,能够让你使用不同的方式读取文件,更多内容请查看官方文档。</p><p>FileReader会假设你想使用你所使用的JVM的版本的默认编码处理字节流,但是这通常不是你想要的,你可以手动设置编码方案。</p><p>如果你想明确指定一种编码方案,利用InputStreamReader配合FileInputStream来替代FileReader(译者注:FileReader没有可以指定编码的构造函数)。InputStreamReader可以让你设置编码处理从底层文件中读取的字节。</p><h3 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h3><p>FileWriter能够把数据以字符流的形式写入文件。同样是处理文件,FileWriter处理字符,FileOutputStream处理字节。根据不同的编码方案,一个字符可能会相当于一个或者多个字节。代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">"c:\\data\\output.txt"</span>);</span><br><span class="line"><span class="keyword">while</span>(moreData) &#123;</span><br><span class="line">    String data = getMoreData();</span><br><span class="line">    write.write(data);</span><br><span class="line">&#125;</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure></p><p>处理文件都会碰到的一个问题是,当前写入的数据是覆盖原文件内容还是追加到文件末尾。当你创建一个FileWriter之后,你可以通过使用不同构造函数实现你的不同目的。</p><p>以下的构造函数取文件名作为参数,将会新写入的内容将会覆盖该文件:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">"c:\\data\\output.txt"</span>);</span><br></pre></td></tr></table></figure></p><p>以下的构造函数取文件名和一个布尔变量作为参数,布尔值表明你是想追加还是覆盖该文件。例子如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">"c:\\data\\output.txt"</span>, <span class="keyword">true</span>); <span class="comment">//appends to file</span></span><br><span class="line">Writer writer = <span class="keyword">new</span> FileWriter(<span class="string">"c:\\data\\output.txt"</span>, <span class="keyword">false</span>); <span class="comment">//overwrites file</span></span><br></pre></td></tr></table></figure></p><p>同样,FileWriter不能指定编码,可以通过OutputStreamWriter配合FileOutputStream替代FileWriter。</p><h2 id="Java-IO-字符流的Buffered和Filter"><a href="#Java-IO-字符流的Buffered和Filter" class="headerlink" title="Java IO: 字符流的Buffered和Filter"></a>Java IO: 字符流的Buffered和Filter</h2><p>本章节将简要介绍缓冲与过滤相关的reader和writer,主要涉及BufferedReader、BufferedWriter、FilterReader、FilterWriter。</p><h3 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h3><p>BufferedReader能为字符输入流提供缓冲区,可以提高许多IO处理的速度。你可以一次读取一大块的数据,而不需要每次从网络或者磁盘中一次读取一个字节。特别是在访问大量磁盘数据时,缓冲通常会让IO快上许多。</p><p>BufferedReader和BufferedInputStream的主要区别在于,BufferedReader操作字符,而BufferedInputStream操作原始字节。只需要把Reader包装到BufferedReader中,就可以为Reader添加缓冲区(译者注:默认缓冲区大小为8192字节,即8KB)。代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"c:\\data\\input-file.txt"</span>));</span><br></pre></td></tr></table></figure><p>你也可以通过传递构造函数的第二个参数,指定缓冲区大小,代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Reader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"c:\\data\\input-file.txt"</span>), <span class="number">8</span> * <span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>这个例子设置了8KB的缓冲区。最好把缓冲区大小设置成1024字节的整数倍,这样能更高效地利用内置缓冲区的磁盘。</p><p>除了能够为输入流提供缓冲区以外,其余方面BufferedReader基本与Reader类似。BufferedReader还有一个额外readLine()方法,可以方便地一次性读取一整行字符。</p><h3 id="BufferedWriter"><a href="#BufferedWriter" class="headerlink" title="BufferedWriter"></a>BufferedWriter</h3><p>与BufferedReader类似,BufferedWriter可以为输出流提供缓冲区。可以构造一个使用默认大小缓冲区的BufferedWriter(译者注:默认缓冲区大小8 * 1024B),代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"c:\\data\\output-file.txt"</span>));</span><br></pre></td></tr></table></figure><p>也可以手动设置缓冲区大小,代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Writer writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"c:\\data\\output-file.txt"</span>), <span class="number">8</span> * <span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>为了更好地使用内置缓冲区的磁盘,同样建议把缓冲区大小设置成1024的整数倍。除了能够为输出流提供缓冲区以外,其余方面BufferedWriter基本与Writer类似。类似地,BufferedWriter也提供了writeLine()方法,能够把一行字符写入到底层的字符输出流中。值得注意是,你需要手动flush()方法确保写入到此输出流的数据真正写入到磁盘或者网络中。</p><h3 id="FilterReader"><a href="#FilterReader" class="headerlink" title="FilterReader"></a>FilterReader</h3><p>与FilterInputStream类似,FilterReader是实现自定义过滤输入字符流的基类,基本上它仅仅只是简单覆盖了Reader中的所有方法。</p><p>就我自己而言,我没发现这个类明显的用途。除了构造函数取一个Reader变量作为参数之外,我没看到FilterReader任何对Reader新增或者修改的地方。如果你选择继承FilterReader实现自定义的类,同样也可以直接继承自Reader从而避免额外的类层级结构。</p><h3 id="FilterWriter"><a href="#FilterWriter" class="headerlink" title="FilterWriter"></a>FilterWriter</h3><p>内容同FilterReader,不再赘述。</p><h2 id="Java-IO-字符流的Piped和CharArray"><a href="#Java-IO-字符流的Piped和CharArray" class="headerlink" title="Java IO: 字符流的Piped和CharArray"></a>Java IO: 字符流的Piped和CharArray</h2><p>本章节将简要介绍管道与字符数组相关的reader和writer,主要涉及PipedReader、PipedWriter、CharArrayReader、CharArrayWriter。</p><h3 id="PipedReader"><a href="#PipedReader" class="headerlink" title="PipedReader"></a>PipedReader</h3><p>PipedReader能够从管道中读取字符流。与PipedInputStream类似,不同的是PipedReader读取的是字符而非字节。换句话说,PipedReader用于读取管道中的文本。代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reader reader = <span class="keyword">new</span> PipedReader(pipedWriter);</span><br><span class="line"><span class="keyword">int</span> data = reader.read();</span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//do something with data...</span></span><br><span class="line">    doSomethingWithData(data);</span><br><span class="line">    data = reader.read();</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure></p><p>注意:为了清晰,代码忽略了一些必要的异常处理。想了解更多异常处理的信息,请参考Java IO异常处理。</p><p>read()方法返回一个包含了读取到的字符内容的int类型变量(译者注:0~65535)。如果方法返回-1,表明PipedReader中已经没有剩余可读取字符,此时可以关闭PipedReader。-1是一个int类型,不是byte或者char类型,这是不一样的。</p><p>正如你所看到的例子那样,一个PipedReader需要与一个PipedWriter相关联,当这两种流联系起来时,就形成了一条管道。要想更多地了解Java IO中的管道,请参考Java IO管道。</p><h3 id="PipedWriter"><a href="#PipedWriter" class="headerlink" title="PipedWriter"></a>PipedWriter</h3><p>PipedWriter能够往管道中写入字符流。与PipedOutputStream类似,不同的是PipedWriter处理的是字符而非字节,PipedWriter用于写入文本数据。代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PipedWriter writer = <span class="keyword">new</span> PipedWriter(pipedReader);</span><br><span class="line"><span class="keyword">while</span>(moreData()) &#123;</span><br><span class="line">    <span class="keyword">int</span> data = getMoreData();</span><br><span class="line">    writer.write(data);</span><br><span class="line">&#125;</span><br><span class="line">writer.close();</span><br></pre></td></tr></table></figure></p><p>PipedWriter的write()方法取一个包含了待写入字节的int类型变量作为参数进行写入,同时也有采用字符串、字符数组作为参数的write()方法。</p><h3 id="CharArrayReader"><a href="#CharArrayReader" class="headerlink" title="CharArrayReader"></a>CharArrayReader</h3><p>CharArrayReader能够让你从字符数组中读取字符流。代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] chars = ... <span class="comment">//get char array from somewhere.</span></span><br><span class="line">Reader reader = <span class="keyword">new</span> CharArrayReader(chars);</span><br><span class="line"><span class="keyword">int</span> data = reader.read();</span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//do something with data</span></span><br><span class="line">    data = reader.read();</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure></p><p>如果数据的存储媒介是字符数组,CharArrayReader可以很方便的读取到你想要的数据。CharArrayReader会包含一个字符数组,然后将字符数组转换成字符流。(译者注:CharArrayReader有2个构造函数,一个是CharArrayReader(char[] buf),将整个字符数组创建成一个字符流。另外一个是CharArrayReader(char[] buf, int offset, int length),把buf从offset开始,length个字符创建成一个字符流。更多细节请参考Java官方文档)</p><h3 id="CharArrayWriter"><a href="#CharArrayWriter" class="headerlink" title="CharArrayWriter"></a>CharArrayWriter</h3><p>CharArrayWriter能够把字符写入到字符输出流writer中,并且能够将写入的字符转换成字符数组。代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CharArrayWriter writer = <span class="keyword">new</span> CharArrayWriter();</span><br><span class="line"><span class="comment">//write characters to writer.</span></span><br><span class="line"><span class="keyword">char</span>[] chars = writer.toCharArray();</span><br></pre></td></tr></table></figure><p>当你需要以字符数组的形式访问写入到writer中的字符流数据时,CharArrayWriter是个不错的选择。</p><h2 id="Java-IO-其他字节流"><a href="#Java-IO-其他字节流" class="headerlink" title="Java IO: 其他字节流"></a>Java IO: 其他字节流</h2><p>本小节会简要概括Java IO中的PushbackInputStream,SequenceInputStream,PrintStream, PushbackReader,LineNumberReader,StreamTokenizer,PrintWriter,StringReader,StringWriter。其中,最常用的是PrintStream,System.out和System.err都是PrintStream类型的变量,请查看Java IO: System.in, System.out, System.err浏览更多关于System.out和System.err的信息。</p><h3 id="PushbackInputStream"><a href="#PushbackInputStream" class="headerlink" title="PushbackInputStream"></a>PushbackInputStream</h3><p>PushbackInputStream用于解析InputStream内的数据。有时候你需要提前知道接下来将要读取到的字节内容,才能判断用何种方式进行数据解析。PushBackInputStream允许你这么做,你可以把读取到的字节重新推回到InputStream中,以便再次通过read()读取。代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PushbackInputStream input = <span class="keyword">new</span> PushbackInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input.txt"</span>));</span><br><span class="line"><span class="keyword">int</span> data = input.read();</span><br><span class="line">input.unread(data);</span><br></pre></td></tr></table></figure></p><p>可以通过PushBackInputStream的构造函数设置推回缓冲区的大小,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PushbackInputStream input = <span class="keyword">new</span> PushbackInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\input.txt"</span>), <span class="number">8</span>);</span><br></pre></td></tr></table></figure></p><p>这个例子设置了8个字节的缓冲区,意味着你最多可以重新读取8个字节的数据。</p><h3 id="PushbackReader"><a href="#PushbackReader" class="headerlink" title="PushbackReader"></a>PushbackReader</h3><p>PushbackReader与PushbackInputStream类似,唯一不同的是PushbackReader处理字符,PushbackInputStream处理字节。代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PushbackReader reader = <span class="keyword">new</span> PushbackReader(<span class="keyword">new</span> FileReader(<span class="string">"c:\\data\\input.txt"</span>));</span><br><span class="line"><span class="keyword">int</span> data = reader.read();</span><br><span class="line">reader.unread(data);</span><br></pre></td></tr></table></figure></p><p>同样可以设置缓冲区大小,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PushbackReader reader = <span class="keyword">new</span> PushbackReader(<span class="keyword">new</span> FileReader(<span class="string">"c:\\data\\input.txt"</span>), <span class="number">8</span>);</span><br></pre></td></tr></table></figure></p><h3 id="SequenceInputStream"><a href="#SequenceInputStream" class="headerlink" title="SequenceInputStream"></a>SequenceInputStream</h3><p>SequenceInputStream把一个或者多个InputStream整合起来,形成一个逻辑连贯的输入流。当读取SequenceInputStream时,会先从第一个输入流中读取,完成之后再从第二个输入流读取,以此推类。代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InputStream input1 = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\file1.txt"</span>);</span><br><span class="line">InputStream input2 = <span class="keyword">new</span> FileInputStream(<span class="string">"c:\\data\\file2.txt"</span>);</span><br><span class="line">InputStream combined = <span class="keyword">new</span> SequenceInputStream(input1, input2);</span><br></pre></td></tr></table></figure><p>通过SequenceInputStream,例子中的2个InputStream使用起来就如同只有一个InputStream一样(译者注:SequenceInputStream的read()方法会在读取到当前流末尾时,关闭流,并把当前流指向逻辑链中的下一个流,最后返回新的当前流的read()值)。</p><h3 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h3><p>PrintStream允许你把格式化数据写入到底层OutputStream中。比如,写入格式化成文本的int,long以及其他原始数据类型到输出流中,而非它们的字节数据。代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PrintStream output = <span class="keyword">new</span> PrintStream(outputStream);</span><br><span class="line">output.print(<span class="keyword">true</span>);</span><br><span class="line">output.print((<span class="keyword">int</span>) <span class="number">123</span>);</span><br><span class="line">output.print((<span class="keyword">float</span>) <span class="number">123.456</span>);</span><br><span class="line">output.printf(Locale.UK, <span class="string">"Text + data: %1$"</span>, <span class="number">123</span>);</span><br><span class="line">output.close();</span><br></pre></td></tr></table></figure></p><p>PrintStream包含2个强大的函数,分别是format()和printf()(这两个函数几乎做了一样的事情,但是C程序员会更熟悉printf())。</p><p>译者注:其中一个printf()函数实现如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PrintStream <span class="title">printf</span><span class="params">(String format, Object ... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> format(format, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h3><p>与PrintStream类似,PrintWriter可以把格式化后的数据写入到底层writer中。由于内容相似,不再赘述。</p><p>值得一提的是,PrintWriter有更多种构造函数供使用者选择,除了可以输出到文件、Writer以外,还可以输出到OutputStream中(译者注:PrintStream只能把数据输出到文件和OutputStream)。</p><h3 id="LineNumberReader"><a href="#LineNumberReader" class="headerlink" title="LineNumberReader"></a>LineNumberReader</h3><p>LineNumberReader是记录了已读取数据行号的BufferedReader。默认情况下,行号从0开始,当LineNumberReader读取到行终止符时,行号会递增(译者注:换行\n,回车\r,或者换行回车\n\r都是行终止符)。</p><p>你可以通过getLineNumber()方法获取当前行号,通过setLineNumber()方法设置当前行数(译者注:setLineNumber()仅仅改变LineNumberReader内的记录行号的变量值,不会改变当前流的读取位置。流的读取依然是顺序进行,意味着你不能通过setLineNumber()实现流的跳跃读取)。代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LineNumberReader reader = <span class="keyword">new</span> LineNumberReader(<span class="keyword">new</span> FileReader(<span class="string">"c:\\data\\input.txt"</span>));</span><br><span class="line"><span class="keyword">int</span> data = reader.read();</span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">char</span> dataChar = (<span class="keyword">char</span>) data;</span><br><span class="line">    data = reader.read();</span><br><span class="line">    <span class="keyword">int</span> lineNumber = reader.getLineNumber();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果解析的文本有错误,LineNumberReader可以很方便地定位问题。当你把错误报告给用户时,如果能够同时把出错的行号提供给用户,用户就能迅速发现并且解决问题。</p><h3 id="StreamTokenizer"><a href="#StreamTokenizer" class="headerlink" title="StreamTokenizer"></a>StreamTokenizer</h3><p>StreamTokenizer(译者注:请注意不是StringTokenizer)可以把输入流(译者注:InputStream和Reader。通过InputStream构造StreamTokenizer的构造函数已经在JDK1.1版本过时,推荐将InputStream转化成Reader,再利用此Reader构造StringTokenizer)分解成一系列符号。比如,句子”Mary had a little lamb”的每个单词都是一个单独的符号。</p><p>当你解析文件或者计算机语言时,为了进一步的处理,需要将解析的数据分解成符号。通常这个过程也称作分词。</p><p>通过循环调用nextToken()可以遍历底层输入流的所有符号。在每次调用nextToken()之后,StreamTokenizer有一些变量可以帮助我们获取读取到的符号的类型和值。这些变量是:</p><p>ttype 读取到的符号的类型(字符,数字,或者行结尾符)</p><p>sval 如果读取到的符号是字符串类型,该变量的值就是读取到的字符串的值</p><p>nval 如果读取到的符号是数字类型,该变量的值就是读取到的数字的值</p><p>代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">StreamTokenizer tokenizer = <span class="keyword">new</span> StreamTokenizer(<span class="keyword">new</span> StringReader(<span class="string">"Mary had 1 little lamb..."</span>));</span><br><span class="line"><span class="keyword">while</span>(tokenizer.nextToken() != StreamTokenizer.TT_EOF)&#123;</span><br><span class="line">    <span class="keyword">if</span>(tokenizer.ttype == StreamTokenizer.TT_WORD) &#123;</span><br><span class="line">        System.out.println(tokenizer.sval);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tokenizer.ttype == StreamTokenizer.TT_NUMBER) &#123;</span><br><span class="line">        System.out.println(tokenizer.nval);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(tokenizer.ttype == StreamTokenizer.TT_EOL) &#123;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>译者注:TT_EOF表示流末尾,TT_EOL表示行末尾。</p><p>StreamTokenizer可以识别标示符,数字,引用的字符串,和多种注释类型。你也可以指定何种字符解释成空格、注释的开始以及结束等。在StreamTokenizer开始解析之前,所有的功能都可以进行配置。请查阅官方文档获取更多信息。</p><h3 id="StringReader"><a href="#StringReader" class="headerlink" title="StringReader"></a>StringReader</h3><p>StringReader能够将原始字符串转换成Reader,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Reader reader = <span class="keyword">new</span> StringReader(<span class="string">"input string..."</span>);</span><br><span class="line"><span class="keyword">int</span> data = reader.read();</span><br><span class="line"><span class="keyword">while</span>(data != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//do something with data...</span></span><br><span class="line">    doSomethingWithData(data);</span><br><span class="line">    data = reader.read();</span><br><span class="line">&#125;</span><br><span class="line">reader.close();</span><br></pre></td></tr></table></figure></p><h3 id="StringWriter"><a href="#StringWriter" class="headerlink" title="StringWriter"></a>StringWriter</h3><p>StringWriter能够以字符串的形式从Writer中获取写入到其中数据,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringWriter writer = <span class="keyword">new</span> StringWriter();</span><br><span class="line"><span class="comment">//write characters to writer.</span></span><br><span class="line">String data = writer.toString();</span><br><span class="line">StringBuffer dataBuffer = writer.getBuffer();</span><br></pre></td></tr></table></figure></p><p>toString()方法能够获取StringWriter中的字符串数据。</p><p>getBuffer()方法能够获取StringWriter内部构造字符串时所使用的StringBuffer对象。</p><p>ref:<br><a href="http://tutorials.jenkov.com/java-io/index.html" target="_blank" rel="noopener">http://tutorials.jenkov.com/java-io/index.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java IO 是一套Java用来读写数据(输入和输出)的API。大部分程序都要处理一些输入,并由输入产生一些输出。Java为此提供了java.io包。&lt;/p&gt;
&lt;p&gt;如果你浏览下java.io包,会对其中各样的类选择感到迷惑。这些类的作用都是什么？对于某个任务该选择哪个类？怎样创建你自己的类做插件？这个手册的目的就是给你介绍这些类是如何组织的,以及怎样使用他们,因此你就不会疑惑需要时怎样选取合适的类,或者是否有一个满足你需求的类已经存在了。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.atecher.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.atecher.com/tags/Java/"/>
    
      <category term="IO" scheme="http://blog.atecher.com/tags/IO/"/>
    
  </entry>
  
  <entry>
    <title>Java-LinkedList-LinkedList的局限</title>
    <link href="http://blog.atecher.com/2017/09/29/Java-LinkedList%E7%9A%84%E5%B1%80%E9%99%90/"/>
    <id>http://blog.atecher.com/2017/09/29/Java-LinkedList的局限/</id>
    <published>2017-09-29T00:00:00.000Z</published>
    <updated>2022-01-28T10:28:39.119Z</updated>
    
    <content type="html"><![CDATA[<p>java.util.LinkedList是双向链表,这个大家都知道,比如Java的基础面试题喜欢问ArrayList和LinkedList的区别,在什么场景下用。<br>大家都会说LinkedList随机增删多的场景比较合适,而ArrayList的随机访问多的场景比较合适。<br>更进一步,我有时候会问,LinkedList.remove(Object)方法的时间复杂度是什么？有的人回答对了,有的人回答错了。回答错的应该是没有读过源码。<br>理论上说,双向链表的删除的时间复杂度是O(1),你只需要将要删除的节点的前节点和后节点相连,然后将要删除的节点的前节点和后节点置为null即可,</p><a id="more"></a><p>先看看删除操作<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlinks non-null node x.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个操作的时间复杂度可以认为是O(1)级别的。但是LinkedList的实现是一个通用的数据结构,因此没有暴露内部的节点 Node 对象,remove(Object)传入的Object其实是节点存储的value,这里还需要一个查找过程:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 查找节点 Node</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因此,显然,LinkedList.remove(Object)方法的时间复杂度是O(n)+O(1),结果仍然是O(n)的时间复杂度,而非推测的O(1)复杂度。最坏情况下要删除的元素是最后一个,你都要比较 N-1 次才能找到要删除的元素。</p><p>既然如此,说LinkedList适合随机删减有个前提,链表的大小不能太大,如果链表元素非常多,调用remove(Object)去删除一个元素的效率肯定有影响,一个简单测试,插入100万数据,随机删除1000个元素:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> count = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">list.add(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Random rand = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">long</span> start = System.nanoTime();</span><br><span class="line"><span class="comment">// remove(Object) 耗时 3.196757626</span></span><br><span class="line"><span class="comment">/*for (int i = 0; i &lt; 1000; i++) &#123;</span></span><br><span class="line"><span class="comment">//这里要强制转型为Integer,否则调用的是remove(int)</span></span><br><span class="line"><span class="comment">list.remove((Integer) rand.nextInt(count));</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// remove(int) 耗时 1.182296505</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">           <span class="comment">// 随机数范围要递减,防止数组越界</span></span><br><span class="line">list.remove(rand.nextInt(list.size() - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println((System.nanoTime() - start) / Math.pow(<span class="number">10</span>, <span class="number">9</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在我的机器上耗时近 3.19 秒,删除1000个元素耗时 3.19 秒,耗时很长？注意到上面的注释,产生的随机数强制转为Integer对象,否则调用的是 remove(int)方法,而非remove(Object)。如果我们调用remove(int)根据索引来删除,换成remove(int)效率提高不少,这是因为 remove(int)的实现很有技巧,它首先判断索引位置在链表的前半部分还是后半部分,如果是前半部分则从head往前查找,如果在后半部分,则从 head往后查找（LinkedList的实现是一个环）:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// size &gt;&gt; 1 判断索引位置是前半部分还是后半部分</span></span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最坏情况下要删除的节点在中点左右,查找的次数仍然达到n/2次,但是注意到这里没有比较的开销,并且比remove(Object)最坏情况下n次查找还是好很多。</p><p>总结下,LinkedList的两个remove方法,remove(Object)和remove(int)的时间复杂度都是O(n),在链表元素很多并且没有索引可用的情况下,LinkedList也并不适合做随机增删元素。在对性能特别敏感的场景下,还是需要自己实现专用的双向链表结构,真正实现 O(1)级别的随机增删。更进一步,jdk5引入的ConcurrentLinkedQueue是一个非阻塞的线程安全的双向队列实现,同样有本文提到的问题,有兴趣可以测试一下在大量元素情况下的并发随机增删,效率跟自己实现的特定类型的线程安全的链表差距是惊人的。</p><p>题外,ArrayList比LinkedList更不适合随机增删的原因是多了一个数组移动的动作,假设你删除的元素在m,那么除了要查找m次之外,还需要往前移动 n-m-1 个元素。</p><p>ref:<br><a href="http://jm.taobao.org/2010/09/16/322/" target="_blank" rel="noopener">http://jm.taobao.org/2010/09/16/322/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;java.util.LinkedList是双向链表,这个大家都知道,比如Java的基础面试题喜欢问ArrayList和LinkedList的区别,在什么场景下用。&lt;br&gt;大家都会说LinkedList随机增删多的场景比较合适,而ArrayList的随机访问多的场景比较合适。&lt;br&gt;更进一步,我有时候会问,LinkedList.remove(Object)方法的时间复杂度是什么？有的人回答对了,有的人回答错了。回答错的应该是没有读过源码。&lt;br&gt;理论上说,双向链表的删除的时间复杂度是O(1),你只需要将要删除的节点的前节点和后节点相连,然后将要删除的节点的前节点和后节点置为null即可,&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.atecher.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.atecher.com/tags/Java/"/>
    
      <category term="LinkedList" scheme="http://blog.atecher.com/tags/LinkedList/"/>
    
  </entry>
  
  <entry>
    <title>Java-Thread-线程池的分析和使用</title>
    <link href="http://blog.atecher.com/2017/09/29/Java-Thread-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%86%E6%9E%90%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://blog.atecher.com/2017/09/29/Java-Thread-线程池的分析和使用/</id>
    <published>2017-09-29T00:00:00.000Z</published>
    <updated>2022-01-28T10:28:39.119Z</updated>
    
    <content type="html"><![CDATA[<p>合理利用线程池能够带来三个好处:</p><ol><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时,任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源,如果无限制的创建,不仅会消耗系统资源,还会降低系统的稳定性,使用线程池可以进行统一的分配,调优和监控。但是要做到合理的利用线程池,必须对其原理了如指掌。</li></ol><a id="more"></a><h2 id="线程池的使用"><a href="#线程池的使用" class="headerlink" title="线程池的使用"></a>线程池的使用</h2><h3 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h3><p>我们可以通过ThreadPoolExecutor来创建一个线程池<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadPoolExecutor(corePoolSize, </span><br><span class="line">                    maximumPoolSize, </span><br><span class="line">                    keepAliveTime, </span><br><span class="line">                    milliseconds,</span><br><span class="line">                    runnableTaskQueue, </span><br><span class="line">                    threadFactory,</span><br><span class="line">                    handler);</span><br></pre></td></tr></table></figure></p><p>创建一个线程池需要输入几个参数:</p><ul><li>corePoolSize(线程池的基本大小):当提交一个任务到线程池时,线程池会创建一个线程来执行任务,即使其他空闲的基本线程能够执行新任务也会创建线程,等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads方法,线程池会提前创建并启动所有基本线程。</li><li><p>runnableTaskQueue(任务队列):用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。</p><ul><li>ArrayBlockingQueue:是一个基于数组结构的有界阻塞队列,此队列按 FIFO(先进先出)原则对元素进行排序。</li><li>LinkedBlockingQueue:一个基于链表结构的阻塞队列,此队列按FIFO (先进先出) 排序元素,吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li><li>SynchronousQueue:一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作,否则插入操作一直处于阻塞状态,吞吐量通常要高于LinkedBlockingQueue,静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li><li>PriorityBlockingQueue:一个具有优先级得无限阻塞队列。</li></ul></li><li><p>maximumPoolSize(线程池最大大小):线程池允许创建的最大线程数。如果队列满了,并且已创建的线程数小于最大线程数,则线程池会再创建新的线程执行任务。值得注意的是如果使用了无界的任务队列这个参数就没什么效果。</p></li><li>ThreadFactory:用于设置创建线程的工厂,可以通过线程工厂给每个创建出来的线程设置更有意义的名字,Debug和定位问题时非常又帮助。</li><li><p>RejectedExecutionHandler(饱和策略):当队列和线程池都满了,说明线程池处于饱和状态,那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy,表示无法处理新任务时抛出异常。以下是JDK1.5提供的四种策略。</p><ul><li>AbortPolicy:直接抛出异常。</li><li>CallerRunsPolicy:只用调用者所在线程来运行任务。</li><li>DiscardOldestPolicy:丢弃队列里最近的一个任务,并执行当前任务。</li><li>DiscardPolicy:不处理,丢弃掉。</li><li>当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。</li></ul></li><li><p>keepAliveTime(线程活动保持时间):线程池的工作线程空闲后,保持存活的时间。所以如果任务很多,并且每个任务执行的时间比较短,可以调大这个时间,提高线程的利用率。</p></li><li>TimeUnit(线程活动保持时间的单位):可选的单位有天(DAYS),小时(HOURS),分钟(MINUTES),毫秒(MILLISECONDS),微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。</li></ul><h3 id="向线程池提交任务"><a href="#向线程池提交任务" class="headerlink" title="向线程池提交任务"></a>向线程池提交任务</h3><p>我们可以使用execute提交的任务,但是execute方法没有返回值,所以无法判断任务知否被线程池执行成功。通过以下代码可知execute方法输入的任务是一个Runnable类的实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">threadsPool.execute(<span class="keyword">new</span> Runnable() &#123;  </span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>我们也可以使用submit 方法来提交任务,它会返回一个future,那么我们可以通过这个future来判断任务是否执行成功,通过future的get方法来获取返回值,get方法会阻塞住直到任务完成,而使用get(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回,这时有可能任务没有执行完。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Future&lt;Object&gt; future = executor.submit(harReturnValuetask);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     Object s = future.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    <span class="comment">// 处理中断异常</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    <span class="comment">// 处理无法执行任务异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭线程池</span></span><br><span class="line">    executor.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h3><p>我们可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池,它们的原理是遍历线程池中的工作线程,然后逐个调用线程的interrupt方法来中断线程,所以无法响应中断的任务可能永远无法终止。但是它们存在一定的区别,shutdownNow首先将线程池的状态设置成STOP,然后尝试停止所有的正在执行或暂停任务的线程,并返回等待执行任务的列表,而shutdown只是将线程池的状态设置成SHUTDOWN状态,然后中断所有没有正在执行任务的线程。</p><p>只要调用了这两个关闭方法的其中一个,isShutdown方法就会返回true。当所有的任务都已关闭后,才表示线程池关闭成功,这时调用isTerminaed方法会返回true。至于我们应该调用哪一种方法来关闭线程池,应该由提交到线程池的任务特性决定,通常调用shutdown来关闭线程池,如果任务不一定要执行完,则可以调用shutdownNow。</p><h2 id="线程池的分析"><a href="#线程池的分析" class="headerlink" title="线程池的分析"></a>线程池的分析</h2><p>流程分析:线程池的主要工作流程如下图:</p><p><a href="//qn.atecher.com/threadpool.jpg"><img src="//qn.atecher.com/threadpool.jpg" alt=""></a></p><p>从上图我们可以看出,当提交一个新任务到线程池时,线程池的处理流程如下:</p><ol><li>首先线程池判断基本线程池是否已满？没满,创建一个工作线程来执行任务。满了,则进入下个流程。</li><li>其次线程池判断工作队列是否已满？没满,则将新提交的任务存储在工作队列里。满了,则进入下个流程。</li><li>最后线程池判断整个线程池是否已满？没满,则创建一个新的工作线程来执行任务,满了,则交给饱和策略来处理这个任务。</li></ol><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>上面的流程分析让我们很直观的了解了线程池的工作原理,让我们再通过源代码来看看是如何实现的。线程池执行任务的方法如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">//如果线程数小于基本线程数,则创建线程并执行当前任务 </span></span><br><span class="line">    <span class="keyword">if</span> (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;</span><br><span class="line">        <span class="comment">//如线程数大于等于基本线程数或线程创建失败,则将当前任务放到工作队列中。</span></span><br><span class="line">        <span class="keyword">if</span> (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runState != RUNNING || poolSize == <span class="number">0</span>)</span><br><span class="line">                      ensureQueuedTaskHandled(command);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果线程池不处于运行中或任务无法放入队列,并且当前线程数量小于最大允许的线程数量,则创建一个线程执行任务。</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addIfUnderMaximumPoolSize(command))</span><br><span class="line">            <span class="comment">//抛出RejectedExecutionException异常</span></span><br><span class="line">            reject(command); <span class="comment">// is shutdown or saturated</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="工作线程"><a href="#工作线程" class="headerlink" title="工作线程"></a>工作线程</h3><p>线程池创建线程时,会将线程封装成工作线程Worker,Worker在执行完任务后,还会无限循环获取工作队列里的任务来执行。我们可以从Worker的run方法里看到这点:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Runnable task = firstTask;</span><br><span class="line">        firstTask = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">             runTask(task);</span><br><span class="line">             task = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         workerDone(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="合理的配置线程池"><a href="#合理的配置线程池" class="headerlink" title="合理的配置线程池"></a>合理的配置线程池</h2><p>要想合理的配置线程池,就必须首先分析任务特性,可以从以下几个角度来进行分析:</p><ul><li>任务的性质:CPU密集型任务,IO密集型任务和混合型任务。</li><li>任务的优先级:高,中和低。</li><li>任务的执行时间:长,中和短。</li><li>任务的依赖性:是否依赖其他系统资源,如数据库连接。</li></ul><p>任务性质不同的任务可以用不同规模的线程池分开处理。CPU密集型任务配置尽可能小的线程,如配置Ncpu+1个线程的线程池。IO密集型任务则由于线程并不是一直在执行任务,则配置尽可能多的线程,如2*Ncpu。混合型的任务,如果可以拆分,则将其拆分成一个CPU密集型任务和一个IO密集型任务,只要这两个任务执行的时间相差不是太大,那么分解后执行的吞吐率要高于串行执行的吞吐率,如果这两个任务执行时间相差太大,则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p><p>优先级不同的任务可以使用优先级队列PriorityBlockingQueue来处理。它可以让优先级高的任务先得到执行,需要注意的是如果一直有优先级高的任务提交到队列里,那么优先级低的任务可能永远不能执行。</p><p>执行时间不同的任务可以交给不同规模的线程池来处理,或者也可以使用优先级队列,让执行时间短的任务先执行。</p><p>依赖数据库连接池的任务,因为线程提交SQL后需要等待数据库返回结果,如果等待的时间越长CPU空闲时间就越长,那么线程数应该设置越大,这样才能更好的利用CPU。</p><p>建议使用有界队列,有界队列能增加系统的稳定性和预警能力,可以根据需要设大一点,比如几千。有一次我们组使用的后台任务线程池的队列和线程池全满了,不断的抛出抛弃任务的异常,通过排查发现是数据库出现了问题,导致执行SQL变得非常缓慢,因为后台任务线程池里的任务全是需要向数据库查询和插入数据的,所以导致线程池里的工作线程全部阻塞住,任务积压在线程池里。如果当时我们设置成无界队列,线程池的队列就会越来越多,有可能会撑满内存,导致整个系统不可用,而不只是后台任务出现问题。当然我们的系统所有的任务是用的单独的服务器部署的,而我们使用不同规模的线程池跑不同类型的任务,但是出现这样问题时也会影响到其他任务。</p><h2 id="线程池的监控"><a href="#线程池的监控" class="headerlink" title="线程池的监控"></a>线程池的监控</h2><p>通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用</p><ul><li>taskCount:线程池需要执行的任务数量。</li><li>completedTaskCount:线程池在运行过程中已完成的任务数量。小于或等于taskCount。</li><li>largestPoolSize:线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小,则表示线程池曾经满了。</li><li>getPoolSize:线程池的线程数量。如果线程池不销毁的话,池里的线程不会自动销毁,所以这个大小只增不减</li><li>getActiveCount:获取活动的线程数。</li></ul><p>通过扩展线程池进行监控。通过继承线程池并重写线程池的beforeExecute,afterExecute和terminated方法,我们可以在任务执行前,执行后和线程池关闭前干一些事情。如监控任务的平均执行时间,最大执行时间和最小执行时间等。这几个方法在线程池里是空方法。如:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>Java并发编程实战。<br>JDK1.6源码</p><p>ref:<br><a href="http://www.infoq.com/cn/articles/java-threadPool" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/java-threadPool</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;合理利用线程池能够带来三个好处:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。&lt;/li&gt;
&lt;li&gt;提高响应速度。当任务到达时,任务可以不需要的等到线程创建就能立即执行。&lt;/li&gt;
&lt;li&gt;提高线程的可管理性。线程是稀缺资源,如果无限制的创建,不仅会消耗系统资源,还会降低系统的稳定性,使用线程池可以进行统一的分配,调优和监控。但是要做到合理的利用线程池,必须对其原理了如指掌。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.atecher.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.atecher.com/tags/Java/"/>
    
      <category term="Thread" scheme="http://blog.atecher.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Map、Set、List、Queue、Stack的特点与用法</title>
    <link href="http://blog.atecher.com/2017/09/27/Map-Set-List-Queue-Stack/"/>
    <id>http://blog.atecher.com/2017/09/27/Map-Set-List-Queue-Stack/</id>
    <published>2017-09-27T10:35:46.000Z</published>
    <updated>2022-01-28T10:28:39.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java集合类基本概念"><a href="#Java集合类基本概念" class="headerlink" title="Java集合类基本概念"></a>Java集合类基本概念</h2><p>在编程中，常常需要集中存放多个数据。从传统意义上讲，数组是我们的一个很好的选择，前提是我们事先已经明确知道我们将要保存的对象的数量。一旦在数组初始化时指定了这个数组长度，这个数组长度就是不可变的，如果我们需要保存一个可以动态增长的数据(在编译时无法确定具体的数量)，java的集合类就是一个很好的设计方案了。</p><a id="more"></a><p>集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。所以的集合类都位于java.util包下，后来为了处理多线程环境下的并发安全问题，java5还在java.util.concurrent包下提供了一些多线程支持的集合类。</p><p>在学习Java中的集合类的API、编程原理的时候，我们一定要明白，”集合”是一个很古老的数学概念，它远远早于Java的出现。从数学概念的角度来理解集合能帮助我们更好的理解编程中什么时候该使用什么类型的集合类。</p><p>Java容器类类库的用途是”保存对象”，并将其划分为两个不同的概念：</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><p>一组”对立”的元素，通常这些元素都服从某种规则:</p><blockquote><ol><li>List必须保持元素特定的顺序</li><li>Set不能有重复元素</li><li>Queue保持一个队列(先进先出)的顺序</li></ol></blockquote><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><blockquote><p>一组成对的”键值对”对象</p></blockquote><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>Collection和Map的区别在于容器中每个位置保存的元素个数:</p><blockquote><ol><li>Collection 每个位置只能保存一个元素(对象)</li><li>Map保存的是”键值对”，就像一个小型数据库。我们可以通过”键”找到该键对应的”值”</li></ol></blockquote><h2 id="Java集合类架构层次关系"><a href="#Java集合类架构层次关系" class="headerlink" title="Java集合类架构层次关系"></a>Java集合类架构层次关系</h2><h3 id="Interface-Iterable"><a href="#Interface-Iterable" class="headerlink" title="Interface Iterable"></a>Interface Iterable</h3><p>迭代器接口，这是Collection类的父接口。实现这个Iterable接口的对象允许使用foreach进行遍历，也就是说，所有的Collection集合对象都具有”foreach可遍历性”。这个Iterable接口只有一个方法: iterator()。它返回一个代表当前集合对象的泛型<t>迭代器，用于之后的遍历操作。</t></p><h4 id="Collection-1"><a href="#Collection-1" class="headerlink" title="Collection"></a>Collection</h4><p>Collection是最基本的集合接口，一个Collection代表一组Object的集合，这些Object被称作Collection的元素。Collection是一个接口，用以提供规范定义，不能被实例化使用</p><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>Set集合类似于一个罐子，”丢进”Set集合里的多个对象之间没有明显的顺序。Set继承自Collection接口，不能包含有重复元素<strong>(记住，这是整个Set类层次的共有属性)</strong>。</p><p>Set判断两个对象相同不是使用”==”运算符，而是根据equals方法。也就是说，我们在加入一个新元素的时候，如果这个新元素对象和Set中已有对象进行注意equals比较都返回false，则Set就会接受这个新元素对象，否则拒绝。</p><p>因为Set的这个制约，在使用Set集合的时候，应该注意两点：</p><blockquote><p>1) 为Set集合里的元素的实现类实现一个有效的equals(Object)方法、<br>2) 对Set的构造函数，传入的Collection参数不能包含重复的元素</p></blockquote><h6 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h6><p>HashSet是Set接口的典型实现，HashSet使用HASH算法来存储集合中的元素，因此具有良好的存取和查找性能。当向HashSet集合中存入一个元素时，HashSet会调用该对象的hashCode()方法来得到该对象的hashCode值，然后根据该HashCode值决定该对象在HashSet中的存储位置。</p><p>值得主要的是，HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()的返回值相等。</p><p><strong>LinkedHashSet</strong></p><p>LinkedHashSet集合也是根据元素的hashCode值来决定元素的存储位置，但和HashSet不同的是，它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。</p><p>当遍历LinkedHashSet集合里的元素时，LinkedHashSet将会按元素的添加顺序来访问集合里的元素。</p><p>LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet的性能，但在迭代访问Set里的全部元素时(遍历)将有很好的性能(链表很适合进行遍历)。</p><h6 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h6><p>此接口主要用于排序操作，即实现此接口的子类都属于排序的子类</p><p><strong>TreeSet</strong></p><p>TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态</p><h6 id="EnumSet"><a href="#EnumSet" class="headerlink" title="EnumSet"></a>EnumSet</h6><p>EnumSet是一个专门为枚举类设计的集合类，EnumSet中所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式、或隐式地指定。EnumSet的集合元素也是有序的，它们以枚举值在Enum类内的定义顺序来决定集合元素的顺序</p><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许加入重复元素，因为它可以通过索引来访问指定位置的集合元素。List集合默认按元素的添加顺序设置元素的索引。</p><h6 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h6><p>ArrayList是基于数组实现的List类，它封装了一个动态的增长的、允许再分配的Object[]数组。</p><h6 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h6><p>Vector和ArrayList在用法上几乎完全相同，但由于Vector是一个古老的集合，所以Vector提供了一些方法名很长的方法，但随着JDK1.2以后，java提供了系统的集合框架，就将Vector改为实现List接口，统一归入集合框架体系中</p><p><strong>Stack</strong></p><p>Stack是Vector提供的一个子类，用于模拟”栈”这种数据结构(LIFO后进先出)</p><h6 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h6><p>implements List<e>, Deque<e>。实现List接口，能对它进行队列操作，即可以根据索引来随机访问集合中的元素。同时它还实现Deque接口，即能将LinkedList当作双端队列使用。自然也可以被当作”栈来使用”</e></e></p><h5 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h5><p>Queue用于模拟”队列”这种数据结构(先进先出 FIFO)。队列的头部保存着队列中存放时间最长的元素，队列的尾部保存着队列中存放时间最短的元素。新元素插入(offer)到队列的尾部，访问元素(poll)操作会返回队列头部的元素，队列不允许随机访问队列中的元素。结合生活中常见的排队就会很好理解这个概念</p><h6 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h6><p>PriorityQueue并不是一个比较标准的队列实现，PriorityQueue保存队列元素的顺序并不是按照加入队列的顺序，而是按照队列元素的大小进行重新排序，这点从它的类名也可以看出来</p><h6 id="Deque"><a href="#Deque" class="headerlink" title="Deque"></a>Deque</h6><p>Deque接口代表一个”双端队列”，双端队列可以同时从两端来添加、删除元素，因此Deque的实现类既可以当成队列使用、也可以当成栈使用<br><strong>ArrayDeque</strong></p><p>是一个基于数组的双端队列，和ArrayList类似，它们的底层都采用一个动态的、可重分配的Object[]数组来存储集合元素，当集合元素超出该数组的容量时，系统会在底层重新分配一个Object[]数组来存储集合元素</p><p><strong>LinkedList</strong></p><h4 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h4><p>Map用于保存具有”映射关系”的数据，因此Map集合里保存着两组值，一组值用于保存Map里的key，另外一组值用于保存Map里的value。key和value都可以是任何引用类型的数据。Map的key不允许重复，即同一个Map对象的任何两个key通过equals方法比较结果总是返回false。</p><p>关于Map，我们要从代码复用的角度去理解，java是先实现了Map，然后通过包装了一个所有value都为null的Map就实现了Set集合</p><p>Map的这些实现类和子接口中key集的存储形式和Set集合完全相同(即key不能重复)</p><p>Map的这些实现类和子接口中value集的存储形式和List非常类似(即value可以重复、根据索引来查找)</p><h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><p>和HashSet集合不能保证元素的顺序一样，HashMap也不能保证key-value对的顺序。并且类似于HashSet判断两个key是否相等的标准也是: 两个key通过equals()方法比较返回true、同时两个key的hashCode值也必须相等</p><h6 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h6><p>LinkedHashMap也使用双向链表来维护key-value对的次序，该链表负责维护Map的迭代顺序，与key-value对的插入顺序一致(注意和TreeMap对所有的key-value进行排序进行区分)</p><h5 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h5><p>是一个古老的Map实现类</p><h6 id="Properties"><a href="#Properties" class="headerlink" title="Properties"></a>Properties</h6><p>Properties对象在处理属性文件时特别方便(windows平台上的.ini文件),Properties类可以把Map对象和属性文件关联起来，从而可以把Map对象中的key-value对写入到属性文件中，也可以把属性文件中的”属性名-属性值”加载到Map对象中</p><h5 id="SortedMap"><a href="#SortedMap" class="headerlink" title="SortedMap"></a>SortedMap</h5><p>正如Set接口派生出SortedSet子接口，SortedSet接口有一个TreeSet实现类一样，Map接口也派生出一个SortedMap子接口，SortedMap接口也有一个TreeMap实现类</p><h6 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h6><p>TreeMap就是一个红黑树数据结构，每个key-value对即作为红黑树的一个节点。TreeMap存储key-value对(节点)时，需要根据key对节点进行排序。TreeMap可以保证所有的key-value对处于有序状态。同样，TreeMap也有两种排序方式: 自然排序、定制排序</p><h5 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h5><p>WeakHashMap与HashMap的用法基本相似。区别在于，HashMap的key保留了对实际对象的”强引用”，这意味着只要该HashMap对象不被销毁，该HashMap所引用的对象就不会被垃圾回收。但WeakHashMap的key只保留了对实际对象的弱引用，这意味着如果WeakHashMap对象的key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象可能被垃圾回收，当垃圾回收了该key所对应的实际对象之后，WeakHashMap也可能自动删除这些key所对应的key-value对</p><h5 id="IdentityHashMap"><a href="#IdentityHashMap" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h5><p>IdentityHashMap的实现机制与HashMap基本相似，在IdentityHashMap中，当且仅当两个key严格相等(key1 == key2)时，IdentityHashMap才认为两个key相等</p><h5 id="EnumMap"><a href="#EnumMap" class="headerlink" title="EnumMap"></a>EnumMap</h5><p>EnumMap是一个与枚举类一起使用的Map实现，EnumMap中的所有key都必须是单个枚举类的枚举值。创建EnumMap时必须显式或隐式指定它对应的枚举类。EnumMap根据key的自然顺序(即枚举值在枚举类中的定义顺序)</p><p><img src="//qn.atecher.com/mts/20180418/3853301862220800" alt="map-set-list-queue-stack-1"></p><h2 id="Java集合类的应用场景代码"><a href="#Java集合类的应用场景代码" class="headerlink" title="Java集合类的应用场景代码"></a>Java集合类的应用场景代码</h2><p>学习了集合类的基本架构框架之后，我们接着来学习它们各自的应用场景、以及细节处的注意事项:</p><h3 id="Set-1"><a href="#Set-1" class="headerlink" title="Set"></a>Set</h3><h4 id="HashSet-1"><a href="#HashSet-1" class="headerlink" title="HashSet"></a>HashSet</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="comment">//类A的equals方法总是返回true,但没有重写其hashCode()方法。不能保证当前对象是HashSet中的唯一对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类B的hashCode()方法总是返回1,但没有重写其equals()方法。不能保证当前对象是HashSet中的唯一对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类C的hashCode()方法总是返回2,且有重写其equals()方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSetTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        HashSet books = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="comment">//分别向books集合中添加两个A对象，两个B对象，两个C对象</span></span><br><span class="line">        books.add(<span class="keyword">new</span> A());</span><br><span class="line">        books.add(<span class="keyword">new</span> A());</span><br><span class="line"></span><br><span class="line">        books.add(<span class="keyword">new</span> B());</span><br><span class="line">        books.add(<span class="keyword">new</span> B());</span><br><span class="line"></span><br><span class="line">        books.add(<span class="keyword">new</span> C());</span><br><span class="line">        books.add(<span class="keyword">new</span> C());</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>result:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[B@1, B@1, C@2, A@3bc257, A@785d65]</span><br></pre></td></tr></table></figure><p>可以看到，如果两个对象通过equals()方法比较返回true，但这两个对象的hashCode()方法返回不同的hashCode值时，这将导致HashSet会把这两个对象保存在Hash表的不同位置，从而使对象可以添加成功，这就与Set集合的规则有些出入了。所以，我们要明确的是: equals()决定是否可以加入HashSet、而hashCode()决定存放的位置，它们两者必须同时满足才能允许一个新元素加入HashSet。</p><p>但是要注意的是: 如果两个对象的hashCode相同，但是它们的equlas返回值不同，HashSet会在这个位置用链式结构来保存多个对象。而HashSet访问集合元素时也是根据元素的HashCode值来快速定位的，这种链式结构会导致性能下降。</p><p>所以如果需要把某个类的对象保存到HashSet集合中，我们在重写这个类的equlas()方法和hashCode()方法时，应该尽量保证两个对象通过equals()方法比较返回true时，它们的hashCode()方法返回值也相等</p><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSetTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        LinkedHashSet books = <span class="keyword">new</span> LinkedHashSet();</span><br><span class="line">        books.add(<span class="string">"Java"</span>);</span><br><span class="line">        books.add(<span class="string">"LittleHann"</span>);</span><br><span class="line">        System.out.println(books);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除 Java</span></span><br><span class="line">      books.remove(<span class="string">"Java"</span>);</span><br><span class="line">        <span class="comment">//重新添加 Java</span></span><br><span class="line">        books.add(<span class="string">"Java"</span>);</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元素的顺序总是与添加顺序一致，同时要明白的是，LinkedHashSetTest是HashSet的子类，因此它不允许集合元素重复</p><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TreeSet nums = <span class="keyword">new</span> TreeSet();</span><br><span class="line">        <span class="comment">//向TreeSet中添加四个Integer对象</span></span><br><span class="line">        nums.add(<span class="number">5</span>);</span><br><span class="line">        nums.add(<span class="number">2</span>);</span><br><span class="line">        nums.add(<span class="number">10</span>);</span><br><span class="line">        nums.add(-<span class="number">9</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出集合元素，看到集合元素已经处于排序状态</span></span><br><span class="line">        System.out.println(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出集合里的第一个元素</span></span><br><span class="line">        System.out.println(nums.first());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出集合里的最后一个元素</span></span><br><span class="line">        System.out.println(nums.last());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回小于4的子集，不包含4</span></span><br><span class="line">        System.out.println(nums.headSet(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回大于5的子集，如果Set中包含5，子集中还包含5</span></span><br><span class="line">        System.out.println(nums.tailSet(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回大于等于-3，小于4的子集。</span></span><br><span class="line">        System.out.println(nums.subSet(-<span class="number">3</span> , <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与HashSet集合采用hash算法来决定元素的存储位置不同，TreeSet采用红黑树的数据结构来存储集合元素。TreeSet支持两种排序方式:自然排序、定制排序。</p><ol><li>自然排序</li></ol><p>TreeSet会调用集合元素的compareTo(Object obj)方法来比较元素之间的大小关系，然后将集合元素按升序排序，即自然排序。如果试图把一个对象添加到TreeSet时，则该对象的类必须实现Comparable接口，否则程序会抛出异常。</p><p>当把一个对象加入TreeSet集合中时，TreeSet会调用该对象的compareTo(Object obj)方法与容器中的其他对象比较大小，然后根据红黑树结构找到它的存储位置。如果两个对象通过compareTo(Object obj)方法比较相等，新对象将无法添加到TreeSet集合中(牢记Set是不允许重复的概念)。</p><p>注意: 当需要把一个对象放入TreeSet中，重写该对象对应类的equals()方法时，应该保证该方法与compareTo(Object obj)方法有一致的结果，即如果两个对象通过equals()方法比较返回true时，这两个对象通过compareTo(Object obj)方法比较结果应该也为0(即相等)</p><p>看到这里，我们应该明白：</p><blockquote><ol><li>对与Set来说，它定义了equals()为唯一性判断的标准，而对于到了具体的实现，HashSet、TreeSet来说，它们又会有自己特有的唯一性判断标准，只有同时满足了才能判定为唯一性</li><li>我们在操作这些集合类的时候，对和唯一性判断有关的函数重写要重点关注</li></ol></blockquote><ol><li>定制排序</li></ol><p>TreeSet的自然排序是根据集合元素的大小，TreeSet将它们以升序排序。如果我们需要实现定制排序，则可以通过Comparator接口的帮助(类似PHP中的array_map回调处理函数的思想)。该接口里包含一个int compare(T o1， T o2)方法，该方法用于比较大小</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">M</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">M</span><span class="params">(<span class="keyword">int</span> age)</span>    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span>    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"M[age:"</span> + age + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSetTest4</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TreeSet ts = <span class="keyword">new</span> TreeSet(<span class="keyword">new</span> Comparator()&#123;</span><br><span class="line">            <span class="comment">//根据M对象的age属性来决定大小</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span></span>&#123;</span><br><span class="line">                M m1 = (M)o1;</span><br><span class="line">                M m2 = (M)o2;</span><br><span class="line">                <span class="keyword">return</span> m1.age &gt; m2.age ? -<span class="number">1</span>: m1.age &lt; m2.age ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);   </span><br><span class="line">        ts.add(<span class="keyword">new</span> M(<span class="number">5</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> M(-<span class="number">3</span>));</span><br><span class="line">        ts.add(<span class="keyword">new</span> M(<span class="number">9</span>));</span><br><span class="line">        System.out.println(ts);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里，我们需要梳理一下关于排序的概念</p><blockquote><p>1) equals、compareTo决定的是怎么比的问题，即用什么field进行大小比较<br>2) 自然排序、定制排序、Comparator决定的是谁大的问题，即按什么顺序(升序、降序)进行排序<br>它们的关注点是不同的，一定要注意区分</p></blockquote><h4 id="EnumSet-1"><a href="#EnumSet-1" class="headerlink" title="EnumSet"></a>EnumSet</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Season&#123;</span><br><span class="line">    SPRING,SUMMER,FALL,WINTER</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumSetTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个EnumSet集合，集合元素就是Season枚举类的全部枚举值</span></span><br><span class="line">        EnumSet es1 = EnumSet.allOf(Season.class);</span><br><span class="line">        <span class="comment">//输出[SPRING,SUMMER,FALL,WINTER]</span></span><br><span class="line">        System.out.println(es1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个EnumSet空集合，指定其集合元素是Season类的枚举值。</span></span><br><span class="line">        EnumSet es2 = EnumSet.noneOf(Season.class); </span><br><span class="line">        <span class="comment">//输出[]</span></span><br><span class="line">        System.out.println(es2); </span><br><span class="line">        <span class="comment">//手动添加两个元素</span></span><br><span class="line">        es2.add(Season.WINTER);</span><br><span class="line">        es2.add(Season.SPRING);</span><br><span class="line">        <span class="comment">//输出[SPRING,WINTER]</span></span><br><span class="line">        System.out.println(es2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以指定枚举值创建EnumSet集合</span></span><br><span class="line">        EnumSet es3 = EnumSet.of(Season.SUMMER , Season.WINTER); </span><br><span class="line">        <span class="comment">//输出[SUMMER,WINTER]</span></span><br><span class="line">        System.out.println(es3);</span><br><span class="line"></span><br><span class="line">        EnumSet es4 = EnumSet.range(Season.SUMMER , Season.WINTER); </span><br><span class="line">        <span class="comment">//输出[SUMMER,FALL,WINTER]</span></span><br><span class="line">        System.out.println(es4);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新创建的EnumSet集合的元素和es4集合的元素有相同类型，</span></span><br><span class="line">        <span class="comment">//es5的集合元素 + es4集合元素 = Season枚举类的全部枚举值</span></span><br><span class="line">        EnumSet es5 = EnumSet.complementOf(es4); </span><br><span class="line">        <span class="comment">//输出[SPRING]</span></span><br><span class="line">        System.out.println(es5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是Set集合类的编程应用场景。那么应该怎样选择何时使用这些集合类呢？</p><blockquote><p>1) HashSet的性能总是比TreeSet好(特别是最常用的添加、查询元素等操作)，因为TreeSet需要额外的红黑树算法来维护集合元素的次序。只有当需要一个保持排序的Set时，才应该使用TreeSet，否则都应该使用HashSet</p><p>2) 对于普通的插入、删除操作，LinkedHashSet比HashSet要略慢一点，这是由维护链表所带来的开销造成的。不过，因为有了链表的存在，遍历LinkedHashSet会更快</p><p>3) EnumSet是所有Set实现类中性能最好的，但它只能保存同一个枚举类的枚举值作为集合元素</p><p>4) HashSet、TreeSet、EnumSet都是”线程不安全”的，通常可以通过Collections工具类的synchronizedSortedSet方法来”包装”该Set集合。<br>SortedSet s = Collections.synchronizedSortedSet(new TreeSet(…));</p></blockquote><h3 id="List-1"><a href="#List-1" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList-1"><a href="#ArrayList-1" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>如果一开始就知道ArrayList集合需要保存多少元素，则可以在创建它们时就指定initialCapacity大小，这样可以减少重新分配的次数，提供性能，ArrayList还提供了如下方法来重新分配Object[]数组:</p><blockquote><p>1) ensureCapacity(int minCapacity): 将ArrayList集合的Object[]数组长度增加minCapacity<br>2) trimToSize(): 调整ArrayList集合的Object[]数组长度为当前元素的个数。程序可以通过此方法来减少ArrayList集合对象占用的内存空间</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List books = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="comment">//向books集合中添加三个元素</span></span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"轻量级Java EE企业应用实战"</span>));</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"疯狂Java讲义"</span>));</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"疯狂Android讲义"</span>));</span><br><span class="line">        System.out.println(books);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将新字符串对象插入在第二个位置</span></span><br><span class="line">        books.add(<span class="number">1</span> , <span class="keyword">new</span> String(<span class="string">"疯狂Ajax讲义"</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; books.size() ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(books.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除第三个元素</span></span><br><span class="line">        books.remove(<span class="number">2</span>);</span><br><span class="line">        System.out.println(books);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断指定元素在List集合中位置：输出1，表明位于第二位</span></span><br><span class="line">        System.out.println(books.indexOf(<span class="keyword">new</span> String(<span class="string">"疯狂Ajax讲义"</span>)));  <span class="comment">//①</span></span><br><span class="line">        <span class="comment">//将第二个元素替换成新的字符串对象</span></span><br><span class="line">        books.set(<span class="number">1</span>, <span class="keyword">new</span> String(<span class="string">"LittleHann"</span>));</span><br><span class="line">        System.out.println(books);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将books集合的第二个元素（包括）</span></span><br><span class="line">        <span class="comment">//到第三个元素（不包括）截取成子集合</span></span><br><span class="line">        System.out.println(books.subList(<span class="number">1</span> , <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h4><p>注意Stack的后进先出的特点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Stack v = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="comment">//依次将三个元素push入"栈"</span></span><br><span class="line">        v.push(<span class="string">"疯狂Java讲义"</span>);</span><br><span class="line">        v.push(<span class="string">"轻量级Java EE企业应用实战"</span>);</span><br><span class="line">        v.push(<span class="string">"疯狂Android讲义"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出：[疯狂Java讲义, 轻量级Java EE企业应用实战 , 疯狂Android讲义]</span></span><br><span class="line">        System.out.println(v);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//访问第一个元素，但并不将其pop出"栈"，输出：疯狂Android讲义</span></span><br><span class="line">        System.out.println(v.peek());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依然输出：[疯狂Java讲义, 轻量级Java EE企业应用实战 , 疯狂Android讲义]</span></span><br><span class="line">        System.out.println(v);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//pop出第一个元素，输出：疯狂Android讲义</span></span><br><span class="line">        System.out.println(v.pop());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出：[疯狂Java讲义, 轻量级Java EE企业应用实战]</span></span><br><span class="line">        System.out.println(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        LinkedList books = <span class="keyword">new</span> LinkedList();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将字符串元素加入队列的尾部(双端队列)</span></span><br><span class="line">        books.offer(<span class="string">"疯狂Java讲义"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将一个字符串元素加入栈的顶部(双端队列)</span></span><br><span class="line">        books.push(<span class="string">"轻量级Java EE企业应用实战"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将字符串元素添加到队列的头(相当于栈的顶部)</span></span><br><span class="line">        books.offerFirst(<span class="string">"疯狂Android讲义"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; books.size() ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(books.get(i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//访问、并不删除栈顶的元素</span></span><br><span class="line">        System.out.println(books.peekFirst());</span><br><span class="line">        <span class="comment">//访问、并不删除队列的最后一个元素</span></span><br><span class="line">        System.out.println(books.peekLast());</span><br><span class="line">        <span class="comment">//将栈顶的元素弹出"栈"</span></span><br><span class="line">        System.out.println(books.pop());</span><br><span class="line">        <span class="comment">//下面输出将看到队列中第一个元素被删除</span></span><br><span class="line">        System.out.println(books);</span><br><span class="line">        <span class="comment">//访问、并删除队列的最后一个元素</span></span><br><span class="line">        System.out.println(books.pollLast());</span><br><span class="line">        <span class="comment">//下面输出将看到队列中只剩下中间一个元素：</span></span><br><span class="line">        <span class="comment">//轻量级Java EE企业应用实战</span></span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以看到，LinkedList同时表现出了双端队列、栈的用法。功能非常强大</p><h3 id="Queue-1"><a href="#Queue-1" class="headerlink" title="Queue"></a>Queue</h3><h4 id="PriorityQueue-1"><a href="#PriorityQueue-1" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueueTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        PriorityQueue pq = <span class="keyword">new</span> PriorityQueue();</span><br><span class="line">        <span class="comment">//下面代码依次向pq中加入四个元素</span></span><br><span class="line">        pq.offer(<span class="number">6</span>);</span><br><span class="line">        pq.offer(-<span class="number">3</span>);</span><br><span class="line">        pq.offer(<span class="number">9</span>);</span><br><span class="line">        pq.offer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出pq队列，并不是按元素的加入顺序排列，</span></span><br><span class="line">        <span class="comment">//而是按元素的大小顺序排列，输出[-3, 0, 9, 6]</span></span><br><span class="line">        System.out.println(pq);</span><br><span class="line">        <span class="comment">//访问队列第一个元素，其实就是队列中最小的元素：-3</span></span><br><span class="line">        System.out.println(pq.poll());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PriorityQueue不允许插入null元素，它还需要对队列元素进行排序，PriorityQueue的元素有两种排序方式</p><blockquote><p>1) 自然排序:采用自然顺序的PriorityQueue集合中的元素对象都必须实现了Comparable接口，而且应该是同一个类的多个实例，否则可能导致ClassCastException异常<br>2) 定制排序:创建PriorityQueue队列时，传入一个Comparator对象，该对象负责对队列中的所有元素进行排序。<br>关于自然排序、定制排序的原理和之前说的TreeSet类似</p></blockquote><h4 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDequeTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ArrayDeque stack = <span class="keyword">new</span> ArrayDeque();</span><br><span class="line">        <span class="comment">//依次将三个元素push入"栈"</span></span><br><span class="line">        stack.push(<span class="string">"疯狂Java讲义"</span>);</span><br><span class="line">        stack.push(<span class="string">"轻量级Java EE企业应用实战"</span>);</span><br><span class="line">        stack.push(<span class="string">"疯狂Android讲义"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出：[疯狂Java讲义, 轻量级Java EE企业应用实战 , 疯狂Android讲义]</span></span><br><span class="line">        System.out.println(stack);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//访问第一个元素，但并不将其pop出"栈"，输出：疯狂Android讲义</span></span><br><span class="line">        System.out.println(stack.peek());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依然输出：[疯狂Java讲义, 轻量级Java EE企业应用实战 , 疯狂Android讲义]</span></span><br><span class="line">        System.out.println(stack);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//pop出第一个元素，输出：疯狂Android讲义</span></span><br><span class="line">        System.out.println(stack.pop());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出：[疯狂Java讲义, 轻量级Java EE企业应用实战]</span></span><br><span class="line">        System.out.println(stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是List集合类的编程应用场景。我们来梳理一下思路:</p><blockquote><ol><li>java提供的List就是一个”线性表接口”，ArrayList(基于数组的线性表)、LinkedList(基于链的线性表)是线性表的两种典型实现</li><li>Queue代表了队列，Deque代表了双端队列(既可以作为队列使用、也可以作为栈使用)</li><li>因为数组以一块连续内存来保存所有的数组元素，所以数组在随机访问时性能最好。所以的内部以数组作为底层实现的集合在随机访问时性能最好。</li><li>内部以链表作为底层实现的集合在执行插入、删除操作时有很好的性能</li><li>进行迭代操作时，以链表作为底层实现的集合比以数组作为底层实现的集合性能好</li></ol></blockquote><p>我们之前说过，Collection接口继承了Iterable接口，也就是说，我们以上学习到的所有的Collection集合类都具有”可遍历性”。</p><p>Iterable接口也是java集合框架的成员，它隐藏了各种Collection实现类的底层细节，向应用程序提供了遍历Collection集合元素的统一编程接口:</p><blockquote><p>1) boolean hasNext(): 是否还有下一个未遍历过的元素<br>2) Object next(): 返回集合里的下一个元素<br>3) void remove(): 删除集合里上一次next方法返回的元素</p></blockquote><p><strong>iterator实现遍历:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个集合</span></span><br><span class="line">        Collection books = <span class="keyword">new</span> HashSet();</span><br><span class="line">        books.add(<span class="string">"轻量级Java EE企业应用实战"</span>);</span><br><span class="line">        books.add(<span class="string">"疯狂Java讲义"</span>);</span><br><span class="line">        books.add(<span class="string">"疯狂Android讲义"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取books集合对应的迭代器</span></span><br><span class="line">        Iterator it = books.iterator();</span><br><span class="line">        <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">            <span class="comment">//it.next()方法返回的数据类型是Object类型，</span></span><br><span class="line">            <span class="comment">//需要强制类型转换</span></span><br><span class="line">            String book = (String)it.next();</span><br><span class="line">            System.out.println(book);</span><br><span class="line">            <span class="keyword">if</span> (book.equals(<span class="string">"疯狂Java讲义"</span>))&#123;</span><br><span class="line">                <span class="comment">//从集合中删除上一次next方法返回的元素</span></span><br><span class="line">                it.remove();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对book变量赋值，不会改变集合元素本身</span></span><br><span class="line">            book = <span class="string">"测试字符串"</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码可以看出，iterator必须依附于Collection对象，若有一个iterator对象，必然有一个与之关联的Collection对象。</p><p>除了可以使用iterator接口迭代访问Collection集合里的元素之外，使用java5提供的foreach循环迭代访问集合元素更加便捷</p><p><strong>foreach实现遍历:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForeachTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个集合</span></span><br><span class="line">        Collection books = <span class="keyword">new</span> HashSet();</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"轻量级Java EE企业应用实战"</span>));</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"疯狂Java讲义"</span>));</span><br><span class="line">        books.add(<span class="keyword">new</span> String(<span class="string">"疯狂Android讲义"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object obj : books)&#123;</span><br><span class="line">            <span class="comment">//此处的book变量也不是集合元素本身</span></span><br><span class="line">            String book = (String)obj;</span><br><span class="line">            System.out.println(book);</span><br><span class="line">            <span class="keyword">if</span> (book.equals(<span class="string">"疯狂Android讲义"</span>))&#123;</span><br><span class="line">                <span class="comment">//下面代码会引发ConcurrentModificationException异常</span></span><br><span class="line">                <span class="comment">//books.remove(book);      </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(books);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了Collection固有的iterator()方法，List还额外提供了一个listIterator()方法，该方法返回一个ListIterator对象，ListIterator接口继承了Iterator接口，提供了专门操作List的方法。ListIterator接口在Iterator接口的继承上增加了如下方法:</p><blockquote><p>1) boolean hasPrevious(): 返回该迭代器关联的集合是否还有上一个元素<br>2) Object previous(): 返回该迭代器的上一个元素(向前迭代)<br>3) void add(): 在指定位置插入一个元素</p></blockquote><p><strong>ListIterator实现遍历:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListIteratorTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String[] books = &#123;</span><br><span class="line">            <span class="string">"疯狂Java讲义"</span>,</span><br><span class="line">            <span class="string">"轻量级Java EE企业应用实战"</span></span><br><span class="line">        &#125;;</span><br><span class="line">        List bookList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; books.length ; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            bookList.add(books[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        ListIterator lit = bookList.listIterator();</span><br><span class="line">        <span class="keyword">while</span> (lit.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(lit.next());</span><br><span class="line">            lit.add(<span class="string">"-------分隔符-------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"=======下面开始反向迭代======="</span>);</span><br><span class="line">        <span class="keyword">while</span>(lit.hasPrevious())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(lit.previous());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map-2"><a href="#Map-2" class="headerlink" title="Map"></a>Map</h3><h4 id="HashMap、Hashtable"><a href="#HashMap、Hashtable" class="headerlink" title="HashMap、Hashtable"></a>HashMap、Hashtable</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据count的值来判断两个对象是否相等。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj!=<span class="keyword">null</span> &amp;&amp;obj.getClass()==A.class)&#123;</span><br><span class="line">            A a = (A)obj;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.count == a.count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据count来计算hashCode值。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span>&#123;</span><br><span class="line">    <span class="comment">//重写equals()方法，B对象与任何对象通过equals()方法比较都相等</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashtableTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Hashtable ht = <span class="keyword">new</span> Hashtable();</span><br><span class="line">        ht.put(<span class="keyword">new</span> A(<span class="number">60000</span>) , <span class="string">"疯狂Java讲义"</span>);</span><br><span class="line">        ht.put(<span class="keyword">new</span> A(<span class="number">87563</span>) , <span class="string">"轻量级Java EE企业应用实战"</span>);</span><br><span class="line">        ht.put(<span class="keyword">new</span> A(<span class="number">1232</span>) , <span class="keyword">new</span> B());</span><br><span class="line">        System.out.println(ht);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只要两个对象通过equals比较返回true，</span></span><br><span class="line">        <span class="comment">//Hashtable就认为它们是相等的value。</span></span><br><span class="line">        <span class="comment">//由于Hashtable中有一个B对象，</span></span><br><span class="line">        <span class="comment">//它与任何对象通过equals比较都相等，所以下面输出true。</span></span><br><span class="line">        System.out.println(ht.containsValue(<span class="string">"测试字符串"</span>));  <span class="comment">//①</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//只要两个A对象的count相等，它们通过equals比较返回true，且hashCode相等</span></span><br><span class="line">        <span class="comment">//Hashtable即认为它们是相同的key，所以下面输出true。</span></span><br><span class="line">        System.out.println(ht.containsKey(<span class="keyword">new</span> A(<span class="number">87563</span>)));   <span class="comment">//②</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面语句可以删除最后一个key-value对</span></span><br><span class="line">        ht.remove(<span class="keyword">new</span> A(<span class="number">1232</span>));    <span class="comment">//③</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过返回Hashtable的所有key组成的Set集合，</span></span><br><span class="line">        <span class="comment">//从而遍历Hashtable每个key-value对</span></span><br><span class="line">        <span class="keyword">for</span> (Object key : ht.keySet())</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(key + <span class="string">"----&gt;"</span>);</span><br><span class="line">            System.out.print(ht.get(key) + <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用自定义类作为HashMap、Hashtable的key时，如果重写该类的equals(Object obj)和hashCode()方法，则应该保证两个方法的判断标准一致–当两个key通过equals()方法比较返回true时，两个key的hashCode()的返回值也应该相同</p><h4 id="LinkedHashMap-1"><a href="#LinkedHashMap-1" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashMapTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        LinkedHashMap scores = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">        scores.put(<span class="string">"语文"</span> , <span class="number">80</span>);</span><br><span class="line">        scores.put(<span class="string">"英文"</span> , <span class="number">82</span>);</span><br><span class="line">        scores.put(<span class="string">"数学"</span> , <span class="number">76</span>);</span><br><span class="line">        <span class="comment">//遍历scores里的所有的key-value对</span></span><br><span class="line">        <span class="keyword">for</span> (Object key : scores.keySet())&#123;</span><br><span class="line">            System.out.println(key + <span class="string">"------&gt;"</span> + scores.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Properties-1"><a href="#Properties-1" class="headerlink" title="Properties"></a>Properties</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//向Properties中增加属性</span></span><br><span class="line">        props.setProperty(<span class="string">"username"</span> , <span class="string">"yeeku"</span>);</span><br><span class="line">        props.setProperty(<span class="string">"password"</span> , <span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将Properties中的key-value对保存到a.ini文件中</span></span><br><span class="line">        props.store(<span class="keyword">new</span> FileOutputStream(<span class="string">"a.ini"</span>), <span class="string">"comment line"</span>);   <span class="comment">//①</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//新建一个Properties对象</span></span><br><span class="line">        Properties props2 = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//向Properties中增加属性</span></span><br><span class="line">        props2.setProperty(<span class="string">"gender"</span> , <span class="string">"male"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将a.ini文件中的key-value对追加到props2中</span></span><br><span class="line">        props2.load(<span class="keyword">new</span> FileInputStream(<span class="string">"a.ini"</span>) );    <span class="comment">//②</span></span><br><span class="line">        System.out.println(props2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Properties还可以把key-value对以XML文件的形式保存起来，也可以从XML文件中加载key-value对</p><h4 id="TreeMap-1"><a href="#TreeMap-1" class="headerlink" title="TreeMap"></a>TreeMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">R</span> <span class="keyword">implements</span> <span class="title">Comparable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">R</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"R[count:"</span> + count + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据count来判断两个对象是否相等。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == obj)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj!=<span class="keyword">null</span>&amp;&amp; obj.getClass()==R.class)&#123;</span><br><span class="line">            R r = (R)obj;</span><br><span class="line">            <span class="keyword">return</span> r.count == <span class="keyword">this</span>.count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据count属性值来判断两个对象的大小。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">        R r = (R)obj;</span><br><span class="line">        <span class="keyword">return</span> count &gt; r.count ? <span class="number">1</span> :</span><br><span class="line">            count &lt; r.count ? -<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMapTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TreeMap tm = <span class="keyword">new</span> TreeMap();</span><br><span class="line">        tm.put(<span class="keyword">new</span> R(<span class="number">3</span>) , <span class="string">"轻量级Java EE企业应用实战"</span>);</span><br><span class="line">        tm.put(<span class="keyword">new</span> R(-<span class="number">5</span>) , <span class="string">"疯狂Java讲义"</span>);</span><br><span class="line">        tm.put(<span class="keyword">new</span> R(<span class="number">9</span>) , <span class="string">"疯狂Android讲义"</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(tm);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回该TreeMap的第一个Entry对象</span></span><br><span class="line">        System.out.println(tm.firstEntry());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回该TreeMap的最后一个key值</span></span><br><span class="line">        System.out.println(tm.lastKey());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回该TreeMap的比new R(2)大的最小key值。</span></span><br><span class="line">        System.out.println(tm.higherKey(<span class="keyword">new</span> R(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回该TreeMap的比new R(2)小的最大的key-value对。</span></span><br><span class="line">        System.out.println(tm.lowerEntry(<span class="keyword">new</span> R(<span class="number">2</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回该TreeMap的子TreeMap</span></span><br><span class="line">        System.out.println(tm.subMap(<span class="keyword">new</span> R(-<span class="number">1</span>) , <span class="keyword">new</span> R(<span class="number">4</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，类似于TreeSet中判断两个元素是否相等的标准，TreeMap中判断两个key相等的标准是: </p><blockquote><p>1) 两个key通过compareTo()方法返回0<br>2) equals()放回true</p></blockquote><p><strong>我们在重写这两个方法的时候一定要保证它们的逻辑关系一致。</strong></p><p>再次强调一下:</p><p>Set和Map的关系十分密切，java源码就是先实现了HashMap、TreeMap等集合，然后通过包装一个所有的value都为null的Map集合实现了Set集合类</p><h4 id="WeakHashMap-1"><a href="#WeakHashMap-1" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakHashMapTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        WeakHashMap whm = <span class="keyword">new</span> WeakHashMap();</span><br><span class="line">        <span class="comment">//将WeakHashMap中添加三个key-value对，</span></span><br><span class="line">        <span class="comment">//三个key都是匿名字符串对象（没有其他引用）</span></span><br><span class="line">        whm.put(<span class="keyword">new</span> String(<span class="string">"语文"</span>) , <span class="keyword">new</span> String(<span class="string">"良好"</span>));</span><br><span class="line">        whm.put(<span class="keyword">new</span> String(<span class="string">"数学"</span>) , <span class="keyword">new</span> String(<span class="string">"及格"</span>));</span><br><span class="line">        whm.put(<span class="keyword">new</span> String(<span class="string">"英文"</span>) , <span class="keyword">new</span> String(<span class="string">"中等"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将WeakHashMap中添加一个key-value对，</span></span><br><span class="line">        <span class="comment">//该key是一个系统缓存的字符串对象。"java"是一个常量字符串强引用</span></span><br><span class="line">        whm.put(<span class="string">"java"</span> , <span class="keyword">new</span> String(<span class="string">"中等"</span>));</span><br><span class="line">        <span class="comment">//输出whm对象，将看到4个key-value对。</span></span><br><span class="line">        System.out.println(whm);</span><br><span class="line">        <span class="comment">//通知系统立即进行垃圾回收</span></span><br><span class="line">        System.gc();</span><br><span class="line">        System.runFinalization();</span><br><span class="line">        <span class="comment">//通常情况下，将只看到一个key-value对。</span></span><br><span class="line">        System.out.println(whm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要使用WeakHashMap的key来保留对象的弱引用，则不要让key所引用的对象具有任何强引用，否则将失去使用WeakHashMap的意义</p><h4 id="IdentityHashMap-1"><a href="#IdentityHashMap-1" class="headerlink" title="IdentityHashMap"></a>IdentityHashMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdentityHashMapTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        IdentityHashMap ihm = <span class="keyword">new</span> IdentityHashMap();</span><br><span class="line">        <span class="comment">//下面两行代码将会向IdentityHashMap对象中添加两个key-value对</span></span><br><span class="line">        ihm.put(<span class="keyword">new</span> String(<span class="string">"语文"</span>) , <span class="number">89</span>);</span><br><span class="line">        ihm.put(<span class="keyword">new</span> String(<span class="string">"语文"</span>) , <span class="number">78</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//下面两行代码只会向IdentityHashMap对象中添加一个key-value对</span></span><br><span class="line">        ihm.put(<span class="string">"java"</span> , <span class="number">93</span>);</span><br><span class="line">        ihm.put(<span class="string">"java"</span> , <span class="number">98</span>);</span><br><span class="line">        System.out.println(ihm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="EnumMap-1"><a href="#EnumMap-1" class="headerlink" title="EnumMap"></a>EnumMap</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> Season</span><br><span class="line">&#123;</span><br><span class="line">    SPRING,SUMMER,FALL,WINTER</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumMapTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一个EnumMap对象，该EnumMap的所有key</span></span><br><span class="line">        <span class="comment">//必须是Season枚举类的枚举值</span></span><br><span class="line">        EnumMap enumMap = <span class="keyword">new</span> EnumMap(Season.class);</span><br><span class="line">        enumMap.put(Season.SUMMER , <span class="string">"夏日炎炎"</span>);</span><br><span class="line">        enumMap.put(Season.SPRING , <span class="string">"春暖花开"</span>);</span><br><span class="line">        System.out.println(enumMap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与创建普通Map有所区别的是，创建EnumMap是必须指定一个枚举类，从而将该EnumMap和指定枚举类关联起来。</p><p><strong>以上就是Map集合类的编程应用场景。我们来梳理一下思路:</strong></p><blockquote><p>1) HashMap和Hashtable的效率大致相同，因为它们的实现机制几乎完全一样。但HashMap通常比Hashtable要快一点，因为Hashtable需要额外的线程同步控制<br>2) TreeMap通常比HashMap、Hashtable要慢(尤其是在插入、删除key-value对时更慢)，因为TreeMap底层采用红黑树来管理key-value对<br>3) 使用TreeMap的一个好处就是： TreeMap中的key-value对总是处于有序状态，无须专门进行排序操作</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java集合类基本概念&quot;&gt;&lt;a href=&quot;#Java集合类基本概念&quot; class=&quot;headerlink&quot; title=&quot;Java集合类基本概念&quot;&gt;&lt;/a&gt;Java集合类基本概念&lt;/h2&gt;&lt;p&gt;在编程中，常常需要集中存放多个数据。从传统意义上讲，数组是我们的一个很好的选择，前提是我们事先已经明确知道我们将要保存的对象的数量。一旦在数组初始化时指定了这个数组长度，这个数组长度就是不可变的，如果我们需要保存一个可以动态增长的数据(在编译时无法确定具体的数量)，java的集合类就是一个很好的设计方案了。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.atecher.com/categories/Java/"/>
    
    
      <category term="Java基础" scheme="http://blog.atecher.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="集合" scheme="http://blog.atecher.com/tags/%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java-Proxy</title>
    <link href="http://blog.atecher.com/2017/09/22/Java-Proxy/"/>
    <id>http://blog.atecher.com/2017/09/22/Java-Proxy/</id>
    <published>2017-09-22T00:00:00.000Z</published>
    <updated>2022-01-28T10:28:39.119Z</updated>
    
    <content type="html"><![CDATA[<p>Proxy,也就是“代理”了。意思就是,你不用去做,别人代替你去处理.<br>它在程序开发中起到了非常重要的作用,比如传说中的 AOP(面向切面编程),就是针对代理的一种应用。此外,在设计模式中,还有一个“代理模式”。</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="什么是代理"><a href="#什么是代理" class="headerlink" title="什么是代理:"></a>什么是代理:</h3><p>代理分为静态代理和动态代理<br>静态代理是在编译时就将接口、实现类、代理类一股脑儿全部手动完成,但如果我们需要很多的代理,每一个都这么手动的去创建实属浪费时间,而且会有大量的重复代码,此时我们就可以采用动态代理<br>动态代理可以在程序运行期间根据需要动态的创建代理类及其实例,来完成具体的功能,主要用的是JAVA的反射机制。</p><p>其实方法直接调用就可以完成功能,为什么还要加个代理呢？<br><strong>原因是采用代理模式可以有效的将具体的实现与调用方进行解耦,通过面向接口进行编码完全将具体的实现隐藏在内部。</strong></p><p>Proxy代理模式是一种结构型设计模式,主要解决的问题是:在直接访问对象时带来的问题</p><p>代理是一种常用的设计模式,其目的就是为其他对象提供一个代理以控制对某个对象的访问。代理类负责为委托类预处理消息,过滤消息并转发消息,以及进行消息被委托类执行后的后续处理。</p><p>更通俗的说,代理解决的问题当两个类需要通信时,引入第三方代理类,将两个类的关系解耦,让我们只了解代理类即可,而且代理的出现还可以让我们完成与另一个类之间的关系的统一管理,但是切记,代理类和委托类要实现相同的接口,因为代理真正调用的还是委托类的方法。</p><p>按照代理的创建时期,代理类可以分为两种:</p><ul><li>静态:由程序员创建代理类或特定工具自动生成源代码再对其编译。在程序运行前代理类的.class文件就已经存在了。</li><li>动态:在程序运行时运用反射机制动态创建而成。</li></ul><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>实代理的一般模式就是静态代理的实现模式:首先创建一个接口(JDK代理都是面向接口的),然后创建具体实现类来实现这个接口,在创建一个代理类同样实现这个接口,不同指出在于,具体实现类的方法中需要将接口中定义的方法的业务逻辑功能实现,而代理类中的方法只要调用具体类中的对应方法即可,这样我们在需要使用接口中的某个方法的功能时直接调用代理类的方法即可,将具体的实现类隐藏在底层。</p><p>第一步:定义总接口Iuser.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iuser</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二步:创建具体实现类UserImpl.java (被代理人)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImpl</span> <span class="keyword">implements</span> <span class="title">Iuser</span> </span>&#123;</span><br><span class="line">　　<span class="meta">@Override</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">　　　　System.out.println(<span class="string">"我要吃"</span>+s);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第三步:创建代理类UserProxy.java (代理人)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserProxy</span> <span class="keyword">implements</span> <span class="title">Iuser</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">private</span> Iuser user = <span class="keyword">new</span> UserImpl();</span><br><span class="line">　　<span class="meta">@Override</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">　　　　System.out.println(<span class="string">"静态代理前置内容"</span>);</span><br><span class="line">　　　　user.eat(s);</span><br><span class="line">　　　　System.out.println(<span class="string">"静态代理后置内容"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第四步:创建测试类ProxyTest.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;    </span><br><span class="line">　　　　UserProxy proxy = <span class="keyword">new</span> UserProxy();</span><br><span class="line">　　　　proxy.eat(<span class="string">"苹果"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">静态代理前置内容</span><br><span class="line">我要吃苹果</span><br><span class="line">静态代理后置内容</span><br></pre></td></tr></table></figure></p><p>综上的代码和输出结果可以看出,静态代理的实现方法还是很简单的。都需要实现总接口,代理人里面持有被代理人的对象。代理人可以根据情况的不同,添加一些操作。</p><h2 id="静态代理类优缺点"><a href="#静态代理类优缺点" class="headerlink" title="静态代理类优缺点"></a>静态代理类优缺点</h2><ul><li>优点 代理使客户端不需要知道实现类是什么,怎么做的,而客户端只需知道代理即可(解耦合)。</li><li><p>缺点:</p><ol><li>代理类和委托类实现了相同的接口,代理类通过委托类实现了相同的方法。这样就出现了大量的代码重复。如果接口增加一个方法,除了所有实现类需要实现这个方法外,所有代理类也需要实现此方法。增加了代码维护的复杂度。</li><li>代理对象只服务于一种类型的对象,如果要服务多类型的对象。势必要为每一种对象都进行代理,静态代理在程序规模稍大时就无法胜任了</li></ol></li></ul><p>举例说明:代理可以对实现类进行统一的管理,如在调用具体实现类之前,需要打印日志等信息,这样我们只需要添加一个代理类,在代理类中添加打印日志的功能,然后调用实现类,这样就避免了修改具体实现类。满足我们所说的开闭原则。但是如果想让每个实现类都添加打印日志的功能的话,就需要添加多个代理类,以及代理类中各个方法都需要添加打印日志功能(如上的代理方法中删除,修改,以及查询都需要添加上打印日志的功能)<br>即静态代理类只能为特定的接口(Service)服务。如想要为多个接口服务则需要建立很多个代理类。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>动态代理的思维模式与之前的一般模式是一样的,也是面向接口进行编码,创建代理类将具体类隐藏解耦,不同之处在于代理类的创建时机不同,动态代理需要在运行时因需实时创建。</p><p>第一步:定义总接口Iuser.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iuser</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String s)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二步:创建具体实现类UserImpl.java (被代理人)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImpl</span> <span class="keyword">implements</span> <span class="title">Iuser</span> </span>&#123;</span><br><span class="line">　　<span class="meta">@Override</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">　　　　System.out.println(<span class="string">"我要吃"</span>+s);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第三步:创建实现InvocationHandler接口的代理类 (代理人)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态代理类只能代理接口(不支持抽象类),代理类都需要实现InvocationHandler类,实现invoke方法。该invoke方法就是调用被代理接口的所有方法时需要调用的,该invoke方法返回的值是被代理接口的一个实现类  </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">private</span> Object object;<span class="comment">//用于接收具体实现类的实例对象</span></span><br><span class="line">　　<span class="comment">//使用带参数的构造器来传递具体实现类的对象</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">　　　　<span class="keyword">this</span>.object = obj;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="meta">@Override</span></span><br><span class="line">　　<span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">　　　　System.out.println(<span class="string">"前置内容"</span>);</span><br><span class="line">　　　　method.invoke(object, args);</span><br><span class="line">　　　　System.out.println(<span class="string">"后置内容"</span>);</span><br><span class="line">　　　　<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第四步:创建测试类ProxyTest.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">　　　　Iuser user = <span class="keyword">new</span> UserImpl();</span><br><span class="line">　　　　InvocationHandler h = <span class="keyword">new</span> DynamicProxy(user);</span><br><span class="line">　　　　Iuser proxy = (Iuser) Proxy.newProxyInstance(Iuser.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;Iuser.class&#125;, h);</span><br><span class="line">　　　　proxy.eat(<span class="string">"苹果"</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">动态代理前置内容</span><br><span class="line">我要吃苹果</span><br><span class="line">动态代理后置内容</span><br></pre></td></tr></table></figure></p><p>第五步:重构</p><p>要注意的是,Proxy.newProxyInstance() 方法的参数实在是让人难以忍受</p><ul><li>参数1:ClassLoader</li><li>参数2:该实现类的所有接口</li><li>参数3:动态代理对象</li></ul><p>调用完了还要来一个强制类型转换一下。</p><p>一定要想办法封装一下,避免再次发生到处都是 Proxy.newProxyInstance()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">            target.getClass().getClassLoader(),</span><br><span class="line">            target.getClass().getInterfaces(),</span><br><span class="line">            <span class="keyword">this</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我在 DynamicProxy 里添加了一个 getProxy() 方法,无需传入任何参数,将刚才所说的那些参数,放在这个方法中,并且该方法返回一个泛型类型,就不会强制类型转换了。方法头上加那个 @SuppressWarnings(“unchecked”) 注解表示忽略编译时的警告(因为 Proxy.newProxyInstance() 方法返回的是一个 Object,这里我强制转换为 T 了,这是向下转型,IDE 中就会有警告,编译时也会出现提示,很烦)。</p><p>好了,这下子使用 DynamicProxy 就简单了吧:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy(<span class="keyword">new</span> UserImpl());</span><br><span class="line">    Iuser proxy = dynamicProxy.getProxy();</span><br><span class="line">    proxy.eat(<span class="string">"苹果"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="代理没有接口的类"><a href="#代理没有接口的类" class="headerlink" title="代理没有接口的类"></a>代理没有接口的类</h2><p>用了这个 DynamicProxy 以后,我觉得它还是非常爽的,爽的地方是,接口变了,这个动态代理类不用动。而静态代理就不一样了,接口变了,实现类还要动,代理类也要动。但我也发现动态代理并不是“万灵丹”,它也有搞不定的时候,比如说,我要代理一个没有任何接口的类,它就没有勇武之地了</p><p>能否代理没有接口的类呢？<br>那就是 CGLib 这个类库。虽然它看起来不太起眼,但 Spring、Hibernate 这样牛逼的开源框架都用到了它。它就是一个在运行期间动态生成字节码的工具,也就是动态生成代理类了。说起来好高深,实际用起来一点都不难。我再写一个 CGLibProxy 吧:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Class&lt;T&gt; cls)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Enhancer.create(cls, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">        after();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要实现 CGLib 给我们提供的 MethodInterceptor 实现类,并填充 intercept() 方法。方法中最后一个 MethodProxy 类型的参数 proxy,值得注意！CGLib 给我们提供的是方法级别的代理,也可以理解为对方法的拦截(这不就是传说中的“方法拦截器”吗？)。我们直接调用 proxy 的 invokeSuper() 方法,将被代理的对象 obj 以及方法参数 args 传入其中即可。</p><p>与 DynamicProxy 类似,我在 CGlibProxy 中也添加了一个泛型的 getProxy() 方法,便于我们可以快速地获取自动生成的代理对象。还是用一个 main() 方法来描述吧:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    CGLibProxy cgLibProxy = <span class="keyword">new</span> CGLibProxy();</span><br><span class="line">    UserImpl proxy = cgLibProxy.getProxy(UserImpl.class);</span><br><span class="line">    proxy.eat(<span class="string">"苹果"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>与 JDK 动态代理不同的是,这里不需要任何的接口信息,对谁都可以生成动态代理对象</p><p>重构:<br>不想总是去 new 这个 CGLibProxy 对象,最好 new 一次,可以使用“单例模式”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CGLibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CGLibProxy instance = <span class="keyword">new</span> CGLibProxy();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//private 的构造方法,就是为了限制外界不能再去 new 它了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CGLibProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CGLibProxy <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    UserImpl userImpl = CGLibProxy.getInstance().getProxy(UserImpl.class);</span><br><span class="line">    userImpl.eat(<span class="string">"苹果"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="动态代理的实现过程"><a href="#动态代理的实现过程" class="headerlink" title="动态代理的实现过程"></a>动态代理的实现过程</h2><ol><li>首先我要说的就是接口，为什么JDK的动态代理是基于接口实现的呢？<br>　　因为通过使用接口指向实现类的实例的多态实现方式，可以有效的将具体的实现与调用之间解耦，便于后期修改与维护。<br>再具体的说就是我们在代理类中创建一个私有成员变量（private修饰），使用接口来指向实现类的对象（纯种的多态体现，向上转型的体现），然后在该代理类中的方法中使用这个创建的实例来调用实现类中的相应方法来完成业务逻辑功能。<br>这么说起来，我之前说的“将具体实现类完全隐藏”就不怎么正确了，可以改成，将具体实现类的细节向调用方完全隐藏（调用方调用的是代理类中的方法，而不是实现类中的方法）。<br>　　这就是面向接口编程，利用java的多态特性，实现程序代码的解耦。</li><li>创建代理类的过程<br>　　如果你了解静态代理，那么你会发现动态代理的实现其实与静态代理类似，都需要创建代理类，但是不同之处也很明显，创建方式不同！<br>　　不同之处体现在静态代理我们知根知底，我们知道要对哪个接口、哪个实现类来创建代理类，所以我们在编译前就直接实现与实现类相同的接口，直接在实现的方法中调用实现类中的相应（同名）方法即可；而动态代理不同，我们不知道它什么时候创建，也不知道要创建针对哪个接口、实现类的代理类（因为它是在运行时因需实时创建的）。<br>　　虽然二者创建时机不同，创建方式也不相同，但是原理是相同的，不同之处仅仅是：静态代理可以直接编码创建，而动态代理是利用反射机制来抽象出代理类的创建过程。</li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ol><li>静态代理需要实现与实现类相同的接口，而动态代理需要实现的是固定的Java提供的内置接口（一种专门提供来创建动态代理的接口）InvocationHandler接口，因为java在接口中提供了一个可以被自动调用的方法invoke，这个之后再说。</li><li>先看代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Object object;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UserProxy</span><span class="params">(Object obj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.object = obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>这几行代码与静态代理之中在代理类中定义的接口指向具体实现类的实例的代码异曲同工，通过这个构造器可以创建代理类的实例，创建的同时还能将具体实现类的实例与之绑定（object指的就是实现类的实例，这个实例需要在测试类中创建并作为参数来创建代理类的实例），实现了静态代理类中private Iuser user = new UserImpl();一行代码的作用相近，这里为什么不是相同，而是相近呢，主要就是因为静态代理的那句代码中包含的实现类的实例的创建，而动态代理中实现类的创建需要在测试类中完成，所以此处是相近。</p><ol><li>invoke(Object proxy, Method method, Object[] args)方法，该方法是InvocationHandler接口中定义的唯一方法，该方法在调用指定的具体方法时会自动调用。其参数为：代理实例、调用的方法、方法的参数列表<br>　　在这个方法中我们定义了几乎和静态代理相同的内容，仅仅是在方法的调用上不同，不同的原因与之前分析的一样（创建时机的不同，创建的方式的不同，即反射），Method类是反射机制中一个重要的类，用于封装方法，该类中有一个方法那就是invoke(Object object,Object…args)方法，其参数分别表示：所调用方法所属的类的对象和方法的参数列表，这里的参数列表正是从测试类中传递到代理类中的invoke方法三个参数中最后一个参数（调用方法的参数列表）中，在传递到method的invoke方法中的第二个参数中的（此处有点啰嗦）。</li><li>测试类中的异同<br>　　静态代理中我们测试类中直接创建代理类的对象，使用代理类的对象来调用其方法即可，若是别的接口（这里指的是别的调用方）要调用Iuser的方法，也可以使用此法<br>动态代理中要复杂的多，首先我们要将之前提到的实现类的实例创建（补充完整），然后利用这个实例作为参数，调用代理来的带参构造器来创建“代理类实例对象”，这里加引号的原因是因为它并不是真正的代理类的实例对象，而是创建真正代理类实例的一个参数，这个实现了InvocationHandler接口的类严格意义上来说并不是代理类，我们可以将其看作是创建代理类的必备中间环节，这是一个调用处理器，也就是处理方法调用的一个类，不是真正意义上的代理类，可以这么说：创建一个方法调用处理器实例。<br>　　下面才是真正的代理类实例的创建，之前创建的”代理类实例对象“仅仅是一个参数<br>　　　　Iuser proxy = (Iuser) Proxy.newProxyInstance(Iuser.class.getClassLoader(), new Class[]{Iuser.class}, h);<br>　　这里使用了动态代理所依赖的第二个重要类Proxy，此处使用了其静态方法来创建一个代理实例，其参数分别是：类加载器（可为父类的类加载器）、接口数组、方法调用处理器实例<br>　　这里同样使用了多态，使用接口指向代理类的实例，最后会用该实例来进行具体方法的调用即可。</li></ol><h2 id="动态代理优点"><a href="#动态代理优点" class="headerlink" title="动态代理优点"></a>动态代理优点</h2><p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。而且动态代理的应用使我们的类职责更加单一，复用性更强</p><p>ref:<br><a href="http://www.daidingkang.cc/2017/07/18/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" target="_blank" rel="noopener">http://www.daidingkang.cc/2017/07/18/Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</a><br><a href="https://my.oschina.net/huangyong/blog/159788" target="_blank" rel="noopener">https://my.oschina.net/huangyong/blog/159788</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Proxy,也就是“代理”了。意思就是,你不用去做,别人代替你去处理.&lt;br&gt;它在程序开发中起到了非常重要的作用,比如传说中的 AOP(面向切面编程),就是针对代理的一种应用。此外,在设计模式中,还有一个“代理模式”。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.atecher.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.atecher.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java-Thread-volatile</title>
    <link href="http://blog.atecher.com/2017/09/22/Java-Thread-volatile/"/>
    <id>http://blog.atecher.com/2017/09/22/Java-Thread-volatile/</id>
    <published>2017-09-22T00:00:00.000Z</published>
    <updated>2022-01-28T10:28:39.119Z</updated>
    
    <content type="html"><![CDATA[<p>volatile两大作用</p><ul><li>保证内存可见性</li><li>防止指令重排</li></ul><p>此外需注意volatile并不保证操作的原子性。</p><a id="more"></a><h2 id="内存可见性"><a href="#内存可见性" class="headerlink" title="内存可见性"></a>内存可见性</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><strong>JVM内存模型:主内存和线程独立的工作内存</strong></p><p>Java内存模型规定,对于多个线程共享的变量,存储在主内存当中,每个线程都有自己独立的工作内存(比如CPU的寄存器),线程只能访问自己的工作内存,不可以访问其它线程的工作内存。</p><p>工作内存中保存了主内存共享变量的副本,线程要操作这些共享变量,只能通过操作工作内存中的副本来实现,操作完毕之后再同步回到主内存当中。</p><p>如何保证多个线程操作主内存的数据完整性是一个难题,Java内存模型也规定了工作内存与主内存之间交互的协议,定义了8种原子操作:</p><ol><li>lock:将主内存中的变量锁定,为一个线程所独占</li><li>unclock:将lock加的锁定解除,此时其它的线程可以有机会访问此变量</li><li>read:将主内存中的变量值读到工作内存当中</li><li>load:将read读取的值保存到工作内存中的变量副本中。</li><li>use:将值传递给线程的代码执行引擎</li><li>assign:将执行引擎处理返回的值重新赋值给变量副本</li><li>store:将变量副本的值存储到主内存中。</li><li>write:将store存储的值写入到主内存的共享变量当中。</li></ol><p><strong>通过上面Java内存模型的概述,我们会注意到这么一个问题,每个线程在获取锁之后会在自己的工作内存来操作共享变量,操作完成之后将工作内存中的副本回写到主内存,并且在其它线程从主内存将变量同步回自己的工作内存之前,共享变量的改变对其是不可见的</strong>。其他线程的本地内存中的变量已经是过时的,并不是更新后的值。</p><h3 id="内存可见性带来的问题"><a href="#内存可见性带来的问题" class="headerlink" title="内存可见性带来的问题"></a>内存可见性带来的问题</h3><p>很多时候我们需要一个线程对共享变量的改动,其它线程也需要立即得知这个改动该怎么办呢？下面举两个例子说明内存可见性的重要性:</p><p>例子1<br>有一个全局的状态变量open:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> open=<span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></p><p>这个变量用来描述对一个资源的打开关闭状态,true表示打开,false表示关闭,假设有一个线程A,在执行一些操作后将open修改为false:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程A</span></span><br><span class="line">resource.close();</span><br><span class="line">open = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure></p><p>线程B随时关注open的状态,当open为true的时候通过访问资源来进行一些操作:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程B</span></span><br><span class="line"><span class="keyword">while</span>(open) &#123;</span><br><span class="line">    doSomethingWithResource(resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当A把资源关闭的时候,open变量对线程B是不可见的,如果此时open变量的改动尚未同步到线程B的工作内存中,那么线程B就会用一个已经关闭了的资源去做一些操作,因此产生错误。</p><p>例子2<br>下面是一个通过布尔标志判断线程是否结束的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CancelThreadTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        PrimeGenerator gen = <span class="keyword">new</span> PrimeGenerator();</span><br><span class="line">        newThread(gen).start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">           gen.cancel();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimeGenerator</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> cancelled;     </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!cancelled) &#123;</span><br><span class="line">           System.out.println(<span class="string">"Running..."</span>);</span><br><span class="line">           <span class="comment">//doingsomething here...</span></span><br><span class="line">        &#125;         </span><br><span class="line">    &#125;      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancel</span><span class="params">()</span></span>&#123;cancelled = <span class="keyword">true</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主线程中设置PrimeGenerator线程的是否取消标识,PrimeGenerator线程检测到这个标识后就会结束线程,由于主线程修改cancelled变量的内存可见性,主线程修改cancelled标识后并不马上同步回主内存,所以PrimeGenerator线程结束的时间难以把控(最终是一定会同步回主内存,让PrimeGenerator线程结束)。</p><p>如果PrimeGenerator线程执行一些比较关键的操作,主线程希望能够及时终止它,这时将cenceled用volatile关键字修饰就是必要的。</p><p><strong>特别注意:上面演示这个并不是正确的取消线程的方法,因为一旦PrimeGenerator线程中包含BolckingQueue.put()等阻塞方法,那么将可能永远不会去检查cancelled标识,导致线程永远不会退出。正确的方法参见另外一篇关于如何正确终止线程的方法。</strong></p><h3 id="提供内存可见性"><a href="#提供内存可见性" class="headerlink" title="提供内存可见性"></a>提供内存可见性</h3><p>volatile保证可见性的原理是在每次访问变量时都会进行一次刷新,因此每次访问都是主内存中最新的版本。所以volatile关键字的作用之一就是保证变量修改的实时可见性。</p><p>针对上面的例子1:<br>要求一个线程对open的改变,其他的线程能够立即可见,Java为此提供了volatile关键字,在声明open变量的时候加入volatile关键字就可以保证open的内存可见性,即open的改变对所有的线程都是立即可见的。<br>备注:也可以通过提供synchronized同步的open变量的Get/Set方法解决此内存可见性问题,因为要Get变量open,必须等Set方完全释放锁之后。后面将介绍到两者的区别。</p><p>针对上面的例子2:<br>将cancelled标志设置的volatile保证主线程针对cancelled标识的修改能够让PrimeGenerator线程立马看到。</p><h2 id="指令重排"><a href="#指令重排" class="headerlink" title="指令重排"></a>指令重排</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><p>指令重排序是JVM为了优化指令,提高程序运行效率,在不影响单线程程序执行结果的前提下,尽可能地提高并行度。编译器、处理器也遵循这样一个目标。注意是单线程。多线程的情况下指令重排序就会给程序员带来问题。</p><p>不同的指令间可能存在数据依赖。比如下面计算圆的面积的语句:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> r = <span class="number">2.3</span>d;<span class="comment">//(1)</span></span><br><span class="line"><span class="keyword">double</span> pi =<span class="number">3.1415926</span>; <span class="comment">//(2)</span></span><br><span class="line"><span class="keyword">double</span> area = pi* r * r; <span class="comment">//(3)</span></span><br></pre></td></tr></table></figure></p><p>area的计算依赖于r与pi两个变量的赋值指令。而r与pi无依赖关系。</p><p>as-if-serial语义是指:不管如何重排序(编译器与处理器为了提高并行度),(单线程)程序的结果不能被改变。这是编译器、Runtime、处理器必须遵守的语义。</p><p>虽然,(1) – happensbefore -&gt; (2),(2) – happens before -&gt; (3),但是计算顺序(1)(2)(3)与(2)(1)(3) 对于r、pi、area变量的结果并无区别。编译器、Runtime在优化时可以根据情况重排序(1)与(2),而丝毫不影响程序的结果。</p><p>指令重排序包括编译器重排序和运行时重排序。</p><h3 id="指令重排带来的问题"><a href="#指令重排带来的问题" class="headerlink" title="指令重排带来的问题"></a>指令重排带来的问题</h3><p>如果一个操作不是原子的,就会给JVM留下重排的机会。下面看几个例子:</p><p>例子1:A线程指令重排导致B线程出错<br>对于在同一个线程内,这样的改变是不会对逻辑产生影响的,但是在多线程的情况下指令重排序会带来问题。看下面这个情景:</p><p>在线程A中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context = loadContext();</span><br><span class="line">inited = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></p><p>在线程B中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!inited )&#123; <span class="comment">//根据线程A中对inited变量的修改决定是否使用context变量</span></span><br><span class="line">   sleep(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure></p><p>假设线程A中发生了指令重排序:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inited = <span class="keyword">true</span>;</span><br><span class="line">context = loadContext();</span><br></pre></td></tr></table></figure></p><p>那么B中很可能就会拿到一个尚未初始化或尚未初始化完成的context,从而引发程序错误。</p><p>例子2:指令重排导致单例模式失效<br>我们都知道一个经典的懒加载方式的双重判断单例模式:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        synchronzied(Singleton.class) &#123;</span><br><span class="line">           <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">               instance = <span class="keyword">new</span> Singleton();  <span class="comment">//非原子操作</span></span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> instance;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看似简单的一段赋值语句:instance= new Singleton(),但是很不幸它并不是一个原子操作,其实际上可以抽象为下面几条JVM指令:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate();    //1:分配对象的内存空间 </span><br><span class="line">ctorInstance(memory);  //2:初始化对象 </span><br><span class="line">instance =memory;     //3:设置instance指向刚分配的内存地址</span><br></pre></td></tr></table></figure></p><p>上面操作2依赖于操作1,但是操作3并不依赖于操作2,所以JVM是可以针对它们进行指令的优化重排序的,经过重排序后如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory =allocate();    //1:分配对象的内存空间 </span><br><span class="line">instance =memory;     //3:instance指向刚分配的内存地址,此时对象还未初始化</span><br><span class="line">ctorInstance(memory);  //2:初始化对象</span><br></pre></td></tr></table></figure></p><p>可以看到指令重排之后,instance指向分配好的内存放在了前面,而这段内存的初始化被排在了后面。<br>在线程A执行这段赋值语句,在初始化分配对象之前就已经将其赋值给instance引用,恰好另一个线程进入方法判断instance引用不为null,然后就将其返回使用,导致出错。</p><h2 id="防止指令重排"><a href="#防止指令重排" class="headerlink" title="防止指令重排"></a>防止指令重排</h2><p>除了前面内存可见性中讲到的volatile关键字可以保证变量修改的可见性之外,还有另一个重要的作用:<strong>在JDK1.5之后,可以使用volatile变量禁止指令重排序.</strong></p><p>解决方案:例子1中的inited和例子2中的instance以关键字volatile修饰之后,就会阻止JVM对其相关代码进行指令重排,这样就能够按照既定的顺序指执行。</p><p>volatile关键字通过提供“<strong>内存屏障</strong>”的方式来防止指令被重排序,为了实现volatile的内存语义,编译器在生成字节码时,会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</p><p>大多数的处理器都支持内存屏障的指令。</p><p>对于编译器来说,发现一个最优布置来最小化插入屏障的总数几乎不可能,为此,Java内存模型采取保守策略。下面是基于保守策略的JMM内存屏障插入策略:</p><ul><li>在每个volatile写操作的前面插入一个StoreStore屏障。</li><li>在每个volatile写操作的后面插入一个StoreLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadLoad屏障。</li><li>在每个volatile读操作的后面插入一个LoadStore屏障。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>volatile是轻量级同步机制</p><p>相对于synchronized块的代码锁,volatile应该是提供了一个轻量级的针对共享变量的锁,当我们在多个线程间使用共享变量进行通信的时候需要考虑将共享变量用volatile来修饰。</p><p>volatile是一种稍弱的同步机制,在访问volatile变量时不会执行加锁操作,也就不会执行线程阻塞,因此volatilei变量是一种比synchronized关键字更轻量级的同步机制。</p><h3 id="volatile使用建议"><a href="#volatile使用建议" class="headerlink" title="volatile使用建议"></a>volatile使用建议</h3><p>使用建议:在两个或者更多的线程需要访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中,或者为常量时,没必要使用volatile。</p><p>由于使用volatile屏蔽掉了JVM中必要的代码优化,所以在效率上比较低,因此一定在必要时才使用此关键字。</p><h3 id="volatile和synchronized区别"><a href="#volatile和synchronized区别" class="headerlink" title="volatile和synchronized区别"></a>volatile和synchronized区别</h3><ol><li>volatile不会进行加锁操作:<br>volatile变量是一种稍弱的同步机制在访问volatile变量时不会执行加锁操作,因此也就不会使执行线程阻塞,因此volatile变量是一种比synchronized关键字更轻量级的同步机制。</li><li>volatile变量作用类似于同步变量读写操作:<br>从内存可见性的角度看,写入volatile变量相当于退出同步代码块,而读取volatile变量相当于进入同步代码块。</li><li>volatile不如synchronized安全:<br>在代码中如果过度依赖volatile变量来控制状态的可见性,通常会比使用锁的代码更脆弱,也更难以理解。仅当volatile变量能简化代码的实现以及对同步策略的验证时,才应该使用它。一般来说,用同步机制会更安全些。</li><li>volatile无法同时保证内存可见性和原子性:<br>加锁机制(即同步机制)既可以确保可见性又可以确保原子性,而volatile变量只能确保可见性,原因是声明为volatile的简单变量如果当前值与该变量以前的值相关,那么volatile关键字不起作用,也就是说如下的表达式都不是原子操作:“count++”、“count = count+1”。</li></ol><h3 id="当且仅当满足以下所有条件时-才应该使用volatile变量"><a href="#当且仅当满足以下所有条件时-才应该使用volatile变量" class="headerlink" title="当且仅当满足以下所有条件时,才应该使用volatile变量:"></a>当且仅当满足以下所有条件时,才应该使用volatile变量:</h3><ol><li>对变量的写入操作不依赖变量的当前值,或者你能确保只有单个线程更新变量的值。</li><li>该变量没有包含在具有其他变量的不变式中。</li></ol><p>总结:在需要同步的时候,第一选择应该是synchronized关键字,这是最安全的方式,尝试其他任何方式都是有风险的。尤其在、jdK1.5之后,对synchronized同步机制做了很多优化,如:自适应的自旋锁、锁粗化、锁消除、轻量级锁等,使得它的性能明显有了很大的提升。</p><p>ref:<br><a href="http://www.importnew.com/23535.html" target="_blank" rel="noopener">http://www.importnew.com/23535.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;volatile两大作用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保证内存可见性&lt;/li&gt;
&lt;li&gt;防止指令重排&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外需注意volatile并不保证操作的原子性。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.atecher.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.atecher.com/tags/Java/"/>
    
      <category term="volatile" scheme="http://blog.atecher.com/tags/volatile/"/>
    
  </entry>
  
</feed>
